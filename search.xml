<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>vue3项目搭建规范</title>
      <link href="/2024/07/20/vue3%E9%A1%B9%E7%9B%AE%E6%90%AD%E5%BB%BA%E8%A7%84%E8%8C%83/"/>
      <url>/2024/07/20/vue3%E9%A1%B9%E7%9B%AE%E6%90%AD%E5%BB%BA%E8%A7%84%E8%8C%83/</url>
      
        <content type="html"><![CDATA[<h1 id="vue3项目搭建规范"><a href="#vue3项目搭建规范" class="headerlink" title="vue3项目搭建规范"></a>vue3项目搭建规范</h1><h2 id="一-代码规范"><a href="#一-代码规范" class="headerlink" title="一. 代码规范"></a>一. 代码规范</h2><h3 id="1-1-集成-editorconfig-配置"><a href="#1-1-集成-editorconfig-配置" class="headerlink" title="1.1. 集成 editorconfig 配置"></a>1.1. 集成 editorconfig 配置</h3><p>EditorConfig 有助于为不同 IDE 编辑器上处理同一项目的多个开发人员维护一致的编码风格。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># http://editorconfig.org</span></span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="string">root</span> <span class="string">=</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">[<span class="string">*</span>] <span class="comment"># 表示所有文件适用</span></span><br><span class="line"></span><br><span class="line"><span class="string">charset</span> <span class="string">=</span> <span class="string">utf-8</span> <span class="comment"># 设置文件字符集为 utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="string">indent_style</span> <span class="string">=</span> <span class="string">space</span> <span class="comment"># 缩进风格（tab | space）</span></span><br><span class="line"></span><br><span class="line"><span class="string">indent_size</span> <span class="string">=</span> <span class="number">2</span> <span class="comment"># 缩进大小</span></span><br><span class="line"></span><br><span class="line"><span class="string">end_of_line</span> <span class="string">=</span> <span class="string">lf</span> <span class="comment"># 控制换行类型(lf | cr | crlf)</span></span><br><span class="line"></span><br><span class="line"><span class="string">trim_trailing_whitespace</span> <span class="string">=</span> <span class="literal">true</span> <span class="comment"># 去除行首的任意空白字符</span></span><br><span class="line"></span><br><span class="line"><span class="string">insert_final_newline</span> <span class="string">=</span> <span class="literal">true</span> <span class="comment"># 始终在文件末尾插入一个新行</span></span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">[<span class="string">*.md</span>] <span class="comment"># 表示仅 md 文件适用以下规则</span></span><br><span class="line"></span><br><span class="line"><span class="string">max_line_length</span> <span class="string">=</span> <span class="string">off</span></span><br><span class="line"></span><br><span class="line"><span class="string">trim_trailing_whitespace</span> <span class="string">=</span> <span class="literal">false</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>VSCode 需要安装一个插件：EditorConfig for VS Code</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gsq2gh989yj30pj05ggmb.jpg" alt="image-20210722215138665"></p><h3 id="1-2-使用-prettier-工具"><a href="#1-2-使用-prettier-工具" class="headerlink" title="1.2. 使用 prettier 工具"></a>1.2. 使用 prettier 工具</h3><p>Prettier 是一款强大的代码格式化工具，支持 JavaScript、TypeScript、CSS、SCSS、Less、JSX、Angular、Vue、GraphQL、JSON、Markdown 等语言，基本上前端能用到的文件格式它都可以搞定，是当下最流行的代码格式化工具。</p><p>1.安装 prettier</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">npm install prettier -D</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>2.配置.prettierrc 文件：</p><ul><li><p>useTabs：使用 tab 缩进还是空格缩进，选择 false；</p></li><li><p>tabWidth：tab 是空格的情况下，是几个空格，选择 2 个；</p></li><li><p>printWidth：当行字符的长度，推荐 80，也有人喜欢 100 或者 120；</p></li><li><p>singleQuote：使用单引号还是双引号，选择 true，使用单引号；</p></li><li><p>trailingComma：在多行输入的尾逗号是否添加，设置为 <code>none</code>；</p></li><li><p>semi：语句末尾是否要加分号，默认值 true，选择 false 表示不加；</p></li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">  <span class="attr">&quot;useTabs&quot;</span>: <span class="literal">false</span>,</span><br><span class="line"></span><br><span class="line">  <span class="attr">&quot;tabWidth&quot;</span>: <span class="number">2</span>,</span><br><span class="line"></span><br><span class="line">  <span class="attr">&quot;printWidth&quot;</span>: <span class="number">80</span>,</span><br><span class="line"></span><br><span class="line">  <span class="attr">&quot;singleQuote&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">  <span class="attr">&quot;trailingComma&quot;</span>: <span class="string">&quot;none&quot;</span>,</span><br><span class="line"></span><br><span class="line">  <span class="attr">&quot;semi&quot;</span>: <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>3.创建.prettierignore 忽略文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">/dist/*</span><br><span class="line"></span><br><span class="line">.local</span><br><span class="line"></span><br><span class="line">.output.js</span><br><span class="line"></span><br><span class="line">/node_modules/**</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">**/*.svg</span><br><span class="line"></span><br><span class="line">**/*.sh</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">/public/*</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>4.VSCode 需要安装 prettier 的插件</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gsq2acx21rj30ow057mxp.jpg" alt="image-20210722214543454"></p><p>5.测试 prettier 是否生效</p><ul><li><p>测试一：在代码中保存代码；一次保存格式化一个文件</p></li><li><p>测试二：配置一次性修改的命令；运行该命令 会格式化所有的文件</p></li></ul><p>在 package.json 中配置一个 scripts：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    <span class="string">&quot;prettier&quot;</span>: <span class="string">&quot;prettier --write .&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="1-3-使用-ESLint-检测"><a href="#1-3-使用-ESLint-检测" class="headerlink" title="1.3. 使用 ESLint 检测"></a>1.3. 使用 ESLint 检测</h3><p>1.在前面创建项目的时候，我们就选择了 ESLint，所以 Vue 会默认帮助我们配置需要的 ESLint 环境。</p><p>2.VSCode 需要安装 ESLint 插件：</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gsq2oq26odj30pw05faaq.jpg" alt="image-20210722215933360"></p><p>3.解决 eslint 和 prettier 冲突的问题：</p><p>安装插件：（vue 在创建项目时，如果选择 prettier，那么这两个插件会自动安装）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">npm i eslint-plugin-prettier eslint-config-prettier -D</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>添加 prettier 插件：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  extends: [</span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;plugin:vue/vue3-essential&quot;</span>,</span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;eslint:recommended&quot;</span>,</span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;@vue/typescript/recommended&quot;</span>,</span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;@vue/prettier&quot;</span>,</span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;@vue/prettier/@typescript-eslint&quot;</span>,</span><br><span class="line"></span><br><span class="line">    &#x27;plugin:prettier/recommended&#x27;</span><br><span class="line"></span><br><span class="line">  ],</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="1-4-git-Husky-和-eslint"><a href="#1-4-git-Husky-和-eslint" class="headerlink" title="1.4. git Husky 和 eslint"></a>1.4. git Husky 和 eslint</h3><p>虽然我们已经要求项目使用 eslint 了，但是不能保证组员提交代码之前都将 eslint 中的问题解决掉了：</p><ul><li><p>也就是我们希望保证代码仓库中的代码都是符合 eslint 规范的；</p></li><li><p>那么我们需要在组员执行 <code>git commit </code> 命令的时候对其进行校验，如果不符合 eslint 规范，那么自动通过规范进行修复；</p></li></ul><p>那么如何做到这一点呢？可以通过 Husky 工具：</p><ul><li>husky 是一个 git hook 工具，可以帮助我们触发 git 提交的各个阶段：pre-commit、commit-msg、pre-push</li></ul><p>如何使用 husky 呢？</p><p>这里我们可以使用自动配置命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">npx husky-init&amp;&amp;npm install</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这里会做三件事：</p><p>1.安装 husky 相关的依赖：</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gsqq0o5jxmj30bb04qwen.jpg" alt="image-20210723112648927"></p><p>2.在项目目录下创建 <code>.husky</code> 文件夹：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">npx huksy install</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gsqq16zo75j307703mt8m.jpg" alt="image-20210723112719634"></p><p>3.在 package.json 中添加一个脚本：</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gsqq26phpxj30dj06fgm3.jpg" alt="image-20210723112817691"></p><p>接下来，我们需要去完成一个操作：在进行 commit 时，执行 lint 脚本：</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gsqq3hn229j30nf04z74q.jpg" alt="image-20210723112932943"></p><p>这个时候我们执行 git commit 的时候会自动对代码进行 lint 校验。</p><h3 id="1-5-git-commit-规范"><a href="#1-5-git-commit-规范" class="headerlink" title="1.5. git commit 规范"></a>1.5. git commit 规范</h3><h4 id="1-5-1-代码提交风格"><a href="#1-5-1-代码提交风格" class="headerlink" title="1.5.1. 代码提交风格"></a>1.5.1. 代码提交风格</h4><p>通常我们的 git commit 会按照统一的风格来提交，这样可以快速定位每次提交的内容，方便之后对版本进行控制。</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gsqw17gaqjj30to0cj3zp.jpg"></p><p>但是如果每次手动来编写这些是比较麻烦的事情，我们可以使用一个工具：Commitizen</p><ul><li>Commitizen 是一个帮助我们编写规范 commit message 的工具；</li></ul><p>  1.安装 Commitizen</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">npm install commitizen -D</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>2.安装 cz-conventional-changelog，并且初始化 cz-conventional-changelog：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">npx commitizen init cz-conventional-changelog --save-dev --save-exact</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这个命令会帮助我们安装 cz-conventional-changelog：</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gsqvz2odi4j30ek00zmx2.jpg" alt="image-20210723145249096"></p><p>并且在 package.json 中进行配置：</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gsqvzftay5j30iu04k74d.jpg"></p><p>这个时候我们提交代码需要使用 <code>npx cz</code>：</p><ul><li>第一步是选择 type，本次更新的类型</li></ul><p>| Type     | 作用                                                                                   |</p><p>| ——– | ————————————————————————————– |</p><p>| feat     | 新增特性 (feature)                                                                     |</p><p>| fix      | 修复 Bug(bug fix)                                                                      |</p><p>| docs     | 修改文档 (documentation)                                                               |</p><p>| style    | 代码格式修改(white-space, formatting, missing semi colons, etc)                        |</p><p>| refactor | 代码重构(refactor)                                                                     |</p><p>| perf     | 改善性能(A code change that improves performance)                                      |</p><p>| test     | 测试(when adding missing tests)                                                        |</p><p>| build    | 变更项目构建或外部依赖（例如 scopes: webpack、gulp、npm 等）                           |</p><p>| ci       | 更改持续集成软件的配置文件和 package 中的 scripts 命令，例如 scopes: Travis, Circle 等 |</p><p>| chore    | 变更构建流程或辅助工具(比如更改测试环境)                                               |</p><p>| revert   | 代码回退                                                                               |</p><ul><li>第二步选择本次修改的范围（作用域）</li></ul><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gsqw8ca15oj30r600wmx4.jpg" alt="image-20210723150147510"></p><ul><li>第三步选择提交的信息</li></ul><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gsqw8mq3zlj60ni01hmx402.jpg" alt="image-20210723150204780"></p><ul><li>第四步提交详细的描述信息</li></ul><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gsqw8y05bjj30kt01fjrb.jpg" alt="image-20210723150223287"></p><ul><li>第五步是否是一次重大的更改</li></ul><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gsqw9z5vbij30bm00q744.jpg" alt="image-20210723150322122"></p><ul><li>第六步是否影响某个 open issue</li></ul><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gsqwar8xp1j30fq00ya9x.jpg" alt="image-20210723150407822"></p><p>我们也可以在 scripts 中构建一个命令来执行 cz：</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gsqwc4gtkxj30e207174t.jpg" alt="image-20210723150526211"></p><h4 id="1-5-2-代码提交验证"><a href="#1-5-2-代码提交验证" class="headerlink" title="1.5.2. 代码提交验证"></a>1.5.2. 代码提交验证</h4><p>如果我们按照 cz 来规范了提交风格，但是依然有同事通过 <code>git commit</code> 按照不规范的格式提交应该怎么办呢？</p><ul><li>我们可以通过 commitlint 来限制提交；</li></ul><p>  1.安装 @commitlint/config-conventional 和 @commitlint/cli</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">npm i @commitlint/config-conventional @commitlint/cli -D</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>2.在根目录创建 commitlint.config.js 文件，配置 commitlint</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line"></span><br><span class="line">  <span class="attr">extends</span>: [<span class="string">&quot;@commitlint/config-conventional&quot;</span>],</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>3.使用 husky 生成 commit-msg 文件，验证提交信息：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">npx husky add .husky/commit-msg &quot;npx --no-install commitlint --edit $1&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="二-第三方库集成"><a href="#二-第三方库集成" class="headerlink" title="二. 第三方库集成"></a>二. 第三方库集成</h2><h3 id="2-1-vue-config-js-配置"><a href="#2-1-vue-config-js-配置" class="headerlink" title="2.1. vue.config.js 配置"></a>2.1. vue.config.js 配置</h3><p>vue.config.js 有三种配置方式：</p><ul><li>方式一：直接通过 CLI 提供给我们的选项来配置：</li></ul><p>  - 比如 publicPath：配置应用程序部署的子目录（默认是 <code>/</code>，相当于部署在 <code>https://www.my-app.com/</code>）；</p><p>  - 比如 outputDir：修改输出的文件夹；</p><ul><li>方式二：通过 configureWebpack 修改 webpack 的配置：</li></ul><p>  - 可以是一个对象，直接会被合并；</p><p>  - 可以是一个函数，会接收一个 config，可以通过 config 来修改配置；</p><ul><li>方式三：通过 chainWebpack 修改 webpack 的配置：</li></ul><p>  - 是一个函数，会接收一个基于 <a href="https://github.com/mozilla-neutrino/webpack-chain">webpack-chain</a> 的 config 对象，可以对配置进行修改；</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&quot;path&quot;</span>);</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line"></span><br><span class="line">  <span class="attr">outputDir</span>: <span class="string">&quot;./build&quot;</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// configureWebpack: &#123;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//   resolve: &#123;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//     alias: &#123;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//       views: &#x27;@/views&#x27;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//     &#125;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//   &#125;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// configureWebpack: (config) =&gt; &#123;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//   config.resolve.alias = &#123;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//     &#x27;@&#x27;: path.resolve(__dirname, &#x27;src&#x27;),</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//     views: &#x27;@/views&#x27;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//   &#125;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// &#125;,</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">chainWebpack</span>: <span class="function">(<span class="params">config</span>) =&gt;</span> &#123;</span><br><span class="line"></span><br><span class="line">    config.resolve.alias</span><br><span class="line"></span><br><span class="line">      .set(<span class="string">&quot;@&quot;</span>, path.resolve(__dirname, <span class="string">&quot;src&quot;</span>))</span><br><span class="line"></span><br><span class="line">      .set(<span class="string">&quot;views&quot;</span>, <span class="string">&quot;@/views&quot;</span>);</span><br><span class="line"></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="2-2-vue-router-集成"><a href="#2-2-vue-router-集成" class="headerlink" title="2.2. vue-router 集成"></a>2.2. vue-router 集成</h3><p>安装 vue-router 的最新版本：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">npm install vue-router@next</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>创建 router 对象：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; createRouter, createWebHashHistory &#125; <span class="keyword">from</span> <span class="string">&quot;vue-router&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; RouteRecordRaw &#125; <span class="keyword">from</span> <span class="string">&quot;vue-router&quot;</span>;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> routes: RouteRecordRaw[] = [</span><br><span class="line"></span><br><span class="line">  &#123;</span><br><span class="line"></span><br><span class="line">    <span class="attr">path</span>: <span class="string">&quot;/&quot;</span>,</span><br><span class="line"></span><br><span class="line">    <span class="attr">redirect</span>: <span class="string">&quot;/main&quot;</span>,</span><br><span class="line"></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  &#123;</span><br><span class="line"></span><br><span class="line">    <span class="attr">path</span>: <span class="string">&quot;/main&quot;</span>,</span><br><span class="line"></span><br><span class="line">    <span class="attr">component</span>: <span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&quot;../views/main/main.vue&quot;</span>),</span><br><span class="line"></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  &#123;</span><br><span class="line"></span><br><span class="line">    <span class="attr">path</span>: <span class="string">&quot;/login&quot;</span>,</span><br><span class="line"></span><br><span class="line">    <span class="attr">component</span>: <span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&quot;../views/login/login.vue&quot;</span>),</span><br><span class="line"></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> router = createRouter(&#123;</span><br><span class="line"></span><br><span class="line">  routes,</span><br><span class="line"></span><br><span class="line">  <span class="attr">history</span>: createWebHashHistory(),</span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> router;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>安装 router：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> router <span class="keyword">from</span> <span class="string">&quot;./router&quot;</span>;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">createApp(App).use(router).mount(<span class="string">&quot;#app&quot;</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在 App.vue 中配置跳转：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">&quot;/login&quot;</span>&gt;</span>登录<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">&quot;/main&quot;</span>&gt;</span>首页<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">router-view</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="2-3-vuex-集成"><a href="#2-3-vuex-集成" class="headerlink" title="2.3. vuex 集成"></a>2.3. vuex 集成</h3><p>安装 vuex：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">npm install vuex@next</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>创建 store 对象：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; createStore &#125; <span class="keyword">from</span> <span class="string">&quot;vuex&quot;</span>;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> store = createStore(&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">state</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line"></span><br><span class="line">      <span class="attr">name</span>: <span class="string">&quot;coderwhy&quot;</span>,</span><br><span class="line"></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> store;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>安装 store：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">createApp(App).use(router).use(store).mount(<span class="string">&quot;#app&quot;</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在 App.vue 中使用：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;&#123; $store.state.name &#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="2-4-element-plus-集成"><a href="#2-4-element-plus-集成" class="headerlink" title="2.4. element-plus 集成"></a>2.4. element-plus 集成</h3><p>Element Plus，一套为开发者、设计师和产品经理准备的基于 Vue 3.0 的桌面端组件库：</p><ul><li><p>相信很多同学在 Vue2 中都使用过 element-ui，而 element-plus 正是 element-ui 针对于 vue3 开发的一个 UI 组件库；</p></li><li><p>它的使用方式和很多其他的组件库是一样的，所以学会 element-plus，其他类似于 ant-design-vue、NaiveUI、VantUI 都是差不多的；</p></li></ul><p>安装 element-plus</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">npm install element-plus</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="2-4-1-全局引入"><a href="#2-4-1-全局引入" class="headerlink" title="2.4.1. 全局引入"></a>2.4.1. 全局引入</h4><p>一种引入 element-plus 的方式是全局引入，代表的含义是所有的组件和插件都会被自动注册：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> ElementPlus <span class="keyword">from</span> <span class="string">&quot;element-plus&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;element-plus/lib/theme-chalk/index.css&quot;</span>;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> router <span class="keyword">from</span> <span class="string">&quot;./router&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> store <span class="keyword">from</span> <span class="string">&quot;./store&quot;</span>;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">createApp(App).use(router).use(store).use(ElementPlus).mount(<span class="string">&quot;#app&quot;</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="2-4-2-局部引入"><a href="#2-4-2-局部引入" class="headerlink" title="2.4.2. 局部引入"></a>2.4.2. 局部引入</h4><p>也就是在开发中用到某个组件对某个组件进行引入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line"></span><br><span class="line">  &lt;div id=&quot;app&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;router-link to=&quot;/login&quot;&gt;登录&lt;/router-link&gt;</span><br><span class="line"></span><br><span class="line">    &lt;router-link to=&quot;/main&quot;&gt;首页&lt;/router-link&gt;</span><br><span class="line"></span><br><span class="line">    &lt;router-view&gt;&lt;/router-view&gt;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">    &lt;h2&gt;&#123;&#123; $store.state.name &#125;&#125;&lt;/h2&gt;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">    &lt;el-button&gt;默认按钮&lt;/el-button&gt;</span><br><span class="line"></span><br><span class="line">    &lt;el-button type=&quot;primary&quot;&gt;主要按钮&lt;/el-button&gt;</span><br><span class="line"></span><br><span class="line">    &lt;el-button type=&quot;success&quot;&gt;成功按钮&lt;/el-button&gt;</span><br><span class="line"></span><br><span class="line">    &lt;el-button type=&quot;info&quot;&gt;信息按钮&lt;/el-button&gt;</span><br><span class="line"></span><br><span class="line">    &lt;el-button type=&quot;warning&quot;&gt;警告按钮&lt;/el-button&gt;</span><br><span class="line"></span><br><span class="line">    &lt;el-button type=&quot;danger&quot;&gt;危险按钮&lt;/el-button&gt;</span><br><span class="line"></span><br><span class="line">  &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">&lt;script lang=&quot;ts&quot;&gt;</span><br><span class="line"></span><br><span class="line">import &#123; defineComponent &#125; from &quot;vue&quot;;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">import &#123; ElButton &#125; from &quot;element-plus&quot;;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">export default defineComponent(&#123;</span><br><span class="line"></span><br><span class="line">  name: &quot;App&quot;,</span><br><span class="line"></span><br><span class="line">  components: &#123;</span><br><span class="line"></span><br><span class="line">    ElButton,</span><br><span class="line"></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">&lt;style lang=&quot;less&quot;&gt;&lt;/style&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>但是我们会发现是没有对应的样式的，引入样式有两种方式：</p><ul><li><p>全局引用样式（像之前做的那样）；</p></li><li><p>局部引用样式（通过 babel 的插件）；</p></li></ul><p>  1.安装 babel 的插件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">npm install babel-plugin-import -D</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>2.配置 babel.config.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line"></span><br><span class="line">  <span class="attr">plugins</span>: [</span><br><span class="line"></span><br><span class="line">    [</span><br><span class="line"></span><br><span class="line">      <span class="string">&quot;import&quot;</span>,</span><br><span class="line"></span><br><span class="line">      &#123;</span><br><span class="line"></span><br><span class="line">        <span class="attr">libraryName</span>: <span class="string">&quot;element-plus&quot;</span>,</span><br><span class="line"></span><br><span class="line">        <span class="attr">customStyleName</span>: <span class="function">(<span class="params">name</span>) =&gt;</span> &#123;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">return</span> <span class="string">`element-plus/lib/theme-chalk/<span class="subst">$&#123;name&#125;</span>.css`</span>;</span><br><span class="line"></span><br><span class="line">        &#125;,</span><br><span class="line"></span><br><span class="line">      &#125;,</span><br><span class="line"></span><br><span class="line">    ],</span><br><span class="line"></span><br><span class="line">  ],</span><br><span class="line"></span><br><span class="line">  <span class="attr">presets</span>: [<span class="string">&quot;@vue/cli-plugin-babel/preset&quot;</span>],</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>但是这里依然有个弊端：</p><ul><li><p>这些组件我们在多个页面或者组件中使用的时候，都需要导入并且在 components 中进行注册；</p></li><li><p>所以我们可以将它们在全局注册一次；</p></li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123;</span><br><span class="line"></span><br><span class="line">  ElButton,</span><br><span class="line"></span><br><span class="line">  ElTable,</span><br><span class="line"></span><br><span class="line">  ElAlert,</span><br><span class="line"></span><br><span class="line">  ElAside,</span><br><span class="line"></span><br><span class="line">  ElAutocomplete,</span><br><span class="line"></span><br><span class="line">  ElAvatar,</span><br><span class="line"></span><br><span class="line">  ElBacktop,</span><br><span class="line"></span><br><span class="line">  ElBadge,</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">&quot;element-plus&quot;</span>;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = createApp(App);</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> components = [</span><br><span class="line"></span><br><span class="line">  ElButton,</span><br><span class="line"></span><br><span class="line">  ElTable,</span><br><span class="line"></span><br><span class="line">  ElAlert,</span><br><span class="line"></span><br><span class="line">  ElAside,</span><br><span class="line"></span><br><span class="line">  ElAutocomplete,</span><br><span class="line"></span><br><span class="line">  ElAvatar,</span><br><span class="line"></span><br><span class="line">  ElBacktop,</span><br><span class="line"></span><br><span class="line">  ElBadge,</span><br><span class="line"></span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> cpn <span class="keyword">of</span> components) &#123;</span><br><span class="line"></span><br><span class="line">  app.component(cpn.name, cpn);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="2-5-axios-集成"><a href="#2-5-axios-集成" class="headerlink" title="2.5. axios 集成"></a>2.5. axios 集成</h3><p>安装 axios：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">npm install axios</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>封装 axios：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> axios, &#123; AxiosInstance, AxiosRequestConfig, AxiosResponse &#125; <span class="keyword">from</span> <span class="string">&quot;axios&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; Result &#125; <span class="keyword">from</span> <span class="string">&quot;./types&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; useUserStore &#125; <span class="keyword">from</span> <span class="string">&quot;/@/store/modules/user&quot;</span>;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HYRequest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> instance: AxiosInstance;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">readonly</span> options: AxiosRequestConfig;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">options: AxiosRequestConfig</span>)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">this</span>.options = options;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">this</span>.instance = axios.create(options);</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">    <span class="built_in">this</span>.instance.interceptors.request.use(</span><br><span class="line"></span><br><span class="line">      <span class="function">(<span class="params">config</span>) =&gt;</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> token = useUserStore().getToken;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (token) &#123;</span><br><span class="line"></span><br><span class="line">          config.headers.Authorization = <span class="string">`Bearer <span class="subst">$&#123;token&#125;</span>`</span>;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> config;</span><br><span class="line"></span><br><span class="line">      &#125;,</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">      <span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> err;</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">    <span class="built_in">this</span>.instance.interceptors.response.use(</span><br><span class="line"></span><br><span class="line">      <span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 拦截响应的数据</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (res.data.code === <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">return</span> res.data.data;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res.data;</span><br><span class="line"></span><br><span class="line">      &#125;,</span><br><span class="line"></span><br><span class="line">      <span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> err;</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">  request&lt;T = <span class="built_in">any</span>&gt;(config: AxiosRequestConfig): <span class="built_in">Promise</span>&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line"></span><br><span class="line">      <span class="built_in">this</span>.instance</span><br><span class="line"></span><br><span class="line">        .request&lt;<span class="built_in">any</span>, AxiosResponse&lt;Result&lt;T&gt;&gt;&gt;(config)</span><br><span class="line"></span><br><span class="line">        .then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line"></span><br><span class="line">          resolve(res <span class="keyword">as</span> unknown <span class="keyword">as</span> <span class="built_in">Promise</span>&lt;T&gt;);</span><br><span class="line"></span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">        .catch(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line"></span><br><span class="line">          reject(err);</span><br><span class="line"></span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">  get&lt;T = <span class="built_in">any</span>&gt;(config: AxiosRequestConfig): <span class="built_in">Promise</span>&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.request(&#123; ...config, <span class="attr">method</span>: <span class="string">&quot;GET&quot;</span> &#125;);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">  post&lt;T = <span class="built_in">any</span>&gt;(config: AxiosRequestConfig): <span class="built_in">Promise</span>&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.request(&#123; ...config, <span class="attr">method</span>: <span class="string">&quot;POST&quot;</span> &#125;);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">  patch&lt;T = <span class="built_in">any</span>&gt;(config: AxiosRequestConfig): <span class="built_in">Promise</span>&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.request(&#123; ...config, <span class="attr">method</span>: <span class="string">&quot;PATCH&quot;</span> &#125;);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">  <span class="keyword">delete</span>&lt;T = <span class="built_in">any</span>&gt;(config: AxiosRequestConfig): <span class="built_in">Promise</span>&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.request(&#123; ...config, <span class="attr">method</span>: <span class="string">&quot;DELETE&quot;</span> &#125;);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> HYRequest;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> None </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 语法</title>
      <link href="/2024/07/20/Java%20%E8%AF%AD%E6%B3%95/"/>
      <url>/2024/07/20/Java%20%E8%AF%AD%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="Java-语法"><a href="#Java-语法" class="headerlink" title="Java 语法"></a>Java 语法</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><ol><li>JDK、JRE、JVM 的关系：<ul><li>JDK：Java Development Kit，Java 开发工具包</li><li>JRE: Java Runtime Environment，Java 运行环境</li><li>JVM：Java Virtual Machine，Java 虚拟机</li><li>JDK 包含 JRE，JRE 包含 JVM</li></ul></li><li>JDK 版本选择<ul><li>目前 JDK1.8（也叫 JDK8，注意不是 JDK18）用得最多</li><li>Java 代码的编译运行流程</li><li>将 Java 源码编译成 Java 字节码。</li><li>使用 JVM 将 Java 字节码转化成机器码。</li><li>JVM 作用：跨平台、内存管理、安全。</li></ul></li><li>JSE、JEE、JME 的区别<ul><li>JSE: Java Standard Edition，标准版</li><li>JEE：Java Enterprise Edition，企业版</li><li>JME: Java Mirco Edition，移动版</li><li>Spring 是 JEE 的轻量级替代品</li><li>SpringBoot 是 Spring + 自动化配置</li></ul></li></ol><h2 id="变量、运算符、输入与输出"><a href="#变量、运算符、输入与输出" class="headerlink" title="变量、运算符、输入与输出"></a>变量、运算符、输入与输出</h2><p>类似于 <code>C#</code>，<code>Java</code> 的所有变量和函数都要定义在 <code>class</code> 中。</p><h3 id="1-1-内置数据类型"><a href="#1-1-内置数据类型" class="headerlink" title="1.1 内置数据类型"></a>1.1 内置数据类型</h3><img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/image-20230220081436300.png" alt="image-20230220081436300" style="zoom: 67%;" /> <h3 id="1-2-常量"><a href="#1-2-常量" class="headerlink" title="1.2 常量"></a>1.2 常量</h3><p>使用 <code>final</code> 修饰：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> N = <span class="number">110</span>;</span><br></pre></td></tr></table></figure><h3 id="1-3-类型转化"><a href="#1-3-类型转化" class="headerlink" title="1.3 类型转化"></a>1.3 类型转化</h3><ul><li><p>显示转化：<code>int x = (int)&#39;A&#39;</code></p></li><li><p>隐式转化：<code>double x = 12, y = 4 * 3.3</code></p><blockquote><p>隐式转化只能从低精度到高精度 显示转化则都可以</p></blockquote></li></ul><h3 id="1-4-表达式"><a href="#1-4-表达式" class="headerlink" title="1.4 表达式"></a>1.4 表达式</h3><p>与 <code>C++</code>、<code>Python3</code> 类似：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">1</span>, b = <span class="number">2</span>, c = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">int</span> x = (a + b) * c;</span><br><span class="line">x ++;</span><br></pre></td></tr></table></figure><h3 id="1-5-输入"><a href="#1-5-输入" class="headerlink" title="1.5 输入"></a>1.5 输入</h3><ol><li><p>方式一：效率较低，输入规模较小时使用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">String str = sc.next();  <span class="comment">// 读入下一个字符串 </span></span><br><span class="line">String line = sc.nextLine();  <span class="comment">// 读入下一行(多个字符串)</span></span><br><span class="line"><span class="keyword">int</span> x = sc.nextInt();  <span class="comment">// 读入下一个整数</span></span><br><span class="line"><span class="keyword">float</span> y = sc.nextFloat();  <span class="comment">// 读入下一个单精度浮点数</span></span><br><span class="line"><span class="keyword">double</span> z = sc.nextDouble();  <span class="comment">// 读入下一个双精度浮点数</span></span><br></pre></td></tr></table></figure></li><li><p>方式二：效率较高，输入规模较大时使用。注意需要抛异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yxc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line">        String str = br.readLine();</span><br><span class="line">        System.out.println(str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="1-6-输出"><a href="#1-6-输出" class="headerlink" title="1.6 输出"></a>1.6 输出</h3><ol><li><p>方式一：效率较低，输出规模较小时使用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 输入结尾补一个回车</span></span><br><span class="line">System.out.println(<span class="number">123</span>);  <span class="comment">// 输出整数 + 换行</span></span><br><span class="line">System.out.println(<span class="string">&quot;Hello World&quot;</span>);  <span class="comment">// 输出字符串 + 换行</span></span><br><span class="line"><span class="comment">// 输入结尾不补回车</span></span><br><span class="line">System.out.print(<span class="number">123</span>);  <span class="comment">// 输出整数</span></span><br><span class="line">System.out.print(<span class="string">&quot;yxc\n&quot;</span>);  <span class="comment">// 输出字符串</span></span><br><span class="line"><span class="comment">// 格式化输出  04d代表不足4位 前面会补0</span></span><br><span class="line">System.out.printf(<span class="string">&quot;%04d %.2f\n&quot;</span>, <span class="number">4</span>, <span class="number">123.456D</span>);  <span class="comment">//  0004 123.46</span></span><br></pre></td></tr></table></figure><blockquote><p>编辑器快捷：<code>sout</code></p></blockquote></li><li><p>方式二：效率较高，输出规模较大时使用。注意需要抛异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yxc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.BufferedWriter;</span><br><span class="line"><span class="keyword">import</span> java.io.OutputStreamWriter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;  <span class="comment">// throws Exception 抛出异常</span></span><br><span class="line">        BufferedWriter bw = <span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> OutputStreamWriter(System.out));</span><br><span class="line">        bw.write(<span class="string">&quot;Hello World\n&quot;</span>);</span><br><span class="line">        bw.flush();  <span class="comment">// 需要手动刷新缓冲区 才会显示输出</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="判断语句"><a href="#判断语句" class="headerlink" title="判断语句"></a>判断语句</h2><h3 id="1-if-else-语句"><a href="#1-if-else-语句" class="headerlink" title="1. if-else 语句"></a>1. if-else 语句</h3><p>与 <code>C++</code>、<code>Python</code> 中类似。</p><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yxc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">int</span> year = sc.nextInt();</span><br><span class="line">        <span class="keyword">if</span> (year % <span class="number">100</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (year % <span class="number">400</span> == <span class="number">0</span>)</span><br><span class="line">                System.out.printf(<span class="string">&quot;%d是闰年\n&quot;</span>, year);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                System.out.printf(<span class="string">&quot;%d不是闰年\n&quot;</span>, year);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (year % <span class="number">4</span> == <span class="number">0</span>)</span><br><span class="line">                System.out.printf(<span class="string">&quot;%d是闰年\n&quot;</span>, year);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                System.out.printf(<span class="string">&quot;%d不是闰年\n&quot;</span>, year);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-switch-语句"><a href="#2-switch-语句" class="headerlink" title="2. switch 语句"></a>2. switch 语句</h3><p>与 <code>C++</code> 中类似。</p><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yxc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">int</span> day = sc.nextInt();</span><br><span class="line">        String name;</span><br><span class="line">        <span class="keyword">switch</span> (day) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                name = <span class="string">&quot;Monday&quot;</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                name = <span class="string">&quot;Tuesday&quot;</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">                name = <span class="string">&quot;Wednesday&quot;</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">                name = <span class="string">&quot;Thursday&quot;</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">                name = <span class="string">&quot;Friday&quot;</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">                name = <span class="string">&quot;Saturday&quot;</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line">                name = <span class="string">&quot;Sunday&quot;</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                name = <span class="string">&quot;not valid&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-逻辑运算符与条件表达式"><a href="#3-逻辑运算符与条件表达式" class="headerlink" title="3. 逻辑运算符与条件表达式"></a>3. 逻辑运算符与条件表达式</h3><p>与 <code>C++</code>、<code>Python</code> 类似。</p><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yxc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">int</span> year = sc.nextInt();</span><br><span class="line">        <span class="keyword">if</span> (year % <span class="number">100</span> != <span class="number">0</span> &amp;&amp; year % <span class="number">4</span> == <span class="number">0</span> || year % <span class="number">400</span> == <span class="number">0</span>) </span><br><span class="line">            System.out.printf(<span class="string">&quot;%d是闰年\n&quot;</span>, year);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            System.out.printf(<span class="string">&quot;%d不是闰年\n&quot;</span>, year);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意：java 里逻辑表达式只能说 bool 值，不能是 int 值</p></blockquote><h2 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h2><h3 id="1-while-循环"><a href="#1-while-循环" class="headerlink" title="1. while 循环"></a>1. while 循环</h3><p>与 <code>C++</code>、<code>Python</code> 类似，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (i &lt; <span class="number">5</span>) &#123;</span><br><span class="line">    System.out.println(i);</span><br><span class="line">    i ++ ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-do-while-循环"><a href="#2-do-while-循环" class="headerlink" title="2. do while 循环"></a>2. do while 循环</h3><p>与 <code>C++</code>、<code>Python</code> 类似，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    System.out.println(i);</span><br><span class="line">    i ++ ;</span><br><span class="line">&#125; <span class="keyword">while</span> (i &lt; <span class="number">5</span>);</span><br></pre></td></tr></table></figure><blockquote><p><code>do while</code> 语句与 <code>while</code> 语句非常相似。唯一的区别是，<code>do while</code> 语句限制性循环体后检查条件。不管条件的值如何，我们都要至少执行一次循环。</p></blockquote><h3 id="3-for-循环"><a href="#3-for-循环" class="headerlink" title="3. for 循环"></a>3. for 循环</h3><p>与 <code>C++</code>、<code>Python</code> 类似，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i ++ ) &#123;  <span class="comment">// 普通循环</span></span><br><span class="line">    System.out.println(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span>[] a = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> x: a) &#123;  <span class="comment">// forEach循环</span></span><br><span class="line">    System.out.println(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>编辑器快捷：<code>fori</code></p></blockquote><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p><code>Java</code> 中的数组与 <code>C++</code> 中的数组类似。<strong>数组不可变长</strong></p><h3 id="1-初始化"><a href="#1-初始化" class="headerlink" title="1. 初始化"></a>1. 初始化</h3><p>与 <code>C++</code> 类似。</p><p>初始化定长数组，长度可以是变量，可以在初始化时赋值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] a = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">5</span>];  <span class="comment">// 初始化长度为5的int数组，初始值为0</span></span><br><span class="line"><span class="keyword">int</span> n = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">float</span>[] b = <span class="keyword">new</span> <span class="keyword">float</span>[n];  <span class="comment">// 初始化长度为n的float数组，初始值为0.0F</span></span><br><span class="line"><span class="keyword">char</span>[] c = &#123;<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>&#125;;  <span class="comment">// 初始化长度为3的char数组，初始值为：&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;</span></span><br><span class="line"><span class="keyword">char</span>[] d = c;  <span class="comment">// d与c地址相同，更改c中的元素，d中的元素也会改变</span></span><br></pre></td></tr></table></figure><blockquote><p>java 里面字符数组就是字符数组，字符串就是 string，二者是相互独立的</p></blockquote><h3 id="2-数组元素的读取与写入"><a href="#2-数组元素的读取与写入" class="headerlink" title="2. 数组元素的读取与写入"></a>2. 数组元素的读取与写入</h3><p>与 <code>C++</code> 类似。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] a = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">    a[i] = i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i ++ ) &#123;</span><br><span class="line">    System.out.println(a[i] * a[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-多维数组"><a href="#3-多维数组" class="headerlink" title="3. 多维数组"></a>3. 多维数组</h3><p>与 <code>C++</code> 类似。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[][] a = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>][<span class="number">3</span>];</span><br><span class="line">a[<span class="number">1</span>][<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span>[][] b = &#123;</span><br><span class="line">        &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;,</span><br><span class="line">        &#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;,</span><br><span class="line">&#125;;</span><br><span class="line">System.out.println(a[<span class="number">1</span>][<span class="number">2</span>]);</span><br><span class="line">System.out.println(b[<span class="number">0</span>][<span class="number">1</span>]);</span><br></pre></td></tr></table></figure><h3 id="4-常用-API"><a href="#4-常用-API" class="headerlink" title="4. 常用 API"></a>4. 常用 <code>API</code></h3><ul><li><p>属性 <code>length</code>：返回数组长度，注意不加小括号</p></li><li><p><code>Arrays.sort()</code>：数组排序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] a = &#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">5</span>&#125;;</span><br><span class="line">Arrays.sort(a);</span><br></pre></td></tr></table></figure></li><li><p><code>Arrays.fill(int[] a, int val)</code>：填充数组</p></li><li><p><code>Arrays.toString()</code>：将数组转化为字符串</p></li><li><p><code>Arrays.deepToString()</code>：将多维数组转化为字符串</p></li></ul><h2 id="String-类"><a href="#String-类" class="headerlink" title="String 类"></a>String 类</h2><h3 id="1-初始化-1"><a href="#1-初始化-1" class="headerlink" title="1. 初始化"></a>1. 初始化</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">String a = <span class="string">&quot;Hello World&quot;</span>;</span><br><span class="line">String b = <span class="string">&quot;My name is&quot;</span>; </span><br><span class="line">String x = b;  <span class="comment">// 存储到了相同地址  b.hashCode()与x.hashCode()是一样的</span></span><br><span class="line">String c = b + <span class="string">&quot;yxc&quot;</span>;  <span class="comment">// String可以通过加号拼接</span></span><br><span class="line">String d = <span class="string">&quot;My age is &quot;</span> + <span class="number">18</span>;  <span class="comment">// int会被隐式转化成字符串&quot;18&quot;</span></span><br><span class="line">String str = String.format(<span class="string">&quot;My age is %d&quot;</span>, <span class="number">18</span>);  <span class="comment">// 格式化字符串，类似于C++中的sprintf</span></span><br><span class="line">String money_str = <span class="string">&quot;123.45&quot;</span>;</span><br><span class="line"><span class="keyword">double</span> money_dou = Double.parseDouble(money_str);  <span class="comment">// String转double</span></span><br><span class="line"><span class="keyword">int</span> money_int = Interger.parseInt(money_str) <span class="comment">// String转int</span></span><br></pre></td></tr></table></figure><p><strong>访问 String 中的字符：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String str = <span class="string">&quot;Hello World&quot;</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.length(); i ++ ) &#123;</span><br><span class="line">    System.out.print(str.charAt(i));  <span class="comment">// 等价于str[i] 只能读取，不能写入</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>只读变量，不能修改，例如：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String a = <span class="string">&quot;Hello &quot;</span>;</span><br><span class="line">System.out.println(a.hashCode())  <span class="comment">// 输出-2137068114</span></span><br><span class="line">a += <span class="string">&quot;World&quot;</span>;  <span class="comment">// 会构造一个新的字符串   </span></span><br><span class="line">System.out.println(a.hashCode())  <span class="comment">// 输出-862545276</span></span><br></pre></td></tr></table></figure><h3 id="2-StringBuilder、StringBuffer"><a href="#2-StringBuilder、StringBuffer" class="headerlink" title="2. StringBuilder、StringBuffer"></a>2. StringBuilder、StringBuffer</h3><ul><li><p><code>String</code> 不能被修改，如果打算修改字符串，可以使用 <code>StringBuilder</code> 和 <code>StringBuffer</code>。</p></li><li><p><code>StringBuffer</code> 线程安全，速度较慢；<code>StringBuilder</code> 线程不安全，速度较快。</p><blockquote><p>所以单线程用 <code>StringBuilder</code>，多线程用 <code>StringBuffer</code></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">StringBuilder sb = <span class="keyword">new</span> StringBuilder(<span class="string">&quot;Hello &quot;</span>);  <span class="comment">// 初始化 该类无String类所继承的方法</span></span><br><span class="line">sb.append(<span class="string">&quot;World&quot;</span>);  <span class="comment">// 拼接字符串</span></span><br><span class="line">sb.reverse() <span class="comment">// 翻转字符串，不会返回新的</span></span><br><span class="line">System.out.println(sb);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sb.length(); i ++ ) &#123;</span><br><span class="line">    sb.setCharAt(i, (<span class="keyword">char</span>)(sb.charAt(i) + <span class="number">1</span>));  <span class="comment">// 读取和写入字符 将第i位设置为...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">System.out.println(sb);</span><br></pre></td></tr></table></figure></li></ul><h4 id="3-常用-API："><a href="#3-常用-API：" class="headerlink" title="3. 常用 API："></a>3. 常用 API：</h4><ul><li><p><code>length()</code>：返回长度</p></li><li><p><code>split(String regex)</code>：分割字符串</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String a = <span class="string">&quot;HeLlo World&quot;</span>;</span><br><span class="line">String[] strs = a.split(<span class="string">&quot; &quot;</span>) <span class="comment">// 以空格分割</span></span><br><span class="line"><span class="keyword">for</span>(String str : strs)&#123;  <span class="comment">// forEach遍历</span></span><br><span class="line">System.out.println(str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>indexOf(char c)</code>、<code>indexOf(String str)</code>：查找字符或字符串，找不到返回 <code>-1</code></p></li><li><p><code>equals()</code>：判断两个字符串是否相等，注意不能直接用 <code>==</code></p></li><li><p><code>compareTo()</code>：判断两个字符串的字典序大小，负数表示小于，<code>0</code> 表示相等，正数表示大于</p></li><li><p><code>startsWith()</code>：判断是否以某个前缀开头</p></li><li><p><code>endsWith()</code>：判断是否以某个后缀结尾</p></li><li><p><code>trim()</code>：去掉首尾的空白字符</p></li><li><p><code>toLowerCase()</code>：全部用小写字符</p></li><li><p><code>toUpperCase()</code>：全部用大写字符</p></li><li><p><code>replace(char oldChar, char newChar)</code>：替换字符</p><blockquote><p><code>replace(String oldRegex, String newRegex)</code>：替换字符串</p></blockquote></li><li><p><code>substring(int beginIndex, int endIndex)</code>：返回 <code>[beginIndex, endIndex)</code> 中的子串（前开后闭）</p></li></ul><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p><strong>Java 的所有变量和函数都要定义在类中。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(max(<span class="number">3</span>, <span class="number">4</span>));</span><br><span class="line">        <span class="keyword">int</span>[][] a = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>][<span class="number">4</span>];</span><br><span class="line">        fill(a, <span class="number">3</span>);</span><br><span class="line">        System.out.println(Arrays.deepToString(a));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[][] b = getArray2d(<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>);</span><br><span class="line">        System.out.println(Arrays.deepToString(b));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (a &gt; b) <span class="keyword">return</span> a;</span><br><span class="line">        <span class="keyword">return</span> b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">fill</span><span class="params">(<span class="keyword">int</span>[][] a, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length; i ++ )</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; a[i].length; j ++ )</span><br><span class="line">                a[i][j] = val;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 返回值可以为一个数组</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span>[][] getArray2d(<span class="keyword">int</span> row, <span class="keyword">int</span> col, <span class="keyword">int</span> val) &#123;</span><br><span class="line">        <span class="keyword">int</span>[][] a = <span class="keyword">new</span> <span class="keyword">int</span>[row][col];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; i ++ )</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; col; j ++ )</span><br><span class="line">                a[i][j] = val;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="静态变量和静态方法"><a href="#静态变量和静态方法" class="headerlink" title="静态变量和静态方法"></a>静态变量和静态方法</h2><h3 id="1-成员变量与成员方法"><a href="#1-成员变量与成员方法" class="headerlink" title="1. 成员变量与成员方法"></a>1. 成员变量与成员方法</h3><p><code>Java</code> 的所有变量和函数都要定义在类中。</p><p>在类中，使用 <code>static</code> 修饰符修饰的属性（成员变量）称为静态变量，也可以称为类变量，常量称为静态常量，方法称为静态方法或类方法，它们统称为静态成员，归整个类所有。</p><p>静态成员不依赖于类的特定实例，被类的所有实例共享，就是说 <code>static</code> 修饰的方法或者变量不需要依赖于对象来进行访问，只要这个类被加载，<code>java</code> 虚拟机就可以根据类名找到它们。</p><p>调用静态成员的语法形式如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">类名.静态成员(变量or函数)</span><br></pre></td></tr></table></figure><p>注意：</p><ul><li>static 修饰的成员变量和方法，从属于类。</li><li>普通变量和方法从属于对象。</li><li><strong>静态方法不能调用非静态成员，只能调用静态函数和静态变量，否则编译会报错</strong></li></ul><h3 id="2-静态变量与实例变量"><a href="#2-静态变量与实例变量" class="headerlink" title="2. 静态变量与实例变量"></a>2. 静态变量与实例变量</h3><p>类的成员变量可以分为以下两种：</p><ol><li>静态变量（或称为类变量），指被 static 修饰的成员变量。</li><li>实例变量，指没有被 static 修饰的成员变量。</li></ol><p>静态变量与实例变量的区别如下：</p><p>1）静态变量</p><ul><li>运行时，Java 虚拟机只为静态变量分配一次内存，在加载类的过程中完成静态变量的内存分配。</li><li>在类的内部，可以在任何方法内直接访问静态变量。</li><li>在其他类中，可以通过类名访问该类中的静态变量。</li></ul><p>2）实例变量</p><ul><li>每创建一个实例，Java 虚拟机就会为实例变量分配一次内存。</li><li>在类的内部，可以在非静态方法中直接访问实例变量。</li><li>在本类的静态方法或其他类中则需要通过类的实例对象进行访问。</li></ul><p>静态变量在类中的作用如下：</p><ul><li><p>静态变量可以被类的所有实例共享，因此静态变量可以作为实例之间的共享数据，增加实例之间的交互性。</p></li><li><p>如果类的所有实例都包含一个相同的常量属性，则可以把这个属性定义为静态常量类型，从而节省内存空间。例如，在类中定义一个静态常量 PI。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">double</span> PI = <span class="number">3.14159256</span>;</span><br></pre></td></tr></table></figure></li></ul><p><strong>eg：</strong>创建一个带静态变量的类，然后在 main() 方法中访问该变量并输出结果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticVar</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String str1 = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String str2 = <span class="string">&quot;World!&quot;</span>;</span><br><span class="line">        <span class="comment">// 直接访问str1</span></span><br><span class="line">        String accessVar1 = str1+str2;</span><br><span class="line">        System.out.println(<span class="string">&quot;第 1 次访问静态变量，结果为：&quot;</span>+accessVar1);</span><br><span class="line">        <span class="comment">// 通过类名访问 str1</span></span><br><span class="line">        String accessVar2 = StaticVar.str1+str2;</span><br><span class="line">        System.out.println(<span class="string">&quot;第 2 次访问静态变量，结果为：&quot;</span>+accessVar2);</span><br><span class="line">        <span class="comment">// 通过对象 svt1访问 str1</span></span><br><span class="line">        StaticVar svt1 = <span class="keyword">new</span> StaticVar();</span><br><span class="line">        svt1.str1 = svt1.str1+str2;</span><br><span class="line">        String accessVar3 = svt1.str1;</span><br><span class="line">        System.out.println(<span class="string">&quot;第3次访向静态变量，结果为：&quot;</span>+accessVar3);</span><br><span class="line">        <span class="comment">// 通过对象 svt2访问 str1</span></span><br><span class="line">        StaticVar svt2 = <span class="keyword">new</span> StaticVar();</span><br><span class="line">        String accessVar4 = svt2.str1+str2;</span><br><span class="line">        System.out.println(<span class="string">&quot;第 4 次访问静态变量，结果为：&quot;</span>+accessVar4);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行该程序后的结果如下所示。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">第 <span class="number">1</span> 次访问静态变量，结果为：HelloWorld!</span><br><span class="line">第 <span class="number">2</span> 次访问静态变量，结果为：HelloWorld!</span><br><span class="line">第 <span class="number">3</span> 次访向静态变量，结果为：HelloWorld!</span><br><span class="line">第 <span class="number">4</span> 次访问静态变量，结果为：HelloWorld!World!</span><br></pre></td></tr></table></figure><p>从运行结果可以看出，在类中定义静态的属性（成员变量），在 main() 方法中可以直接访问，也可以通过类名访问，还可以通过类的实例对象来访问。</p><blockquote><p>注意：静态变量是被多个实例所共享的。</p></blockquote><h3 id="3-静态方法与实例方法"><a href="#3-静态方法与实例方法" class="headerlink" title="3. 静态方法与实例方法"></a>3. 静态方法与实例方法</h3><p>与成员变量类似，成员方法也可以分为以下两种：</p><ol><li>静态方法（或称为类方法），指被 static 修饰的成员方法。</li><li>实例方法，指没有被 static 修饰的成员方法。</li></ol><p>静态方法与实例方法的区别如下：</p><ul><li>静态方法不需要通过它所属的类的任何实例就可以被调用，因此在静态方法中不能使用 this 关键字，也不能直接访问所属类的实例变量和实例方法，但是可以直接访问所属类的静态变量和静态方法。另外，和 this 关键字一样，super 关键字也与类的特定实例相关，所以在静态方法中也不能使用 super 关键字。</li><li>在实例方法中可以直接访问所属类的静态变量、静态方法、实例变量和实例方法。</li></ul><p><strong>eg：</strong>创建一个带静态变量的类，添加几个静态方法对静态变量的值进行修改，然后在 main( ) 方法中调用静态方法并输出结果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticMethod</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">1</span>;    <span class="comment">// 定义静态变量 count</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">method1</span><span class="params">()</span> </span>&#123;    </span><br><span class="line">        <span class="comment">// 实例方法 method1</span></span><br><span class="line">        count++;    <span class="comment">// 访问静态变量 count 并赋值</span></span><br><span class="line">        System.out.println(<span class="string">&quot;在静态方法 method1()中的 count=&quot;</span>+count);    <span class="comment">// 打印 count</span></span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">method2</span><span class="params">()</span> </span>&#123;    </span><br><span class="line">        <span class="comment">// 静态方法 method2</span></span><br><span class="line">        count += count;    <span class="comment">// 访问静态变量 count 并赋值</span></span><br><span class="line">        System.out.println(<span class="string">&quot;在静态方法 method2()中的 count=&quot;</span>+count);    <span class="comment">// 打印 count</span></span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">PrintCount</span><span class="params">()</span> </span>&#123;    </span><br><span class="line">        <span class="comment">// 静态方法 PrintCount</span></span><br><span class="line">        count += <span class="number">2</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;在静态方法 PrintCount()中的 count=&quot;</span>+count);    <span class="comment">// 打印 count</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        StaticMethod sft = <span class="keyword">new</span> StaticMethod();</span><br><span class="line">        <span class="comment">// 通过实例对象调用实例方法</span></span><br><span class="line">        System.out.println(<span class="string">&quot;method1() 方法返回值 intro1=&quot;</span>+sft.method1());</span><br><span class="line">        <span class="comment">// 直接调用静态方法</span></span><br><span class="line">        System.out.println(<span class="string">&quot;method2() 方法返回值 intro1=&quot;</span>+method2());</span><br><span class="line">        <span class="comment">// 通过类名调用静态方法，打印 count</span></span><br><span class="line">        StaticMethod.PrintCount();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行该程序后的结果如下所示。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">在静态方法 method1()中的 count=<span class="number">2</span></span><br><span class="line">method1() 方法返回值 intro1=<span class="number">2</span></span><br><span class="line">在静态方法 method2()中的 count=<span class="number">4</span></span><br><span class="line">method2() 方法返回值 intro1=<span class="number">4</span></span><br><span class="line">在静态方法 PrintCount()中的 count=<span class="number">6</span></span><br></pre></td></tr></table></figure><p>在该程序中，静态变量 count 作为实例之间的共享数据，因此在不同的方法中调用 count，值是不一样的。从该程序中可以看出，在静态方法 method2() 和 PrintCount() 中是不可以调用非静态方法 method1() 的，而在 method1() 方法中可以调用静态方法 method2() 和 PrintCount()。</p><p>在访问非静态方法时，需要通过实例对象来访问，而在访问静态方法时，可以直接访问，也可以通过类名来访问，还可以通过实例化对象来访问。</p><h3 id="3-静态代码块与非静态代码块"><a href="#3-静态代码块与非静态代码块" class="headerlink" title="3. 静态代码块与非静态代码块"></a>3. 静态代码块与非静态代码块</h3><p>静态代码块指 Java 类中的 static{ } 代码块，主要用于初始化类，为类的静态变量赋初始值，提升程序性能。</p><p>静态代码块的特点如下：</p><ul><li>静态代码块类似于一个方法，但它不可以存在于任何方法体中。</li><li>静态代码块可以置于类中的任何地方，类中可以有多个静态初始化块。 </li><li>Java 虚拟机在加载类时执行静态代码块，所以很多时候会将一些只需要进行一次的初始化操作都放在 static 代码块中进行。</li><li>如果类中包含多个静态代码块，则 Java 虚拟机将按它们在类中出现的顺序依次执行它们，每个静态代码块只会被执行一次。</li><li>静态代码块与静态方法一样，不能直接访问类的实例变量和实例方法，而需要通过类的实例对象来访问。</li></ul><p><strong>eg：</strong>编写一个 Java 类，在类中定义一个静态变量，然后使用静态代码块修改静态变量的值。最后在 main() 方法中进行测试和输出。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticCode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    &#123; <span class="comment">// “&#123;” 前没加 static -&gt; 非静态代码块</span></span><br><span class="line">        count++;</span><br><span class="line">        System.out.println(<span class="string">&quot;非静态代码块 count=&quot;</span> + count);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> &#123; <span class="comment">// “&#123;” 前加 static -&gt; 静态代码块</span></span><br><span class="line">        count++;</span><br><span class="line">        System.out.println(<span class="string">&quot;静态代码块1 count=&quot;</span> + count);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> &#123; <span class="comment">// “&#123;” 前加 static -&gt; 静态代码块</span></span><br><span class="line">        count++;</span><br><span class="line">        System.out.println(<span class="string">&quot;静态代码块2 count=&quot;</span> + count);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;*************** StaticCode1 执行 ***************&quot;</span>);</span><br><span class="line">        StaticCode sct1 = <span class="keyword">new</span> StaticCode();</span><br><span class="line">        System.out.println(<span class="string">&quot;*************** StaticCode2 执行 ***************&quot;</span>);</span><br><span class="line">        StaticCode sct2 = <span class="keyword">new</span> StaticCode();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上述示例，为了说明静态代码块只被执行一次，特地添加了非静态代码块作为对比，并在主方法中创建了两个类的实例对象。上述示例的执行结果为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">静态代码块<span class="number">1</span> count=<span class="number">1</span></span><br><span class="line">静态代码块<span class="number">2</span> count=<span class="number">2</span></span><br><span class="line">*************** StaticCode1 执行 ***************</span><br><span class="line">非静态代码块 count=<span class="number">3</span></span><br><span class="line">*************** StaticCode2 执行 ***************</span><br><span class="line">非静态代码块 count=<span class="number">4</span></span><br></pre></td></tr></table></figure><p>上述代码中 { } 代码块为非静态代码块，非静态代码块是在创建对象时自动执行的代码，不创建对象不执行该类的非静态代码块。代码域中定义的变量都是局部的，只有域中的代码可以调用。 </p><h3 id="4-利用-static-创建全局变量的一种方式"><a href="#4-利用-static-创建全局变量的一种方式" class="headerlink" title="4. 利用 static 创建全局变量的一种方式"></a>4. 利用 static 创建全局变量的一种方式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Argument</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> x = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> y = <span class="number">1</span>; <span class="comment">// 常量</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(Argument.x); <span class="comment">// 调用</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="类和接口"><a href="#类和接口" class="headerlink" title="类和接口"></a>类和接口</h2><h3 id="1-源文件声明规则"><a href="#1-源文件声明规则" class="headerlink" title="1.源文件声明规则"></a>1.源文件声明规则</h3><ul><li>一个源文件中<strong>只能有一个</strong><code>public</code>类。</li><li>一个源文件可以有多个非<code>public</code>类。</li><li>源文件的名称应该和<code>public</code>类的类名保持一致。</li><li>每个源文件中，先写<code>package</code>语句，再写<code>import</code>语句，最后定义类。</li><li>同一个目录下不需要<code>import 类名</code></li></ul><h3 id="2-类"><a href="#2-类" class="headerlink" title="2. 类"></a>2. 类</h3><h4 id="2-1-不同修饰符的区别"><a href="#2-1-不同修饰符的区别" class="headerlink" title="2.1 不同修饰符的区别"></a>2.1 不同修饰符的区别</h4><p><img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/image-20230307142819546.png" alt="image-20230307142819546"></p><h5 id="修饰类和接口时"><a href="#修饰类和接口时" class="headerlink" title="修饰类和接口时"></a>修饰类和接口时</h5><p><strong>public</strong></p><blockquote><p>当一个类被 public 修饰时，该类可以被所有其他类访问。当被访问的公共类与访问类不在同一个包的时候，需要通过 import 语句加载被访问的类。</p></blockquote><p><strong>default（class 前啥也不写）</strong></p><blockquote><p>当一个类被 default 修饰时，该类可以被所有其他类访问。当被访问的公共类与访问类不在同一个包的时候，不能访问。</p></blockquote><hr><h5 id="修饰变量时"><a href="#修饰变量时" class="headerlink" title="修饰变量时"></a>修饰变量时</h5><p><strong>public</strong></p><blockquote><p>使用 public 修饰的字段，new 的对象可以直接操作该字段。如赋值：<code>person.name = &quot;ldx&quot;</code></p></blockquote><p><strong>private</strong></p><blockquote><p>1.使用 private 修饰的字段，new 的对象只能通过对象内部的方法间接的操作该字段。如：<code>person.setName(&quot;ldx&quot;)</code>，这时该方法可检查传入的参数，这样外部代码就没有任何机会把<code>name</code>设置为不合理的值。</p><p>2.只能在类的内部访问，无法被其他类访问。如果一个类内部还定义了嵌套类，那么，嵌套类拥有访问<code>private</code>的权限</p><p>注意：嵌套类和子孙类有明显区别，子孙类是继承关系</p></blockquote><p><strong>protected</strong> </p><blockquote><p>使用<code>protected</code>修饰的字段可以被子类访问，以及子类的子类。作用于继承关系。</p></blockquote><hr><h5 id="修饰方法时"><a href="#修饰方法时" class="headerlink" title="修饰方法时"></a>修饰方法时</h5><p><strong>public</strong></p><blockquote><p>使用 public 修饰的方法，new 的对象可以调用。</p></blockquote><p><strong>private</strong></p><blockquote><p>使用 private 修饰的方法，new 的对象不能调用，只能在类内部调用，子类也无法调用。</p></blockquote><p>eg：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> birth;</span><br><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBirth</span><span class="params">(<span class="keyword">int</span> birth)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.birth = birth;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// new 的对象可调用的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> calcAge(<span class="number">2019</span>); <span class="comment">// 调用 private 方法</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// new 的对象不能调用，只能在类内部调用</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">calcAge</span><span class="params">(<span class="keyword">int</span> currentYear)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> currentYear - <span class="keyword">this</span>.birth;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>protected</strong> </p><blockquote><p>使用<code>protected</code>修饰的方法可以被子类调用，以及子类的子类。作用于继承关系。</p></blockquote><hr><h5 id="final"><a href="#final" class="headerlink" title="final"></a>final</h5><p>Java 还提供了一个<code>final</code>修饰符。<code>final</code>与访问权限不冲突，它有很多作用。</p><p>用<code>final</code>修饰<code>class</code>可以阻止被继承：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">package abc;</span><br><span class="line"></span><br><span class="line">// 无法被继承:</span><br><span class="line">public final class Hello &#123;</span><br><span class="line">    private int n = 0;</span><br><span class="line">    protected void hi(int t) &#123;</span><br><span class="line">        long i = t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用<code>final</code>修饰<code>method</code>可以阻止被子类覆写：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">package abc;</span><br><span class="line"></span><br><span class="line">public class Hello &#123;</span><br><span class="line">    // 无法被覆写:</span><br><span class="line">    protected final void hi() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用<code>final</code>修饰<code>field</code>可以阻止被重新赋值：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">package abc;</span><br><span class="line"></span><br><span class="line">public class Hello &#123;</span><br><span class="line">    private final int n = 0;</span><br><span class="line">    protected void hi() &#123;</span><br><span class="line">        this.n = 1; // error!</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用<code>final</code>修饰局部变量可以阻止被重新赋值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> abc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hello</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">hi</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">        t = <span class="number">1</span>; <span class="comment">// error!</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-2-方法相关"><a href="#2-2-方法相关" class="headerlink" title="2.2 方法相关"></a>2.2 方法相关</h4><h5 id="this-变量"><a href="#this-变量" class="headerlink" title="this 变量"></a>this 变量</h5><p>在方法内部，可以使用一个隐含的变量<code>this</code>，它始终指向当前实例。因此，通过<code>this.field</code>就可以访问当前实例的字段。</p><p>如果没有命名冲突，可以省略<code>this</code>。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name; <span class="comment">// 相当于 this.name</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是，如果有局部变量和字段重名，那么局部变量优先级更高，就必须加上<code>this</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name; <span class="comment">// 前面的 this 不可少，少了就变成局部变量 name 了</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h5 id="参数的传递"><a href="#参数的传递" class="headerlink" title="参数的传递"></a>参数的传递</h5><ul><li><p>基本类型参数的传递，是调用方值的复制。双方各自的后续修改，互不影响。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Person p = <span class="keyword">new</span> Person();</span><br><span class="line">        <span class="keyword">int</span> n = <span class="number">15</span>; <span class="comment">// n 的值为15</span></span><br><span class="line">        p.setAge(n); <span class="comment">// 传入 n 的值</span></span><br><span class="line">        System.out.println(p.getAge()); <span class="comment">// 15</span></span><br><span class="line">        n = <span class="number">20</span>; <span class="comment">// n 的值改为20</span></span><br><span class="line">        System.out.println(p.getAge()); <span class="comment">// 15还是20?</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>引用类型参数的传递，调用方的变量，和接收方的参数变量，指向的是同一个对象。双方任意一方对这个对象的修改，都会影响对方（因为指向同一个对象嘛）</p><p>eg1：思考下面的例子为什么输出一次<code>Homer Simpson</code>，一次<code>Bart Simpson</code>?</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Person p = <span class="keyword">new</span> Person();</span><br><span class="line">        String[] fullname = <span class="keyword">new</span> String[] &#123; <span class="string">&quot;Homer&quot;</span>, <span class="string">&quot;Simpson&quot;</span> &#125;;</span><br><span class="line">        p.setName(fullname); <span class="comment">// 传入 fullname 数组</span></span><br><span class="line">        System.out.println(p.getName()); <span class="comment">// &quot;Homer Simpson&quot;</span></span><br><span class="line">        fullname[<span class="number">0</span>] = <span class="string">&quot;Bart&quot;</span>; <span class="comment">// fullname 数组的第一个元素修改为&quot;Bart&quot;</span></span><br><span class="line">        System.out.println(p.getName()); <span class="comment">// 输出 &quot;Bart Simpson&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String[] name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name[<span class="number">0</span>] + <span class="string">&quot; &quot;</span> + <span class="keyword">this</span>.name[<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String[] name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>eg2：思考下面的例子为什么输出两次<code>Bob</code>?</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Person p = <span class="keyword">new</span> Person();</span><br><span class="line">        String bob = <span class="string">&quot;Bob&quot;</span>;</span><br><span class="line">        p.setName(bob); <span class="comment">// 传入 bob 变量</span></span><br><span class="line">        System.out.println(p.getName()); <span class="comment">// &quot;Bob&quot;</span></span><br><span class="line">        bob = <span class="string">&quot;Alice&quot;</span>; <span class="comment">// bob 改名为 Alice</span></span><br><span class="line">        System.out.println(p.getName()); <span class="comment">// &quot;Bob&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>因为 String 是不可变的，当修改实参时是 new 一个新的 String 对象，故修改新的值与原来的 String 没有关系</strong></p></li></ul><hr><h5 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h5><p>可变参数用<code>类型...</code>定义，可变参数相当于数组类型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Group</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String[] names;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNames</span><span class="params">(String... names)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.names = names;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的<code>setNames()</code>就定义了一个可变参数。调用时，可以这么写：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Group g = <span class="keyword">new</span> Group();</span><br><span class="line">g.setNames(<span class="string">&quot;Xiao Ming&quot;</span>, <span class="string">&quot;Xiao Hong&quot;</span>, <span class="string">&quot;Xiao Jun&quot;</span>); <span class="comment">// 传入3个 String</span></span><br><span class="line">g.setNames(<span class="string">&quot;Xiao Ming&quot;</span>, <span class="string">&quot;Xiao Hong&quot;</span>); <span class="comment">// 传入2个 String</span></span><br><span class="line">g.setNames(<span class="string">&quot;Xiao Ming&quot;</span>); <span class="comment">// 传入1个 String</span></span><br><span class="line">g.setNames(); <span class="comment">// 传入0个 String</span></span><br></pre></td></tr></table></figure><p>完全可以把可变参数改写为<code>String[]</code>类型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Group</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String[] names;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNames</span><span class="params">(String[] names)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.names = names;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是，调用方需要自己先构造<code>String[]</code>，比较麻烦。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Group g = <span class="keyword">new</span> Group();</span><br><span class="line">g.setNames(<span class="keyword">new</span> String[] &#123;<span class="string">&quot;Xiao Ming&quot;</span>, <span class="string">&quot;Xiao Hong&quot;</span>, <span class="string">&quot;Xiao Jun&quot;</span>&#125;); <span class="comment">// 传入1个 String[]</span></span><br></pre></td></tr></table></figure><p>另一个问题是，调用方可以传入<code>null</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Group g = <span class="keyword">new</span> Group();</span><br><span class="line">g.setNames(<span class="keyword">null</span>);</span><br></pre></td></tr></table></figure><p>而可变参数可以保证无法传入<code>null</code>，因为传入0个参数时，接收到的实际值是一个空数组而不是<code>null</code>。</p><h4 id="2-3-类的继承"><a href="#2-3-类的继承" class="headerlink" title="2.3 类的继承"></a>2.3 <a href="https://www.liaoxuefeng.com/wiki/1252599548343744/1260454548196032">类的继承</a></h4><p>继承是面向对象编程中非常强大的一种机制，它首先可以复用代码。当我们让<code>Student</code>从<code>Person</code>继承时，<code>Student</code>就获得了<code>Person</code>的所有功能，我们只需要为<code>Student</code>编写新增的功能。</p><p>Java 使用<code>extends</code>关键字来实现继承：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;...&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;...&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;...&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;...&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 不要重复 name 和 age 字段/方法,</span></span><br><span class="line">    <span class="comment">// 只需要定义新增 score 字段/方法:</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> score;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getScore</span><span class="params">()</span> </span>&#123; … &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setScore</span><span class="params">(<span class="keyword">int</span> score)</span> </span>&#123; … &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可见，通过继承，<code>Student</code>只需要编写额外的功能，不再需要重复代码。</p><blockquote><p>注意：子类自动获得了父类的所有字段，严禁定义与父类重名的字段！</p></blockquote><h5 id="继承树"><a href="#继承树" class="headerlink" title="继承树"></a>继承树</h5><ul><li><p>注意到我们在定义<code>Person</code>的时候，没有写<code>extends</code>。在 Java 中，没有明确写<code>extends</code>的类，编译器会自动加上<code>extends Object</code>。所以，任何类，除了<code>Object</code>，都会继承自某个类。下图是<code>Person</code>、<code>Student</code>的继承树：</p><p><img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/image-20230221082015181.png" alt="image-20230221082015181"></p></li><li><p>Java 只允许一个 class 继承自一个类，因此，一个类有且仅有一个父类。只有<code>Object</code>特殊，它没有父类。</p><p>类似的，如果我们定义一个继承自<code>Person</code>的<code>Teacher</code>，它们的继承树关系如下：</p><p> <img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/image-20230221082028215.png" alt="image-20230221082028215"></p></li></ul><h5 id="protected"><a href="#protected" class="headerlink" title="protected"></a>protected</h5><ul><li><p>继承有个特点，就是子类无法访问父类的<code>private</code>字段或者<code>private</code>方法。例如，<code>Student</code>类就无法访问<code>Person</code>类的<code>name</code>和<code>age</code>字段：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Hello, &quot;</span> + name; <span class="comment">// 编译错误：无法访问 name 字段</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>这使得继承的作用被削弱了。为了让子类可以访问父类的字段，我们需要把<code>private</code>改为<code>protected</code>。用<code>protected</code>修饰的字段可以被子类访问：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> String name;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">int</span> age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Hello, &quot;</span> + name; <span class="comment">// OK!</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>因此，<code>protected</code>关键字可以把字段和方法的访问权限控制在继承树内部，一个<code>protected</code>字段和方法可以被其子类，以及子类的子类所访问。</p></li></ul><h5 id="super"><a href="#super" class="headerlink" title="super"></a>super</h5><p><code>super</code>关键字表示父类（超类）。子类引用父类的字段时，可以用<code>super.fieldName</code>。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Hello, &quot;</span> + <span class="keyword">super</span>.name; <span class="comment">// name 为 protected 修饰的字段</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>若父类中的<code>protected</code>修饰的<code>name</code>字段，可在子类中通过<code>super.name</code>直接访问</p><p>若父类中的<code>private</code>修饰的<code>name</code>字段，可在子类中通过<code>super.getName()</code>间接访问</p></blockquote><p>实际上，这里使用<code>super.name</code>，或者<code>this.name</code>，或者<code>name</code>，效果都是一样的。编译器会自动定位到父类的<code>name</code>字段。</p><p>但是，在某些时候，就必须使用<code>super</code>。我们来看一个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> String name;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">int</span> age;</span><br><span class="line"><span class="comment">// Person 构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">int</span> score;</span><br><span class="line"><span class="comment">// Student 构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name, <span class="keyword">int</span> age, <span class="keyword">int</span> score)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.score = score;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Student s = <span class="keyword">new</span> Student(<span class="string">&quot;Xiao Ming&quot;</span>, <span class="number">12</span>, <span class="number">89</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是因为在 Java 中，任何<code>class</code>的构造方法，第一行语句必须是调用父类的构造方法。如果没有明确地调用父类的构造方法，编译器会帮我们自动加一句<code>super();</code>，所以，<code>Student</code>类的构造方法实际上是这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">int</span> score;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name, <span class="keyword">int</span> age, <span class="keyword">int</span> score)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(); <span class="comment">// 自动调用父类的构造方法</span></span><br><span class="line">        <span class="keyword">this</span>.score = score;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是，<code>Person</code>类并没有无参数的构造方法，因此，编译失败。</p><p>解决方法是调用<code>Person</code>类存在的某个构造方法。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">int</span> score;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name, <span class="keyword">int</span> age, <span class="keyword">int</span> score)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name, age); <span class="comment">// 调用父类的构造方法 Person(String, int)</span></span><br><span class="line">        <span class="keyword">this</span>.score = score;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就可以正常编译了！</p><p>因此我们得出结论：如果父类没有默认的构造方法，子类就必须显式调用<code>super()</code>并给出参数以便让编译器定位到父类的一个合适的构造方法。</p><p>这里还顺带引出了另一个问题：即<strong>子类不会继承造方法</strong>。子类默认的构造方法是编译器自动生成的，不是继承的。</p><h5 id="向上转型"><a href="#向上转型" class="headerlink" title="向上转型"></a>向上转型</h5><p>一个引用类型为<code>Person</code>的变量，可以指向<code>Student</code>类型的实例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Person p = <span class="keyword">new</span> Student(); </span><br></pre></td></tr></table></figure><p>因为<code>Student</code>继承自<code>Person</code>，因此，它拥有<code>Person</code>的全部功能。<code>Person</code>类型的变量，如果指向<code>Student</code>类型的实例，对它进行操作，是没有问题的！</p><p>这种把一个子类类型安全地变为父类类型的赋值，被称为向上转型（upcasting）。</p><p>向上转型实际上是把一个子类型安全地变为更加抽象的父类型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Student s = <span class="keyword">new</span> Student();</span><br><span class="line">Person p = s; <span class="comment">// upcasting, ok</span></span><br><span class="line">Object o1 = p; <span class="comment">// upcasting, ok</span></span><br><span class="line">Object o2 = s; <span class="comment">// upcasting, ok</span></span><br></pre></td></tr></table></figure><p>注意到继承树是<code>Student &gt; Person &gt; Object</code>，所以，可以把<code>Student</code>类型转型为<code>Person</code>，或者更高层次的<code>Object</code>。</p><h4 id="2-4-类的多态"><a href="#2-4-类的多态" class="headerlink" title="2.4 类的多态"></a>2.4 <a href="https://www.liaoxuefeng.com/wiki/1252599548343744/1260455778791232">类的多态</a></h4><h5 id="覆写（Override）"><a href="#覆写（Override）" class="headerlink" title="覆写（Override）"></a>覆写（Override）</h5><p>在继承关系中，子类如果定义了一个与父类方法签名完全相同的方法，被称为覆写（Override）。</p><p><code>Override</code>和<code>Overload</code>不同：</p><ul><li>如果方法签名不同，就是<code>Overload</code>，<code>Overload</code>方法是一个新方法；</li><li>如果方法签名相同，并且返回值也相同，就是<code>Override</code>。</li></ul><blockquote><p>注意：方法名相同，方法参数相同，但方法返回值不同，也是不同的方法。在 Java 程序中，出现这种情况，编译器会报错。</p></blockquote><p>在上一节中，我们已经知道，引用变量的声明类型可能与其实际类型不符，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Person p = <span class="keyword">new</span> Student();</span><br></pre></td></tr></table></figure><p>现在，我们考虑一种情况，如果子类覆写了父类的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;   <span class="comment">// 子类覆写父类的 run()函数</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Person.run&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Student.run&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Person p = <span class="keyword">new</span> Student();</span><br><span class="line">        p.run(); <span class="comment">// 应该打印 Person.run 还是 Student.run?</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么，一个实际类型为<code>Student</code>，引用类型为<code>Person</code>的变量，调用其<code>run()</code>方法，调用的是<code>Person</code>还是<code>Student</code>的<code>run()</code>方法？</p><p>运行一下上面的代码就可以知道，实际上调用的方法是<code>Student</code>的<code>run()</code>方法。因此可得出结论：</p><p><strong>Java 的实例方法调用是基于运行时的实际类型的动态调用，而非变量的声明类型。</strong></p><p>这个非常重要的特性在面向对象编程中称之为多态。它的英文拼写非常复杂：Polymorphic。</p><h5 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h5><p>多态是指，针对某个类型的方法调用，其真正执行的方法取决于运行时期实际类型的方法。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Person p = <span class="keyword">new</span> Student();</span><br><span class="line">p.run(); <span class="comment">// 无法确定运行时究竟调用哪个 run()方法</span></span><br></pre></td></tr></table></figure><p>有童鞋会问，从上面的代码一看就明白，肯定调用的是<code>Student</code>的<code>run()</code>方法啊。</p><p>但是，假设我们编写这样一个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">runTwice</span><span class="params">(Person p)</span> </span>&#123;</span><br><span class="line">    p.run();</span><br><span class="line">    p.run();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它传入的参数类型是<code>Person</code>，我们是无法知道传入的参数实际类型究竟是<code>Person</code>，还是<code>Student</code>，还是<code>Person</code>的其他子类，因此，也无法确定调用的是不是<code>Person</code>类定义的<code>run()</code>方法。</p><p>所以，多态的特性就是，运行期才能动态决定调用的子类方法。对某个类型调用某个方法，执行的实际方法可能是某个子类的覆写方法。这种不确定性的方法调用，究竟有什么作用？</p><p>我们还是来举栗子。</p><p>假设我们定义一种收入，需要给它报税，那么先定义一个<code>Income</code>类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Income</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">double</span> income;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getTax</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> income * <span class="number">0.1</span>; <span class="comment">// 税率10%</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于工资收入，可以减去一个基数，那么我们可以从<code>Income</code>派生出<code>SalaryIncome</code>，并覆写<code>getTax()</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Salary</span> <span class="keyword">extends</span> <span class="title">Income</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getTax</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (income &lt;= <span class="number">5000</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (income - <span class="number">5000</span>) * <span class="number">0.2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果你享受国务院特殊津贴，那么按照规定，可以全部免税：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StateCouncilSpecialAllowance</span> <span class="keyword">extends</span> <span class="title">Income</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getTax</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在，我们要编写一个报税的财务软件，对于一个人的所有收入进行报税，可以这么写：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">totalTax</span><span class="params">(Income... incomes)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> total = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (Income income: incomes) &#123;</span><br><span class="line">        total = total + income.getTax();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> total;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>综上：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Income</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">double</span> income;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Income</span><span class="params">(<span class="keyword">double</span> income)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.income = income;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getTax</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> income * <span class="number">0.1</span>; <span class="comment">// 税率10%</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Salary</span> <span class="keyword">extends</span> <span class="title">Income</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Salary</span><span class="params">(<span class="keyword">double</span> income)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(income);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getTax</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (income &lt;= <span class="number">5000</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (income - <span class="number">5000</span>) * <span class="number">0.2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StateCouncilSpecialAllowance</span> <span class="keyword">extends</span> <span class="title">Income</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">StateCouncilSpecialAllowance</span><span class="params">(<span class="keyword">double</span> income)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(income);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getTax</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 给一个有普通收入、工资收入和享受国务院特殊津贴的小伙伴算税:</span></span><br><span class="line">        Income[] incomes = <span class="keyword">new</span> Income[] &#123;</span><br><span class="line">            <span class="keyword">new</span> Income(<span class="number">3000</span>),</span><br><span class="line">            <span class="keyword">new</span> Salary(<span class="number">7500</span>),</span><br><span class="line">            <span class="keyword">new</span> StateCouncilSpecialAllowance(<span class="number">15000</span>)</span><br><span class="line">        &#125;;</span><br><span class="line">        System.out.println(totalTax(incomes));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">totalTax</span><span class="params">(Income... incomes)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> total = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (Income income: incomes) &#123;</span><br><span class="line">            total = total + income.getTax();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> total;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>观察<code>totalTax()</code>方法：利用多态，<code>totalTax()</code>方法只需要和<code>Income</code>打交道，它完全不需要知道<code>Salary</code>和<code>StateCouncilSpecialAllowance</code>的存在，就可以正确计算出总的税。如果我们要新增一种稿费收入，只需要从<code>Income</code>派生，然后正确覆写<code>getTax()</code>方法就可以。把新的类型传入<code>totalTax()</code>，不需要修改任何代码。</p><p>可见，多态具有一个非常强大的功能，就是允许添加更多类型的子类实现功能扩展，却不需要修改基于父类的代码。</p><h5 id="覆写-Object-方法"><a href="#覆写-Object-方法" class="headerlink" title="覆写 Object 方法"></a>覆写 Object 方法</h5><p>因为所有的<code>class</code>最终都继承自<code>Object</code>，而<code>Object</code>定义了几个重要的方法：</p><ul><li><code>toString()</code>：把 instance 输出为<code>String</code>；</li><li><code>equals()</code>：判断两个 instance 是否逻辑相等；</li><li><code>hashCode()</code>：计算一个 instance 的哈希值。</li></ul><p>在必要的情况下，我们可以覆写<code>Object</code>的这几个方法。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 显示更有意义的字符串:</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Person:name=&quot;</span> + name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 比较是否相等:</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 当且仅当 o 为 Person 类型:</span></span><br><span class="line">        <span class="keyword">if</span> (o <span class="keyword">instanceof</span> Person) &#123;</span><br><span class="line">            Person p = (Person) o;</span><br><span class="line">            <span class="comment">// 并且 name 字段相同时，返回 true:</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.name.equals(p.name);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算 hash:</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name.hashCode();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="调用-super"><a href="#调用-super" class="headerlink" title="调用 super"></a>调用 super</h5><p>在子类的覆写方法中，如果<strong>要调用父类的被覆写的方法</strong>，可以通过<code>super</code>来调用。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> String name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Hello, &quot;</span> + name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 调用父类的 hello()方法:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.hello() + <span class="string">&quot;!&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="final-1"><a href="#final-1" class="headerlink" title="final"></a>final</h5><p>继承可以允许子类覆写父类的方法。如果一个父类不允许子类对它的某个方法进行覆写，可以把该方法标记为<code>final</code>。用<code>final</code>修饰的方法不能被<code>Override</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> String name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Hello, &quot;</span> + name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="comment">// compile error: 不允许覆写</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果一个类不希望任何其他类继承自它，那么可以把这个类本身标记为<code>final</code>。用<code>final</code>修饰的类不能被继承：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> String name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// compile error: 不允许继承自 Person</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于一个类的实例字段，同样可以用<code>final</code>修饰。用<code>final</code>修饰的字段在初始化后不能被修改。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> String name = <span class="string">&quot;Unamed&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对<code>final</code>字段重新赋值会报错：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Person p = <span class="keyword">new</span> Person();</span><br><span class="line">p.name = <span class="string">&quot;New Name&quot;</span>; <span class="comment">// compile error!</span></span><br></pre></td></tr></table></figure><p>可以在构造方法中初始化 final 字段：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> String name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方法更为常用，因为可以保证实例一旦创建，其<code>final</code>字段就不可修改。</p><h4 id="2-5-抽象类"><a href="#2-5-抽象类" class="headerlink" title="2.5 抽象类"></a>2.5 抽象类</h4><h5 id="abstract"><a href="#abstract" class="headerlink" title="abstract"></a>abstract</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果一个<code>class</code>定义了方法，但没有具体执行代码，这个方法就是抽象方法，抽象方法用<code>abstract</code>修饰。</p><p>因为无法执行抽象方法，因此这个类也必须申明为抽象类（abstract class）。</p><p>使用<code>abstract</code>修饰的类就是抽象类。我们无法实例化一个抽象类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Person p = <span class="keyword">new</span> Person(); <span class="comment">// 编译错误</span></span><br></pre></td></tr></table></figure><p>无法实例化的抽象类有什么用？</p><p>因为<strong>抽象类本身被设计成只能用于被继承</strong>，因此，抽象类可以强迫子类实现其定义的抽象方法，否则编译会报错。因此，抽象方法实际上相当于定义了“规范”。</p><p>例如，<code>Person</code>类定义了抽象方法<code>run()</code>，那么，在实现子类<code>Student</code>的时候，就必须覆写<code>run()</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Person p = <span class="keyword">new</span> Student();</span><br><span class="line">        p.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Student.run&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="面向抽象编程"><a href="#面向抽象编程" class="headerlink" title="面向抽象编程"></a>面向抽象编程</h5><p>当我们定义了抽象类<code>Person</code>，以及具体的<code>Student</code>、<code>Teacher</code>子类的时候，我们可以通过抽象类<code>Person</code>类型去引用具体的子类的实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Person s = <span class="keyword">new</span> Student();</span><br><span class="line">Person t = <span class="keyword">new</span> Teacher();</span><br></pre></td></tr></table></figure><p>这种引用抽象类的好处在于，我们对其进行方法调用，并不关心<code>Person</code>类型变量的具体子类型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不关心 Person 变量的具体子类型:</span></span><br><span class="line">s.run();</span><br><span class="line">t.run();</span><br></pre></td></tr></table></figure><p>同样的代码，如果引用的是一个新的子类，我们仍然不关心具体类型：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 同样不关心新的子类是如何实现 run()方法的：</span><br><span class="line">Person e = new Employee();</span><br><span class="line">e.run();</span><br></pre></td></tr></table></figure><p>这种尽量引用高层类型，避免引用实际子类型的方式，称之为面向抽象编程。</p><p>面向抽象编程的本质就是：</p><ul><li>上层代码只定义规范（例如：<code>abstract class Person</code>）；</li><li>不需要子类就可以实现业务逻辑（正常编译）；</li><li>具体的业务逻辑由不同的子类实现，调用者并不关心。</li></ul><h3 id="3-接口"><a href="#3-接口" class="headerlink" title="3. 接口"></a>3. 接口</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p>在抽象类中，抽象方法本质上是定义接口规范：即规定高层类的接口，从而保证所有子类都有相同的接口实现，这样，多态就能发挥出威力。</p><p>如果一个抽象类没有字段，<strong>所有方法全部都是抽象方法</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> String <span class="title">getName</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就可以把该抽象类改写为接口：<code>interface</code>。</p><p>在 Java 中，使用<code>interface</code>可以声明一个接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">String <span class="title">getName</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所谓<code>interface</code>，就是比抽象类还要抽象的纯抽象接口，因为它连字段都不能有。因为接口定义的所有方法默认都是<code>public abstract</code>的，所以这两个修饰符不需要写出来（写不写效果都一样）。</p><p>当一个具体的<code>class</code>去实现一个<code>interface</code>时，需要使用<code>implements</code>关键字。举个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">implements</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="keyword">this</span>.name + <span class="string">&quot; run&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们知道，在 Java 中，一个类只能继承自另一个类，不能从多个类继承。但是，**一个类可以实现多个<code>interface</code>**，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">implements</span> <span class="title">Person</span>, <span class="title">Hello</span> </span>&#123; <span class="comment">// 实现了两个 interface</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="接口继承"><a href="#接口继承" class="headerlink" title="接口继承"></a>接口继承</h4><p>一个<code>interface</code>可以继承自另一个<code>interface</code>。<code>interface</code>继承自<code>interface</code>使用<code>extends</code>，它相当于扩展了接口的方法。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Hello</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Person</span> <span class="keyword">extends</span> <span class="title">Hello</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">String <span class="title">getName</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时，<code>Person</code>接口继承自<code>Hello</code>接口，因此，<code>Person</code>接口现在实际上有3个抽象方法签名，其中一个来自继承的<code>Hello</code>接口。</p><h4 id="default-方法"><a href="#default-方法" class="headerlink" title="default 方法"></a>default 方法</h4><p>在接口中，可以定义<code>default</code>方法。例如，把<code>Person</code>接口的<code>run()</code>方法改为<code>default</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Person p = <span class="keyword">new</span> Student(<span class="string">&quot;Xiao Ming&quot;</span>);  <span class="comment">// new 一个继承 Person 接口的 student 实例</span></span><br><span class="line">        p.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">getName</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;   <span class="comment">// default 修饰符</span></span><br><span class="line">        System.out.println(getName() + <span class="string">&quot; run&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">implements</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现类可以不必覆写<code>default</code>方法。**<code>default</code>方法的目的是，当我们需要给接口新增一个方法时，会涉及到修改全部子类。如果新增的是<code>default</code>方法，那么子类就不必全部修改，只需要在需要覆写的地方去覆写新增方法。**</p><p><code>default</code>方法和抽象类的普通方法是有所不同的。因为<code>interface</code>没有字段，<code>default</code>方法无法访问字段，而抽象类的普通方法可以访问实例字段。</p><h4 id="接口的多态"><a href="#接口的多态" class="headerlink" title="接口的多态"></a>接口的多态</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Hero</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">move</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSpeed</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 继承 Hero 的 Zeus</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Zeus</span> <span class="keyword">implements</span> <span class="title">Hero</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String name = <span class="string">&quot;Zeus&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">move</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(name + <span class="string">&quot;: Move!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSpeed</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 继承 Hero 的 Athena</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Athena</span> <span class="keyword">implements</span> <span class="title">Hero</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String name = <span class="string">&quot;Athena&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">move</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(name + <span class="string">&quot;: Move!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSpeed</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner sc = <span class="keyword">new</span> Scanner((System.in));</span><br><span class="line">        System.out.println(<span class="string">&quot;请选择英雄：&quot;</span>);</span><br><span class="line">        String name =  sc.next();</span><br><span class="line">        Hero hero ;</span><br><span class="line">        <span class="comment">// 先判断是谁</span></span><br><span class="line">        <span class="keyword">if</span>(name.equals(<span class="string">&quot;Zeus&quot;</span>))  </span><br><span class="line">            hero = <span class="keyword">new</span> Zeus(); <span class="comment">// 实例化的对象永远只能是某个具体的子类，但总是通过接口去引用它</span></span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            hero = <span class="keyword">new</span> Athena();</span><br><span class="line">        <span class="comment">// 再执行操作</span></span><br><span class="line">        hero.move();   <span class="comment">// 不管子类是啥 这里都是 Hero 接口的方法</span></span><br><span class="line">        hero.getSpeed();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果没有多态，那么 main 函数会如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner sc = <span class="keyword">new</span> Scanner((System.in));</span><br><span class="line">        System.out.println(<span class="string">&quot;请选择英雄：&quot;</span>);</span><br><span class="line">        String name =  sc.next();</span><br><span class="line">        <span class="comment">// 边判断是谁 边其执行操作</span></span><br><span class="line">        <span class="keyword">if</span>(name.equals(<span class="string">&quot;Zeus&quot;</span>))&#123;</span><br><span class="line">            Zeus hero = <span class="keyword">new</span> Zeus(); </span><br><span class="line">            hero.move();   </span><br><span class="line">        hero.getSpeed();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 边判断是谁 边其执行操作</span></span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            Athena hero = <span class="keyword">new</span> Athena();</span><br><span class="line">            hero.move();   </span><br><span class="line">        hero.getSpeed();  </span><br><span class="line">        &#125;</span><br><span class="line">       </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>相比之下，多态可以通过接口去引用具体的子类，进而达到复用代码的目的。</strong></p><h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><p>生成一个实例时，指定类中某个变量的类型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Stack&lt;Double&gt; stk = <span class="keyword">new</span> Stack&lt;Double&gt;(); <span class="comment">// 这里指定栈 Stack 中存储的为 Double 类型</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// java 中栈 stack 实现的部分源码</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Stack</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">Vector</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates an empty Stack.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Stack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">push</span><span class="params">(E item)</span> </span>&#123;</span><br><span class="line">        addElement(item);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> item;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> E <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        E       obj;</span><br><span class="line">        <span class="keyword">int</span>     len = size();</span><br><span class="line"></span><br><span class="line">        obj = peek();</span><br><span class="line">        removeElementAt(len - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a><a href="https://www.liaoxuefeng.com/wiki/1252599548343744/1255943629175808">集合</a></h2><p>Java 集合的设计有几个特点：</p><ol><li><p>实现了接口和实现类相分离，例如，有序表接口是<code>List</code>，具体的实现类有<code>ArrayList</code>，<code>LinkedList</code>等。</p></li><li><p>支持泛型，我们可以限制在一个集合中只能放入同一种数据类型的元素，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;(); <span class="comment">// 只能放入 String 类型</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="List（有序列表的集合）"><a href="#List（有序列表的集合）" class="headerlink" title="List（有序列表的集合）"></a>List（有序列表的集合）</h3><h4 id="1-接口"><a href="#1-接口" class="headerlink" title="1. 接口"></a>1. 接口</h4><ul><li><code>java.util.List&lt;&gt;</code></li></ul><h4 id="2-实现"><a href="#2-实现" class="headerlink" title="2. 实现"></a>2. 实现</h4><ul><li><code>java.util.ArrayList&lt;&gt;</code>：变长数组（比较适合读取操作）</li><li><code>java.util.LinkedList&lt;&gt;</code>：双链表 (比较适合添加、删除操作 )</li></ul><h4 id="3-函数"><a href="#3-函数" class="headerlink" title="3. 函数"></a>3. 函数</h4><ul><li><code>add()</code>：在末尾添加一个元素</li><li><code>clear()</code>：清空</li><li><code>size()</code>：返回长度</li><li><code>isEmpty()</code>：是否为空</li><li><code>get(i)</code>：获取第 i 个元素</li><li><code>set(i, val)</code>：将第 i 个元素设置为 val</li></ul><h4 id="4-覆写-equals-方法"><a href="#4-覆写-equals-方法" class="headerlink" title="4. 覆写 equals 方法"></a>4. 覆写 equals 方法</h4><p><code>List</code>的<code>contains(Object o)</code>方法和<code>indexOf(Object o)</code>方法依赖于<code>equals</code>方法。</p><p>因此，要正确使用<code>List</code>的<code>contains()</code>、<code>indexOf()</code>这些方法，放入的实例必须正确覆写<code>equals()</code>方法，否则，放进去的实例，查</p><p>找不到。我们之所以能正常放入<code>String</code>、<code>Integer</code>这些对象，是因为 Java 标准库定义的这些类已经正确实现了<code>equals()</code>方法。</p><p>eg：以<code>Person</code>对象为例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;Person&gt; list = List.of(</span><br><span class="line">            <span class="keyword">new</span> Person(<span class="string">&quot;Xiao Ming&quot;</span>),</span><br><span class="line">            <span class="keyword">new</span> Person(<span class="string">&quot;Xiao Hong&quot;</span>),</span><br><span class="line">            <span class="keyword">new</span> Person(<span class="string">&quot;Bob&quot;</span>)</span><br><span class="line">        );</span><br><span class="line">        System.out.println(list.contains(<span class="keyword">new</span> Person(<span class="string">&quot;Bob&quot;</span>))); <span class="comment">// false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><code>equals()</code>方法的正确编写方法：</strong></p><ol><li>先确定实例“相等”的逻辑，即哪些字段相等，就认为实例相等；</li><li>用<code>instanceof</code>判断传入的待比较的<code>Object</code>是不是当前类型，如果是，继续比较，否则，返回<code>false</code>；</li><li>对引用类型用<code>Objects.equals()</code>比较，对基本类型直接用<code>==</code>比较。</li></ol><p>使用<code>Objects.equals()</code>比较两个引用类型是否相等的目的是省去了判断<code>null</code>的麻烦。两个引用类型都是<code>null</code>时它们也是相等的。</p><p>如果不调用<code>List</code>的<code>contains()</code>、<code>indexOf()</code>这些方法，那么放入的元素就不需要实现<code>equals()</code>方法。 </p><p>eg：在 Person 中覆写<code>equals()</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> age;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (o <span class="keyword">instanceof</span> Person) &#123;</span><br><span class="line">        Person p = (Person) o;</span><br><span class="line">        <span class="keyword">return</span> Objects.equals(<span class="keyword">this</span>.name, p.name) &amp;&amp; <span class="keyword">this</span>.age == p.age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-遍历list"><a href="#5-遍历list" class="headerlink" title="5. 遍历list"></a>5. 遍历<code>list</code></h4><p>和数组类型，我们要遍历一个<code>List</code>，完全可以用<code>for</code>循环根据索引配合<code>get(int)</code>方法遍历：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; list = List.of(<span class="string">&quot;apple&quot;</span>, <span class="string">&quot;pear&quot;</span>, <span class="string">&quot;banana&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;list.size(); i++) &#123;</span><br><span class="line">            String s = list.get(i);</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但这种方式并不推荐，一是代码复杂，二是因为<code>get(int)</code>方法只有<code>ArrayList</code>的实现是高效的，换成<code>LinkedList</code>后，索引越大，访问速度越慢。</p><p>所以我们要始终坚持使用迭代器<code>Iterator</code>来访问<code>List</code>。<code>Iterator</code>本身也是一个对象，但它是由<code>List</code>的实例调用<code>iterator()</code>方法的时候创建的。<code>Iterator</code>对象知道如何遍历一个<code>List</code>，并且不同的<code>List</code>类型，返回的<code>Iterator</code>对象实现也是不同的，但<strong>总是具有最高的访问效率</strong>。</p><p><code>Iterator</code>对象有两个方法：<code>boolean hasNext()</code>判断是否有下一个元素，<code>E next()</code>返回下一个元素。因此，使用<code>Iterator</code>遍历<code>List</code>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; list = List.of(<span class="string">&quot;apple&quot;</span>, <span class="string">&quot;pear&quot;</span>, <span class="string">&quot;banana&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (Iterator&lt;String&gt; it = list.iterator(); it.hasNext(); ) &#123;</span><br><span class="line">            String s = it.next();</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有童鞋可能觉得使用<code>Iterator</code>访问<code>List</code>的代码比使用索引更复杂。但是，要记住，<strong>通过<code>Iterator</code>遍历<code>List</code>永远是最高效的方式</strong>。并且，由于<code>Iterator</code>遍历是如此常用，所以，Java 的<code>for each</code>循环本身就可以帮我们使用<code>Iterator</code>遍历。把上面的代码再改写如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; list = List.of(<span class="string">&quot;apple&quot;</span>, <span class="string">&quot;pear&quot;</span>, <span class="string">&quot;banana&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (String s : list) &#123;</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码就是我们编写遍历<code>List</code>的常见代码。</p><p>实际上，只要实现了<code>Iterable</code>接口的集合类都可以直接用<code>for each</code>循环来遍历，Java编译器本身并不知道如何遍历集合对象，但它会自动把<code>for each</code>循环变成<code>Iterator</code>的调用，原因就在于<code>Iterable</code>接口定义了一个<code>Iterator&lt;E&gt; iterator()</code>方法，强迫集合类必须返回一个<code>Iterator</code>实例。</p><h4 id="6-List-和-Array-转换"><a href="#6-List-和-Array-转换" class="headerlink" title="6. List 和 Array 转换"></a>6. List 和 Array 转换</h4><h6 id="List-转-Array"><a href="#List-转-Array" class="headerlink" title="List 转 Array"></a>List 转 Array</h6><ul><li><p>方法一：调用<code>toArray()</code>方法直接返回一个<code>Object[]</code>数组：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = List.of(<span class="string">&quot;apple&quot;</span>, <span class="string">&quot;pear&quot;</span>, <span class="string">&quot;banana&quot;</span>);</span><br><span class="line">Object[] array = list.toArray(); <span class="comment">// 由 String 到 Object 类型</span></span><br></pre></td></tr></table></figure><p>这种方法会丢失类型信息，所以实际应用很少。</p></li><li><p>方法二：给<code>toArray(T[])</code>传入一个类型相同的<code>Array</code>，<code>List</code>内部自动把元素复制到传入的<code>Array</code>中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; list = List.of(<span class="number">12</span>, <span class="number">34</span>, <span class="number">56</span>);</span><br><span class="line">Integer[] array = list.toArray(<span class="keyword">new</span> Integer[<span class="number">3</span>]); <span class="comment">// 由 Integer 到 Integer 类型</span></span><br></pre></td></tr></table></figure><p>如果传入的数组不够大，那么<code>List</code>内部会创建一个新的刚好够大的数组，填充后返回；如果传入的数组比<code>List</code>元素还要多，那么填充完元素后，剩下的数组元素一律填充<code>null</code>。</p></li><li><p>方法三：通过<code>List</code>接口定义的<code>T[] toArray(IntFunction&lt;T[]&gt; generator)</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; list = List.of(<span class="number">12</span>, <span class="number">34</span>, <span class="number">56</span>);</span><br><span class="line">Integer[] array = list.toArray(Integer[]::<span class="keyword">new</span>);</span><br></pre></td></tr></table></figure></li></ul><h6 id="Array-转-List"><a href="#Array-转-List" class="headerlink" title="Array 转 List"></a>Array 转 List</h6><ul><li><p>通过<code>List.of(T...)</code>方法最简单：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Integer[] array = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;;</span><br><span class="line">List&lt;Integer&gt; list = List.of(array);</span><br></pre></td></tr></table></figure><p>对于JDK 11之前的版本，可以使用<code>Arrays.asList(T...)</code>方法把数组转换成<code>List</code>。</p><p>要注意的是，返回的<code>List</code>不一定就是<code>ArrayList</code>或者<code>LinkedList</code>，因为<code>List</code>只是一个接口，如果我们调用<code>List.of()</code>，它返回的是一个只读<code>List</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; list = List.of(<span class="number">12</span>, <span class="number">34</span>, <span class="number">56</span>);</span><br><span class="line">        list.add(<span class="number">999</span>); <span class="comment">// UnsupportedOperationException</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><h4 id="1-类"><a href="#1-类" class="headerlink" title="1. 类"></a>1. 类</h4><ul><li><code>java.util.Stack&lt;&gt;</code></li></ul><h4 id="2-函数"><a href="#2-函数" class="headerlink" title="2. 函数"></a>2. 函数</h4><ul><li><code>push()</code>：压入元素</li><li><code>pop()</code>：弹出栈顶元素，并返回栈顶元素</li><li><code>peek()</code>：返回栈顶元素</li><li><code>size()</code>：返回长度</li><li><code>empty()</code>：栈是否为空</li><li><code>clear()</code>：清空</li></ul><h3 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h3><h4 id="1-接口-1"><a href="#1-接口-1" class="headerlink" title="1. 接口"></a>1. 接口</h4><ul><li><code>java.util.Queue&lt;&gt;</code></li></ul><h4 id="2-实现-1"><a href="#2-实现-1" class="headerlink" title="2.实现"></a>2.实现</h4><ul><li><p><code>java.util.LinkedList&lt;&gt;</code>：双链表</p></li><li><p><code>java.util.PriorityQueue&lt;&gt;</code>：优先队列(<strong>堆</strong>)</p><blockquote><p>默认是小根堆，大根堆写法：<code>new PriorityQueue&lt;(Collections.reverseOrder())</code></p></blockquote></li></ul><h4 id="3-函数-1"><a href="#3-函数-1" class="headerlink" title="3. 函数"></a>3. 函数</h4><ul><li><code>add()</code>：在队尾添加元素</li><li><code>remove()</code>：删除并返回队头</li><li><code>isEmpty()</code>：是否为空</li><li><code>size()</code>：返回长度</li><li><code>peek()</code>：返回队头</li><li><code>clear()</code>：清空</li></ul><h3 id="Set（保证没有重复元素的集合）"><a href="#Set（保证没有重复元素的集合）" class="headerlink" title="Set（保证没有重复元素的集合）"></a>Set（保证没有重复元素的集合）</h3><h4 id="1-接口-2"><a href="#1-接口-2" class="headerlink" title="1. 接口"></a>1. 接口</h4><ul><li><code>java.util.Set&lt;K&gt;</code></li></ul><h5 id="2-实现-2"><a href="#2-实现-2" class="headerlink" title="2. 实现"></a>2. 实现</h5><ul><li><h4 id="java-util-HashSet-lt-K-gt-：哈希表（无序集合）"><a href="#java-util-HashSet-lt-K-gt-：哈希表（无序集合）" class="headerlink" title="java.util.HashSet&lt;K&gt;：哈希表（无序集合）"></a><code>java.util.HashSet&lt;K&gt;</code>：哈希表（无序集合）</h4></li><li><p><code>java.util.TreeSet&lt;K&gt;</code>：平衡树（有序集合，二叉排序树）</p></li></ul><h4 id="3-函数-2"><a href="#3-函数-2" class="headerlink" title="3. 函数"></a>3. 函数</h4><ul><li><code>add()</code>：添加元素</li><li><code>contains()</code>：是否包含某个元素</li><li><code>remove()</code>：删除元素</li><li><code>size()</code>：返回元素数</li><li><code>isEmpty()</code>：是否为空</li><li><code>clear()</code>：清空</li></ul><p><code>java.util.TreeSet</code>多的几个函数：</p><ul><li><code>ceiling(key)</code>：返回大于等于<code>key</code>的最小元素，不存在则返回<code>null</code></li><li><code>floor(key)</code>：返回小于等于<code>key</code>的最大元素，不存在则返回<code>null</code></li></ul><h3 id="Map（通过键值（key-value）查找的映射表集合）"><a href="#Map（通过键值（key-value）查找的映射表集合）" class="headerlink" title="Map（通过键值（key-value）查找的映射表集合）"></a>Map（通过键值（key-value）查找的映射表集合）</h3><blockquote><p>我们知道，<code>List</code>是一种顺序列表，如果有一个存储学生<code>Student</code>实例的<code>List</code>，要在<code>List</code>中根据<code>name</code>查找某个指定的<code>Student</code>的分数，应该怎么办？最简单的方法是遍历<code>List</code>并判断<code>name</code>是否相等，然后返回指定元素。这种需求其实非常常见，即通过一个键去查询对应的值。使用<code>List</code>来实现存在效率非常低的问题，因为平均需要扫描一半的元素才能确定，而<code>Map</code>这种键值（key-value）映射表的数据结构，作用就是能高效通过<code>key</code>快速查找<code>value</code>（元素）。</p></blockquote><h4 id="1-接口-3"><a href="#1-接口-3" class="headerlink" title="1. 接口"></a>1. 接口</h4><ul><li><code>java.util.Map&lt;K, V&gt;</code></li></ul><h4 id="2-实现-3"><a href="#2-实现-3" class="headerlink" title="2. 实现"></a>2. 实现</h4><ul><li><code>java.util.HashMap&lt;K, V&gt;</code>：哈希表（无序集合）</li><li><code>java.util.TreeMap&lt;K, V&gt;</code>：平衡树（有序集合，二叉排序树）</li></ul><h4 id="3-函数-3"><a href="#3-函数-3" class="headerlink" title="3. 函数"></a>3. 函数</h4><ul><li><code>put(key, value)</code>：添加关键字和其对应的值</li><li><code>get(key)</code>：返回关键字对应的值</li><li><code>containsKey(key)</code>：是否包含关键字</li><li><code>remove(key)</code>：删除关键字</li><li><code>size()</code>：返回元素数</li><li><code>isEmpty()</code>：是否为空</li><li><code>clear()</code>：清空</li><li><code>entrySet()</code>：获取<code>Map</code>中的所有对象的集合</li><li><code>Map.Entry&lt;K, V&gt;</code>：<code>Map</code>中的对象类型</li><li><code>getKey()</code>：获取关键字</li><li><code>getValue()</code>：获取值</li></ul><p><code>java.util.TreeMap&lt;K, V&gt;</code>多的函数：</p><ul><li><code>ceilingEntry(key)</code>：返回大于等于<code>key</code>的最小元素，不存在则返回<code>null</code></li><li><code>floorEntry(key)</code>：返回小于等于<code>key</code>的最大元素，不存在则返回<code>null</code></li></ul><h4 id="4-遍历Map"><a href="#4-遍历Map" class="headerlink" title="4. 遍历Map"></a>4. 遍历<code>Map</code></h4><p>对<code>Map</code>来说，要遍历<code>key</code>可以使用<code>for each</code>循环遍历<code>Map</code>实例的<code>keySet()</code>方法返回的<code>Set</code>集合，它包含不重复的<code>key</code>的集合：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Map&lt;String, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">&quot;apple&quot;</span>, <span class="number">123</span>);</span><br><span class="line">        map.put(<span class="string">&quot;pear&quot;</span>, <span class="number">456</span>);</span><br><span class="line">        map.put(<span class="string">&quot;banana&quot;</span>, <span class="number">789</span>);</span><br><span class="line">        <span class="keyword">for</span> (String key : map.keySet()) &#123;</span><br><span class="line">            Integer value = map.get(key);</span><br><span class="line">            System.out.println(key + <span class="string">&quot; = &quot;</span> + value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">banana = <span class="number">789</span></span><br><span class="line">apple = <span class="number">123</span></span><br><span class="line">pear = <span class="number">456</span></span><br></pre></td></tr></table></figure><h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><h3 id="创建一个新线程"><a href="#创建一个新线程" class="headerlink" title="创建一个新线程"></a>创建一个新线程</h3><p>Java 用<code>Thread</code>对象表示一个线程，通过<code>Thread</code>类<code>new</code>的实例对象调用<code>start()</code>启动一个新线程</p><p><code>Thread.sleep()</code>可以把<strong>当前线程</strong>暂停一段时间。</p><p>线程的执行代码写在<code>run()</code>方法中，一旦<code>run()</code>方法执行完毕，新线程就结束了</p><blockquote><p>一个线程实例对象只能调用一次<code>start()</code>方法；</p><p>线程调度由操作系统决定，程序本身无法决定调度顺序；</p></blockquote><p><strong>创建方法1</strong>：从<code>Thread</code>派生一个自定义类，然后覆写<code>run()</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Game</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;  <span class="comment">// 新线程的执行代码</span></span><br><span class="line">        <span class="keyword">super</span>.run();</span><br><span class="line">        <span class="keyword">try</span> &#123;  <span class="comment">// try..catch 包裹 防止等待期间异常;</span></span><br><span class="line">            Thread.sleep(<span class="number">3000</span>);  </span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;game thread&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Game game = <span class="keyword">new</span> Game();</span><br><span class="line">        game.start();  <span class="comment">// 开启新线程</span></span><br><span class="line">        <span class="keyword">try</span> &#123;  <span class="comment">// try..catch 包裹 防止等待期间异常;</span></span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;  <span class="comment">// 防止等待的一秒内出现异常</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;main thread&quot;</span>);   <span class="comment">// 不要写在 try 里面 写在 try 里面会立即打印</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码的结果为</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">main thread</span><br><span class="line">game thread</span><br></pre></td></tr></table></figure><p><code>mian</code>中通过<code>game</code>实例的<code>start</code>方法，启动了一个新的线程，并执行<code>Game</code>类中覆写父类<code>Thread</code>中的<code>run</code>方法，即新线程的执行代码。</p><p>然后<code>main</code>线程与<code>game</code>线程同时<code>sleep</code>，<code>sleep</code>完后再先后各自打印结果。</p><p><strong>创建方法2</strong>：创建<code>Thread</code>实例时，传入一个<code>Runnable</code>实例：</p><blockquote><p>这样<code>runnable</code>可以复用于多个<code>Thread</code>实例</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread t = <span class="keyword">new</span> Thread(<span class="keyword">new</span> MyRunnable());</span><br><span class="line">        t.start(); <span class="comment">// 启动新线程</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;start new thread!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>或者或者用 Java8引入的 lambda 语法进一步简写为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread t = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;start new thread!&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        t.start(); <span class="comment">// 启动新线程</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="线程的状态"><a href="#线程的状态" class="headerlink" title="线程的状态"></a>线程的状态</h3><p>在 Java 程序中，一个线程对象只能调用一次<code>start()</code>方法启动新线程，并在新线程中执行<code>run()</code>方法。一旦<code>run()</code>方法执行完毕，线程就结束了。因此，Java 线程的状态有以下几种：</p><ul><li><code>New</code>：新创建的线程，尚未执行；</li><li><code>Runnable</code>：运行中的线程，正在执行<code>run()</code>方法的 Java 代码；</li><li><code>Blocked</code>：运行中的线程，因为某些操作被阻塞而挂起；</li><li><code>Waiting</code>：运行中的线程，因为某些操作在等待中；</li><li><code>Timed Waiting</code>：运行中的线程，因为执行<code>sleep()</code>方法正在计时等待；</li><li><code>Terminated</code>：线程已终止，因为<code>run()</code>方法执行完毕。</li></ul><p>用一个状态转移图表示如下：</p> <img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/image-20230306152329299.png" alt="image-20230306152329299" style="zoom: 80%;" /><p>线程终止的原因有：</p><ul><li>线程正常终止：<code>run()</code>方法执行到<code>return</code>语句返回；</li><li>线程意外终止：<code>run()</code>方法因为未捕获的异常导致线程终止；</li><li>对某个线程的<code>Thread</code>实例调用<code>stop()</code>方法强制终止（强烈不推荐使用）。</li></ul><p>一个线程还可以等待另一个线程直到其运行结束。例如，<code>main</code>线程在启动<code>game</code>线程后，可以通过<code>game.join()</code>等待<code>game</code>线程结束后再继续运行：</p><blockquote><p><code>game.join(1000)</code>也可以指定一个等待时间，超过等待时间后就不再继续等待</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Game</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;  <span class="comment">// 新线程的执行代码</span></span><br><span class="line">        <span class="keyword">super</span>.run();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">try</span> &#123;  <span class="comment">// try..catch 包裹 防止等待期间异常;</span></span><br><span class="line">            Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;game thread&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Game game = <span class="keyword">new</span> Game();</span><br><span class="line">        game.start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;  <span class="comment">// try..catch 包裹 防止等待期间异常</span></span><br><span class="line">            game.join();  <span class="comment">// main 线程等待 game 线程结束后再继续运行：</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;  <span class="comment">// try..catch 包裹 防止等待期间异常</span></span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;main thread&quot;</span>);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码运行结果为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">game thread</span><br><span class="line">main thread</span><br></pre></td></tr></table></figure><h3 id="中断线程"><a href="#中断线程" class="headerlink" title="中断线程"></a>中断线程</h3><p>如果线程需要执行一个长时间任务，就可能需要能中断线程。中断线程就是其他线程给该线程发一个信号，该线程收到信号后结束执行<code>run()</code>方法，使得自身线程能立刻结束运行。</p><p>我们举个栗子：假设从网络下载一个100M 的文件，如果网速很慢，用户等得不耐烦，就可能在下载过程中点“取消”，这时，程序就需要中断下载线程的执行。</p><p><strong>中断线程有两种常用方案：</strong></p><ol><li><p>对目标线程调用<code>interrupt()</code>方法可以请求中断一个线程，目标线程通过检测<code>isInterrupted()</code>标志获取自身是否已中断。<br>如果目标线程处于等待状态，该线程会捕获到<code>InterruptedException</code>；</p><blockquote><p>目标线程检测到<code>isInterrupted()</code>为<code>true</code>或者捕获了<code>InterruptedException</code>都应该立刻结束自身线程；</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Game game = <span class="keyword">new</span> Game();</span><br><span class="line">        game.start(); <span class="comment">// game 线程启动</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">3000</span>);  <span class="comment">// main 线程睡3秒</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">        game.interrupt(); <span class="comment">// 让 game 线程中断</span></span><br><span class="line">        System.out.println(<span class="string">&quot;main run over&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Game</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.run();</span><br><span class="line">        Player player = <span class="keyword">new</span> Player();</span><br><span class="line">        player.start(); <span class="comment">// play 线程启动</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            player.join();  <span class="comment">// game 线程等待 play 线程执行完</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;game interrupted&quot;</span>);  <span class="comment">// game 线程被中断则打印</span></span><br><span class="line">            player.interrupt();  <span class="comment">// 让 player 线程中断</span></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;game run over&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Player</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.run();</span><br><span class="line">        <span class="keyword">while</span> (!isInterrupted())&#123;  <span class="comment">// 反复判断 player 线程是否被中断</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;player interrupted&quot;</span>);  </span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.printf(<span class="string">&quot;player thread %d\n&quot;</span>,i++);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;player run over&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">player thread <span class="number">0</span></span><br><span class="line">player thread <span class="number">1</span></span><br><span class="line">main run over</span><br><span class="line">game interrupted</span><br><span class="line">game run over</span><br><span class="line">player interrupted</span><br><span class="line">player run over</span><br></pre></td></tr></table></figure></li><li><p>另一个常用的中断线程的方法是设置标志位。通常会用一个<code>running</code>标志位来标识线程是否应该继续运行，在外部线程中，通过把<code>game.running</code>置为<code>false</code>，就可以让线程结束。</p><blockquote><p><code>volatile</code>关键字表明<code>running</code>是一个线程间共享的变量。线程间共享变量需要使用<code>volatile</code>关键字标记，确保每个线程都能读取到更新后的变量值。</p><p>为什么要对线程间共享的变量用关键字<code>volatile</code>声明？这涉及到 Java 的内存模型。在 Java 虚拟机中，变量的值保存在主内存中，但是，当线程访问变量时，它会先获取一个副本，并保存在自己的工作内存中。如果线程修改了变量的值，虚拟机会在某个时刻把修改后的值回写到主内存，但是，这个时间是不确定的！</p><p> <img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/image-20230306163452342.png" alt="image-20230306163452342"></p><p>这会导致如果一个线程更新了某个变量，另一个线程读取的值可能还是更新前的。例如，主内存的变量<code>a = true</code>，线程1执行<code>a = false</code>时，它在此刻仅仅是把变量<code>a</code>的副本变成了<code>false</code>，主内存的变量<code>a</code>还是<code>true</code>，在 JVM 把修改后的<code>a</code>回写到主内存之前，其他线程读取到的<code>a</code>的值仍然是<code>true</code>，这就造成了多线程之间共享的变量不一致。</p><p>因此，<code>volatile</code>关键字的目的是告诉虚拟机：</p><ul><li>每次访问变量时，总是获取主内存的最新值；</li><li>每次修改变量后，立刻回写到主内存。</li></ul><p><code>volatile</code>关键字解决的是可见性问题：当一个线程修改了某个共享变量的值，其他线程能够立刻看到修改后的值。</p><p>如果我们去掉<code>volatile</code>关键字，运行上述程序，发现效果和带<code>volatile</code>差不多，这是因为在 x86的架构下，JVM 回写主内存的速度非常快，但是，换成 ARM 的架构，就会有显著的延迟。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Game game = <span class="keyword">new</span> Game();</span><br><span class="line">        game.start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">        game.running = <span class="keyword">false</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;main run over&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Game</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> running = <span class="keyword">true</span>;  <span class="comment">// 需要添加 volatile 关键字</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.run();</span><br><span class="line">        <span class="keyword">while</span>(running)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.printf(<span class="string">&quot;game thread %d\n&quot;</span>,i++);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;game run over&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码执行结果为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">game thread <span class="number">0</span></span><br><span class="line">game thread <span class="number">1</span></span><br><span class="line">main run over</span><br><span class="line">game thread <span class="number">2</span></span><br><span class="line">game run over</span><br></pre></td></tr></table></figure><p><code>game thread 2</code>之所以在<code>main run over</code>之后，是因为<code>runnig</code>设置为<code>false</code>时，上一次<code>while</code>循环的<code>sleep</code>还在等待，随后才输出<code>game thread 2</code>。</p></li></ol><p><strong>注意：</strong></p><p>正在跑的线程不会响应别的线程发出的中断。</p><p><strong>只有 sleep/wait 状态的线程会响应 interrupt。</strong></p><p>如果一个线程正在跑，别的线程给他发 interrupt，它要继续跑到什么时候才会响应 interrupt 呢？得到自己调用 sleep/wait 的时候。</p><p>如果你写了一个计算密集型任务，跑一次要10分钟，为了能及时响应别的线程发的 interrupt，可以每跑几秒钟就 sleep(1)一下，确保能及时被 interrupt。</p><h3 id="守护线程"><a href="#守护线程" class="headerlink" title="守护线程"></a>守护线程</h3><p>Java 程序入口就是由 JVM 启动<code>main</code>线程，<code>main</code>线程又可以启动其他线程。当所有线程都运行结束时，JVM 退出，进程结束。</p><p>如果有一个线程没有退出，JVM 进程就不会退出。所以，<strong>必须保证所有线程都能及时结束。</strong></p><p>但是有一种线程的目的就是无限循环，例如，一个定时触发任务的线程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TimerThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            System.out.println(LocalTime.now());</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果这个线程不结束，JVM 进程就无法结束。问题是，由谁负责结束这个线程？</p><p>答案是使用守护线程（Daemon Thread）。</p><p>守护线程是指为其他线程服务的线程。<strong>在 JVM 中，所有非守护线程都执行完毕后，无论有没有守护线程，虚拟机都会自动退出。</strong></p><p>因此，JVM 退出时，不必关心守护线程是否已结束。</p><p><strong>如何创建守护线程呢？方法和普通线程一样，只是在调用<code>start()</code>方法前，调用<code>setDaemon(true)</code>把该线程标记为守护线程：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">TimerThread t = <span class="keyword">new</span> TimerThread();</span><br><span class="line">t.setDaemon(<span class="keyword">true</span>);</span><br><span class="line">t.start();</span><br></pre></td></tr></table></figure><p>在守护线程中，编写代码要注意：守护线程不能持有任何需要关闭的资源，例如打开文件等，因为虚拟机退出时，守护线程没有任何机会来关闭文件，这会导致数据丢失。</p><h3 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h3><h4 id="通过-synchronized-加锁"><a href="#通过-synchronized-加锁" class="headerlink" title="通过 synchronized 加锁"></a>通过 synchronized 加锁</h4><p>当多个线程同时运行时，线程的调度由操作系统决定，程序本身无法决定。因此，任何一个线程都有可能在任何指令处被操作系统暂停，然后在某个时间段后继续执行。</p><p>这个时候，有个单线程模型下不存在的问题就来了：如果多个线程同时读写共享变量，会出现数据不一致的问题。</p><p>我们来看一个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> add = <span class="keyword">new</span> AddThread();</span><br><span class="line">        <span class="keyword">var</span> dec = <span class="keyword">new</span> DecThread();</span><br><span class="line">        add.start();</span><br><span class="line">        dec.start();</span><br><span class="line">        add.join();</span><br><span class="line">        dec.join();</span><br><span class="line">        System.out.println(Counter.count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Counter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AddThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10000</span>; i++) &#123; Counter.count += <span class="number">1</span>; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DecThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10000</span>; i++) &#123; Counter.count -= <span class="number">1</span>; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码很简单，两个线程同时对一个<code>int</code>变量进行操作，一个加10000次，一个减10000次，最后结果应该是0，但是，每次运行，结果实际上都是不一样的。</p><p>这是因为对变量进行读取和写入时，结果要正确，必须保证是原子操作。</p><blockquote><p>原子操作是指不能被中断的一个或一系列操作</p></blockquote><p>例如，对于语句：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">n = n + 1;</span><br></pre></td></tr></table></figure><p>看上去是一行语句，实际上对应了3条指令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ILOAD</span><br><span class="line">IADD</span><br><span class="line">ISTORE</span><br></pre></td></tr></table></figure><p>我们假设<code>n</code>的值是<code>100</code>，如果两个线程同时执行<code>n = n + 1</code>，得到的结果很可能不是<code>102</code>，而是<code>101</code>，原因在于：</p><p> <img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/image-20230306165409571.png" alt="image-20230306165409571"></p><p>如果线程1在执行<code>ILOAD</code>后被操作系统中断，此刻如果线程2被调度执行，它执行<code>ILOAD</code>后获取的值仍然是<code>100</code>，最终结果被两个线程的<code>ISTORE</code>写入后变成了<code>101</code>，而不是期待的<code>102</code>。</p><p>这说明多线程模型下，要保证逻辑正确，对共享变量进行读写时，必须保证一组指令以原子方式执行：<strong>即某一个线程执行时，其他线程必须等待：</strong></p> <img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/image-20230306165426556.png" alt="image-20230306165426556" style="zoom:67%;" /><p><strong>通过加锁和解锁的操作，就能保证3条指令总是在一个线程执行期间</strong>，不会有其他线程会进入此指令区间。即使在执行期线程被操作系统中断执行，其他线程也会因为无法获得锁导致无法进入此指令区间。只有执行线程将锁释放后，其他线程才有机会获得锁并执行。这种加锁和解锁之间的代码块我们称之为临界区（Critical Section），任何时候临界区最多只有一个线程能执行。</p><p>可见，保证一段代码的原子性就是通过加锁和解锁实现的。Java 程序使用<code>synchronized</code>关键字对<strong>一个对象进行加锁</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">synchronized(lock) &#123;</span><br><span class="line">    n = n + 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><code>synchronized</code>保证了代码块在任意时刻最多只有一个线程能执行</strong>。我们把上面的代码用<code>synchronized</code>改写如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> add = <span class="keyword">new</span> AddThread();</span><br><span class="line">        <span class="keyword">var</span> dec = <span class="keyword">new</span> DecThread();</span><br><span class="line">        add.start();</span><br><span class="line">        dec.start();</span><br><span class="line">        add.join();</span><br><span class="line">        dec.join();</span><br><span class="line">        System.out.println(Counter.count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Counter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Object lock = <span class="keyword">new</span> Object(); <span class="comment">// Counter 的所有实例锁的是同一个对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AddThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10000</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(Counter.lock) &#123;</span><br><span class="line">                Counter.count += <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DecThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10000</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(Counter.lock) &#123;</span><br><span class="line">                Counter.count -= <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>注意到代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(Counter.lock) &#123; <span class="comment">// 获取锁</span></span><br><span class="line">    ...</span><br><span class="line">&#125; <span class="comment">// 释放锁</span></span><br></pre></td></tr></table></figure><p>它表示<strong>用<code>Counter.lock</code>实例作为锁</strong>，两个线程在执行各自的<code>synchronized(Counter.lock) &#123; ... &#125;</code>代码块时，必须先获得锁，才能进入代码块进行。执行结束后，在<code>synchronized</code>语句块结束会自动释放锁。这样一来，对<code>Counter.count</code>变量进行读写就不可能同时进行。上述代码无论运行多少次，最终结果都是0。</p><p>使用<code>synchronized</code>解决了多线程同步访问共享变量的正确性问题。但是，它的缺点是带来了性能下降。因为<code>synchronized</code>代码块无法并发执行。此外，加锁和解锁需要消耗一定的时间，所以，<code>synchronized</code>会降低程序的执行效率。</p><p>我们来概括一下如何使用<code>synchronized</code>：</p><ol><li>找出修改共享变量的线程代码块；</li><li>选择一个共享实例作为锁；</li><li>使用<code>synchronized(lockObject) &#123; ... &#125;</code>。</li></ol><p>在使用<code>synchronized</code>的时候，不必担心抛出异常。因为无论是否有异常，都会在<code>synchronized</code>结束处正确释放锁：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (obj) &#123;</span><br><span class="line">        <span class="keyword">if</span> (m &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.value += m;</span><br><span class="line">    &#125; <span class="comment">// 无论有无异常，都会在此释放锁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们再来看一个错误使用<code>synchronized</code>的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> add = <span class="keyword">new</span> AddThread();</span><br><span class="line">        <span class="keyword">var</span> dec = <span class="keyword">new</span> DecThread();</span><br><span class="line">        add.start();</span><br><span class="line">        dec.start();</span><br><span class="line">        add.join();</span><br><span class="line">        dec.join();</span><br><span class="line">        System.out.println(Counter.count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Counter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Object lock1 = <span class="keyword">new</span> Object();  <span class="comment">// 锁的不是同一个对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Object lock2 = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AddThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10000</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(Counter.lock1) &#123;</span><br><span class="line">                Counter.count += <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DecThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10000</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(Counter.lock2) &#123;</span><br><span class="line">                Counter.count -= <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果并不是0，这是因为两个线程各自的<code>synchronized</code>锁住的<em><strong>不是同一个对象</strong></em>！这使得两个线程各自都可以同时获得锁：因为 JVM 只保证同一个锁在任意时刻只能被一个线程获取，但两个不同的锁在同一时刻可以被两个线程分别获取。</p><p>因此，使用<code>synchronized</code>的时候，获取到的是哪个锁非常重要。锁对象如果不对，代码逻辑就不对。</p><p>我们再看一个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> ts = <span class="keyword">new</span> Thread[] &#123; <span class="keyword">new</span> AddStudentThread(), <span class="keyword">new</span> DecStudentThread(), <span class="keyword">new</span> AddTeacherThread(), <span class="keyword">new</span> DecTeacherThread() &#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> t : ts) &#123;</span><br><span class="line">            t.start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> t : ts) &#123;</span><br><span class="line">            t.join();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Counter.studentCount);</span><br><span class="line">        System.out.println(Counter.teacherCount);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Counter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Object lock = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> studentCount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> teacherCount = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AddStudentThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10000</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(Counter.lock) &#123;</span><br><span class="line">                Counter.studentCount += <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DecStudentThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10000</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(Counter.lock) &#123;</span><br><span class="line">                Counter.studentCount -= <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AddTeacherThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10000</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(Counter.lock) &#123;</span><br><span class="line">                Counter.teacherCount += <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DecTeacherThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10000</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(Counter.lock) &#123;</span><br><span class="line">                Counter.teacherCount -= <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码的4个线程对两个共享变量分别进行读写操作，但是使用的锁都是<code>Counter.lock</code>这一个对象，这就造成了原本可以并发执行的<code>Counter.studentCount += 1</code>和<code>Counter.teacherCount += 1</code>，现在无法并发执行了，执行效率大大降低。实际上，需要同步的线程可以分成两组：<code>AddStudentThread</code>和<code>DecStudentThread</code>，<code>AddTeacherThread</code>和<code>DecTeacherThread</code>，组之间不存在竞争，因此，应该使用两个不同的锁，即：</p><p><code>AddStudentThread</code>和<code>DecStudentThread</code>使用<code>lockStudent</code>锁：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(Counter.lockStudent) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>AddTeacherThread</code>和<code>DecTeacherThread</code>使用<code>lockTeacher</code>锁：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(Counter.lockTeacher) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样才能最大化地提高执行效率。</p><h4 id="不需要-synchronized-的操作"><a href="#不需要-synchronized-的操作" class="headerlink" title="不需要 synchronized 的操作"></a>不需要 synchronized 的操作</h4><p>JVM 规范定义了几种原子操作：</p><ul><li>基本类型（<code>long</code>和<code>double</code>除外）赋值，例如：<code>int n = m</code>；</li><li>引用类型赋值，例如：<code>List&lt;String&gt; list = anotherList</code>。</li></ul><p><code>long</code>和<code>double</code>是64位数据，JVM 没有明确规定64位赋值操作是不是一个原子操作，不过在 x64平台的 JVM 是把<code>long</code>和<code>double</code>的赋值作为原子操作实现的。</p><p>单条原子操作的语句不需要同步。例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public void set(int m) &#123;</span><br><span class="line">    synchronized(lock) &#123;</span><br><span class="line">        this.value = m;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就不需要同步。</p><p>对引用也是类似。例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public void set(String s) &#123;</span><br><span class="line">    this.value = s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述赋值语句并不需要同步。</p><p>但是，如果是多行赋值语句，就必须保证是同步操作，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class Pair &#123;</span><br><span class="line">    int first;</span><br><span class="line">    int last;</span><br><span class="line">    public void set(int first, int last) &#123;</span><br><span class="line">        synchronized(this) &#123;</span><br><span class="line">            this.first = first;</span><br><span class="line">            this.last = last;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有些时候，通过一些巧妙的转换，可以把非原子操作变为原子操作。例如，上述代码如果改造成：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class Pair &#123;</span><br><span class="line">    int[] pair;</span><br><span class="line">    public void set(int first, int last) &#123;</span><br><span class="line">        int[] ps = new int[] &#123; first, last &#125;;</span><br><span class="line">        this.pair = ps;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就不再需要同步，因为<code>this.pair = ps</code>是引用赋值的原子操作。而语句：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int[] ps = new int[] &#123; first, last &#125;;</span><br></pre></td></tr></table></figure><p>这里的<code>ps</code>是方法内部定义的局部变量，每个线程都会有各自的局部变量，互不影响，并且互不可见，并不需要同步。</p><h3 id="同步方法"><a href="#同步方法" class="headerlink" title="同步方法"></a>同步方法</h3><p>我们知道 Java 程序依靠<code>synchronized</code>对线程进行同步，使用<code>synchronized</code>的时候，锁住的是哪个对象非常重要。</p><p>让线程自己选择锁对象往往会使得代码逻辑混乱，也不利于封装。更好的方法是把<code>synchronized</code>逻辑封装起来。例如，我们编写一个计数器如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Counter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line">            count += n;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dec</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line">            count -= n;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">()</span> </span>&#123;  <span class="comment">// 只是读 不需要加锁</span></span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样一来，线程调用<code>add()</code>、<code>dec()</code>方法时，它不必关心同步逻辑，因为<code>synchronized</code>代码块在<code>add()</code>、<code>dec()</code>方法内部。并且，我们注意到，<code>synchronized</code>锁住的对象是<code>this</code>，即当前实例，这又使得创建多个<code>Counter</code>实例的时候，它们之间互不影响，可以并发执行。</p><p>现在，对于<code>Counter</code>类，多线程可以正确调用。</p><p>如果一个类被设计为允许多线程正确访问，我们就说这个类就是“线程安全”的（thread-safe），上面的<code>Counter</code>类就是线程安全的。Java 标准库的<code>java.lang.StringBuffer</code>也是线程安全的。</p><p>还有一些不变类，例如<code>String</code>，<code>Integer</code>，<code>LocalDate</code>，它们的所有成员变量都是<code>final</code>，多线程同时访问时只能读不能写，这些不变类也是线程安全的。</p><p>最后，类似<code>Math</code>这些只提供静态方法，没有成员变量的类，也是线程安全的。</p><p>除了上述几种少数情况，大部分类，例如<code>ArrayList</code>，都是非线程安全的类，我们不能在多线程中修改它们。但是，如果所有线程都只读取，不写入，那么<code>ArrayList</code>是可以安全地在线程间共享的。</p><blockquote><p>没有特殊说明时，一个类默认是非线程安全的。</p></blockquote><p>我们再观察<code>Counter</code>的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Counter</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line">            count += n;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我们锁住的是<code>this</code>实例时，实际上可以用<code>synchronized</code>修饰这个方法。下面两种写法是等价的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123; <span class="comment">// 锁住 this</span></span><br><span class="line">        count += n;</span><br><span class="line">    &#125; <span class="comment">// 解锁</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123; <span class="comment">// 锁住 this</span></span><br><span class="line">    count += n;</span><br><span class="line">&#125; <span class="comment">// 解锁</span></span><br></pre></td></tr></table></figure><p>因此，用<code>synchronized</code>修饰的方法就是同步方法，它表示整个方法都必须用<code>this</code>实例加锁。</p><p>我们再思考一下，如果对一个静态方法添加<code>synchronized</code>修饰符，它锁住的是哪个对象？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于<code>static</code>方法，是没有<code>this</code>实例的，因为<code>static</code>方法是针对类而不是实例。但是我们注意到任何一个类都有一个由 JVM 自动创建的<code>Class</code>实例，因此，对<code>static</code>方法添加<code>synchronized</code>，锁住的是该类的<code>Class</code>实例。上述<code>synchronized static</code>方法实际上相当于：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Counter</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(Counter.class) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们再考察<code>Counter</code>的<code>get()</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Counter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它没有同步，因为读一个<code>int</code>变量不需要同步。</p><p>然而，如果我们把代码稍微改一下，返回一个包含两个<code>int</code>的对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Counter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> first;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> last;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Pair <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Pair p = <span class="keyword">new</span> Pair();</span><br><span class="line">        p.first = first;</span><br><span class="line">        p.last = last;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就必须要同步了。</p><h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><p>Java 的线程锁是可重入的锁。</p><p>什么是可重入的锁？我们还是来看例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Counter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            dec(-n);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            count += n;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">dec</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        count += n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>观察<code>synchronized</code>修饰的<code>add()</code>方法，一旦线程执行到<code>add()</code>方法内部，说明它已经获取了当前实例的<code>this</code>锁。如果传入的<code>n &lt; 0</code>，将在<code>add()</code>方法内部调用<code>dec()</code>方法。由于<code>dec()</code>方法也需要获取<code>this</code>锁，现在问题来了：</p><p>对同一个线程，能否在获取到锁以后继续获取同一个锁？</p><p>答案是肯定的。JVM 允许同一个线程重复获取同一个锁，这种能被同一个线程反复获取的锁，就叫做可重入锁。</p><p>由于 Java 的线程锁是可重入锁，所以，获取锁的时候，不但要判断是否是第一次获取，还要记录这是第几次获取。每获取一次锁，记录+1，每退出<code>synchronized</code>块，记录-1，<strong>减到0的时候，才会真正释放锁</strong>。</p><p>一个线程可以获取一个锁后，再继续获取另一个锁。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(lockA) &#123; <span class="comment">// 获得 lockA 的锁</span></span><br><span class="line">        <span class="keyword">this</span>.value += m;</span><br><span class="line">        <span class="keyword">synchronized</span>(lockB) &#123; <span class="comment">// 获得 lockB 的锁</span></span><br><span class="line">            <span class="keyword">this</span>.another += m;</span><br><span class="line">        &#125; <span class="comment">// 释放 lockB 的锁</span></span><br><span class="line">    &#125; <span class="comment">// 释放 lockA 的锁</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dec</span><span class="params">(<span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(lockB) &#123; <span class="comment">// 获得 lockB 的锁</span></span><br><span class="line">        <span class="keyword">this</span>.another -= m;</span><br><span class="line">        <span class="keyword">synchronized</span>(lockA) &#123; <span class="comment">// 获得 lockA 的锁</span></span><br><span class="line">            <span class="keyword">this</span>.value -= m;</span><br><span class="line">        &#125; <span class="comment">// 释放 lockA 的锁</span></span><br><span class="line">    &#125; <span class="comment">// 释放 lockB 的锁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在获取多个锁的时候，不同线程获取多个不同对象的锁可能导致死锁。对于上述代码，线程1和线程2如果分别执行<code>add()</code>和<code>dec()</code>方法时：</p><ul><li>线程1：进入<code>add()</code>，获得<code>lockA</code>；</li><li>线程2：进入<code>dec()</code>，获得<code>lockB</code>。</li></ul><p>随后：</p><ul><li>线程1：准备获得<code>lockB</code>，失败，等待中；</li><li>线程2：准备获得<code>lockA</code>，失败，等待中。</li></ul><p><strong>此时，两个线程各自持有不同的锁，然后各自试图获取对方手里的锁，造成了双方无限等待下去，这就是死锁</strong>。</p><p>死锁发生后，没有任何机制能解除死锁，只能强制结束 JVM 进程。</p><p>因此，在编写多线程应用时，要特别注意防止死锁。因为死锁一旦形成，就只能强制结束进程。</p><p>那么我们应该如何避免死锁呢？答案是：线程获取锁的顺序要一致。即严格按照先获取<code>lockA</code>，再获取<code>lockB</code>的顺序，改写<code>dec()</code>方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dec</span><span class="params">(<span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(lockA) &#123; <span class="comment">// 获得 lockA 的锁</span></span><br><span class="line">        <span class="keyword">this</span>.value -= m;</span><br><span class="line">        <span class="keyword">synchronized</span>(lockB) &#123; <span class="comment">// 获得 lockB 的锁</span></span><br><span class="line">            <span class="keyword">this</span>.another -= m;</span><br><span class="line">        &#125; <span class="comment">// 释放 lockB 的锁</span></span><br><span class="line">    &#125; <span class="comment">// 释放 lockA 的锁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="wait、notify、notifyAll"><a href="#wait、notify、notifyAll" class="headerlink" title="wait、notify、notifyAll"></a>wait、notify、notifyAll</h3><h4 id="多线程协调问题"><a href="#多线程协调问题" class="headerlink" title="多线程协调问题"></a>多线程协调问题</h4><p>在 Java 程序中，<code>synchronized</code>解决了多线程竞争的问题。例如，对于一个任务管理器，<strong>多个线程同时往队列中添加任务</strong>，可以用<code>synchronized</code>加锁：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TaskQueue</span> </span>&#123;</span><br><span class="line">    Queue&lt;String&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="comment">// synchronized 保证了在任意时刻最多只有一个线程往队列中添加任务</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">addTask</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.queue.add(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是<code>synchronized</code>并没有解决多线程协调的问题。</p><p>仍然以上面的<code>TaskQueue</code>为例，我们再编写一个<code>getTask()</code>方法取出队列的第一个任务：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TaskQueue</span> </span>&#123;</span><br><span class="line">    Queue&lt;String&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">addTask</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.queue.add(s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> String <span class="title">getTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (queue.isEmpty()) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> queue.remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码看上去没有问题：<code>getTask()</code>内部先判断队列是否为空，如果为空，就循环等待，直到另一个线程往队列中放入了一个任务，<code>while()</code>循环退出，就可以返回队列的元素了。</p><p>但实际上<code>while()</code>循环永远不会退出。因为线程在执行<code>while()</code>循环时，已经在<code>getTask()</code>入口获取了<code>this</code>锁，其他线程根本无法调用<code>addTask()</code>，因为<code>addTask()</code>执行条件也是获取<code>this</code>锁。</p><p>因此，执行上述代码，线程会在<code>getTask()</code>中因为死循环而100%占用 CPU 资源。</p><p>如果深入思考一下，我们想要的执行效果是：</p><ul><li>线程1可以调用<code>addTask()</code>不断往队列中添加任务；</li><li>线程2可以调用<code>getTask()</code>从队列中获取任务。如果队列为空，则<code>getTask()</code>应该等待，直到队列中至少有一个任务时再返回。</li></ul><p>因此，<strong>多线程协调运行的原则就是：当条件不满足时，线程进入等待状态；当条件满足时，线程被唤醒，继续执行任务</strong>。</p><h4 id="wait-方法"><a href="#wait-方法" class="headerlink" title="wait()方法"></a>wait()方法</h4><p>对于上述<code>TaskQueue</code>，我们先改造<code>getTask()</code>方法，在条件不满足时，线程进入等待状态：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> String <span class="title">getTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (queue.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">this</span>.wait();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> queue.remove();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当一个线程执行到<code>getTask()</code>方法内部的<code>while</code>循环时，它必定已经获取到了<code>this</code>锁，此时，线程执行<code>while</code>条件判断，如果条件成立（队列为空），线程将执行<code>this.wait()</code>，进入等待状态，且<strong>会释放线程获得的锁</strong>，直到将来某个时刻，线程从等待状态被其他线程唤醒后，<code>wait()</code>方法才会返回，线程又会重新试图获得锁，然后，继续执行下一条语句。</p><blockquote><p><code>wait()</code>方法必须在当前获取的锁对象上调用，这里获取的是<code>this</code>锁，因此调用<code>this.wait()</code>。</p></blockquote><h4 id="notify-方法"><a href="#notify-方法" class="headerlink" title="notify 方法"></a>notify 方法</h4><p>如何让等待的线程被重新唤醒，然后从<code>wait()</code>方法返回？答案是在相同的锁对象上调用<code>notify()</code>方法。我们修改<code>addTask()</code>如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">addTask</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.queue.add(s);</span><br><span class="line">    <span class="keyword">this</span>.notify(); <span class="comment">// 唤醒在 this 锁等待的线程</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="notifyAll-方法"><a href="#notifyAll-方法" class="headerlink" title="notifyAll 方法"></a>notifyAll 方法</h4><p>当有多个线程正在<code>getTask()</code>方法内部的<code>wait()</code>中等待，使用<code>notifyAll()</code>可以将其一次性全部唤醒，而<code>notify()</code>只会唤醒其中一个（具体哪个依赖操作系统，有一定的随机性），通常来说，<code>notifyAll()</code>更安全。有些时候，如果我们的代码逻辑考虑不周，用<code>notify()</code>会导致只唤醒了一个线程，而其他线程可能永远等待下去醒不过来了</p><p>但使用<code>notifyAll</code>需格外注意：</p><ul><li><strong>当前等待的多个线程全部被唤醒，不代表这多个线程全部都会重新获得锁，他们其中只会有一个线程会重新获得锁，并执行<code>wait</code>方法后面的代码。</strong></li></ul><p>例如：开了5个线程一直等待从任务队列里获取任务，随后开了1个线程每0.1秒往任务队列里添加任务，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        TaskQueue q = <span class="keyword">new</span> TaskQueue();</span><br><span class="line">        ArrayList&lt;Thread&gt; getTaskTherads = <span class="keyword">new</span> ArrayList&lt;&gt;();  <span class="comment">// 存放线程的 list</span></span><br><span class="line">        <span class="comment">// 开启5个线程 一直等待从任务队列里获取任务</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            Thread t = <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;  <span class="comment">// 会一直等待 死循环</span></span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            String s = q.getTask();</span><br><span class="line">                            System.out.println(<span class="string">&quot;execute task: &quot;</span> + s);</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                            <span class="keyword">return</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            t.start();</span><br><span class="line">            getTaskTherads.add(t);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 开启1个线程 每0.1秒往任务队列里添加任务</span></span><br><span class="line">        Thread add = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                String s = <span class="string">&quot;task-&quot;</span> + i;</span><br><span class="line">                System.out.println(<span class="string">&quot;add task: &quot;</span> + s);</span><br><span class="line">                q.addTask(s);</span><br><span class="line">                <span class="keyword">try</span> &#123; Thread.sleep(<span class="number">100</span>); &#125; <span class="keyword">catch</span>(InterruptedException e) &#123;&#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        </span><br><span class="line">        add.start();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 等待 add 线程结束后再继续运行 main 线程;</span></span><br><span class="line">        add.join();</span><br><span class="line">        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// add 线程结束后 因为从任务队列里获取任务的5个线程是一直等待的，一旦任务队列不为空，其就会取出任务，</span></span><br><span class="line">        <span class="comment">// 即使 add 进程结束，获取任务的5个进程也会一直 while 循环 所以这里需要中断这5个进程</span></span><br><span class="line">        <span class="keyword">for</span> (Thread t : getTaskTherads) &#123;</span><br><span class="line">            t.interrupt();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TaskQueue</span> </span>&#123;</span><br><span class="line">    Queue&lt;String&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">addTask</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.queue.add(s);</span><br><span class="line">        <span class="keyword">this</span>.notifyAll();  <span class="comment">// 唤醒所有等待的进程</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> String <span class="title">getTask</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (queue.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">this</span>.wait();   </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> queue.remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意这里，<code>wait()</code>方法返回时需要重新获得<code>this</code>锁。假设当前有3个线程被唤醒，唤醒后，首先要等待执行<code>addTask()</code>的线程结束此方法后，才能释放<code>this</code>锁，随后，这3个线程中只能有一个获取到<code>this</code>锁，剩下2个将继续等待。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> String <span class="title">getTask</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (queue.isEmpty()) &#123;</span><br><span class="line">             <span class="comment">// 释放 this 锁:</span></span><br><span class="line">            <span class="keyword">this</span>.wait();  </span><br><span class="line">            <span class="comment">// 重新获取 this 锁   </span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> queue.remove();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果将<code>while</code>改为<code>if</code>,则会出现问题：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> String <span class="title">getTask</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (queue.isEmpty()) &#123;</span><br><span class="line">             <span class="comment">// 释放 this 锁:</span></span><br><span class="line">            <span class="keyword">this</span>.wait();  </span><br><span class="line">            <span class="comment">// 重新获取 this 锁   </span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> queue.remove();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为，假设任务队列中新加了一个任务，且任务队列中只有一个任务，</p><p>对于5个正在一直等待获取任务的线程，通过<code>notifyAll</code>将其全部唤醒，假设只有线程1重新获取了锁，再执行完<code>return queue.remove();</code>后，此时队列为空，且线程1因为执行完了<code>getTask</code>方法会释放锁，那么对于线程2，因为是<code>if</code>，它会直接执行<code>this.wait</code>下的代码，跳过<code>if</code>判断，直接<code>return queue.remove();</code>，但此刻任务队列可能已经没有任何元素了。</p><p>总结：如果是用<code>while</code>作判断，每次<code>wait</code>被<code>notifyAll</code>唤醒后都要先判断当前队列是否为空，而<code>if</code>做判断时，如果<code>wait</code>被唤醒，则直接执行<code>wait</code>后的代码，获取队列元素。</p><h3 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h3><p>从 Java 5开始，引入了一个高级的处理并发的<code>java.util.concurrent</code>包，它提供了大量更高级的并发功能，能大大简化多线程程序的编写。</p><p>我们知道 Java 语言直接提供了<code>synchronized</code>关键字用于加锁，但这种锁一是很重，二是获取时必须一直等待，没有额外的尝试机制。</p><p><code>java.util.concurrent.locks</code>包提供的<code>ReentrantLock</code>用于替代<code>synchronized</code>加锁，我们来看一下传统的<code>synchronized</code>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Counter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line">            count += n;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果用<code>ReentrantLock</code>替代，可以把代码改造为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Counter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            count += n;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为<code>synchronized</code>是 Java 语言层面提供的语法，所以我们不需要考虑异常，而<code>ReentrantLock</code>是 Java 代码实现的锁，我们就必须先获取锁，然后在<code>finally</code>中正确释放锁。</p><p>顾名思义，<code>ReentrantLock</code>是可重入锁，它和<code>synchronized</code>一样，一个线程可以多次获取同一个锁。</p><p>和<code>synchronized</code>不同的是，<code>ReentrantLock</code>可以尝试获取锁：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (lock.tryLock(<span class="number">1</span>, TimeUnit.SECONDS)) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码在尝试获取锁的时候，最多等待1秒。如果1秒后仍未获取到锁，<code>tryLock()</code>返回<code>false</code>，程序就可以做一些额外处理，而不是无限等待下去。</p><p>所以，使用<code>ReentrantLock</code>比直接使用<code>synchronized</code>更安全，线程在<code>tryLock()</code>失败的时候不会导致死锁。</p><h3 id="Condition"><a href="#Condition" class="headerlink" title="Condition"></a>Condition</h3><p>使用<code>ReentrantLock</code>比直接使用<code>synchronized</code>更安全，可以替代<code>synchronized</code>进行线程同步。</p><p>但是，<code>synchronized</code>可以配合<code>wait</code>和<code>notify</code>实现线程在条件不满足时等待，条件满足时唤醒，用<code>ReentrantLock</code>我们怎么编写<code>wait</code>和<code>notify</code>的功能呢？</p><p>答案是使用<code>Condition</code>对象来实现<code>wait</code>和<code>notify</code>的功能。</p><p>我们仍然以<code>TaskQueue</code>为例，把前面用<code>synchronized</code>实现的功能通过<code>ReentrantLock</code>和<code>Condition</code>来实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TaskQueue</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Condition condition = lock.newCondition(); <span class="comment">// 从 lock 获取 condition</span></span><br><span class="line">    <span class="keyword">private</span> Queue&lt;String&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addTask</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            queue.add(s);</span><br><span class="line">            condition.signalAll();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (queue.isEmpty()) &#123;</span><br><span class="line">                condition.await();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> queue.remove();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可见，<strong>使用<code>Condition</code>时，引用的<code>Condition</code>对象必须从<code>Lock</code>实例的<code>newCondition()</code>返回，这样才能获得一个绑定了<code>Lock</code>实例的<code>Condition</code>实例</strong>。</p><p><code>Condition</code>提供的<code>await()</code>、<code>signal()</code>、<code>signalAll()</code>原理和<code>synchronized</code>锁对象的<code>wait()</code>、<code>notify()</code>、<code>notifyAll()</code>是一致的，并且其行为也是一样的：</p><ul><li><code>await()</code>会释放当前锁，进入等待状态；</li><li><code>signal()</code>会唤醒某个等待线程；</li><li><code>signalAll()</code>会唤醒所有等待线程；</li><li>唤醒线程从<code>await()</code>返回后需要重新获得锁。</li></ul><p>此外，和<code>tryLock()</code>类似，<code>await()</code>可以在等待指定时间后，如果还没有被其他线程通过<code>signal()</code>或<code>signalAll()</code>唤醒，可以自己醒来：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (condition.await(<span class="number">1</span>, TimeUnit.SECOND)) &#123;</span><br><span class="line">    <span class="comment">// 被其他线程唤醒</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 指定时间内没有被其他线程唤醒</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可见，使用<code>Condition</code>配合<code>Lock</code>，我们可以实现更灵活的线程同步。</p><h3 id="ReadWriteLock"><a href="#ReadWriteLock" class="headerlink" title="ReadWriteLock"></a>ReadWriteLock</h3><p>前面讲到的<code>ReentrantLock</code>保证了只有一个线程可以执行临界区代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Counter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] counts = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inc</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            counts[index] += <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] get() &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> Arrays.copyOf(counts, counts.length);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是有些时候，这种保护有点过头。因为我们发现，任何时刻，只允许一个线程修改，也就是调用<code>inc()</code>方法是必须获取锁，但是，<code>get()</code>方法只读取数据，不修改数据，它实际上允许多个线程同时调用。</p><p>实际上我们想要的是：允许多个线程同时读，但只要有一个线程在写，其他线程就必须等待：</p><table><thead><tr><th align="left"></th><th align="left">读</th><th align="left">写</th></tr></thead><tbody><tr><td align="left">读</td><td align="left">允许</td><td align="left">不允许</td></tr><tr><td align="left">写</td><td align="left">不允许</td><td align="left">不允许</td></tr></tbody></table><p>使用<code>ReadWriteLock</code>可以解决这个问题，它保证：</p><ul><li>只允许一个线程写入（其他线程既不能写入也不能读取）；</li><li>没有写入时，多个线程允许同时读（提高性能）。</li></ul><p>用<code>ReadWriteLock</code>实现这个功能十分容易。我们需要创建一个<code>ReadWriteLock</code>实例，然后分别获取读锁和写锁：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Counter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ReadWriteLock rwlock = <span class="keyword">new</span> ReentrantReadWriteLock();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Lock rlock = rwlock.readLock();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Lock wlock = rwlock.writeLock();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] counts = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inc</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        wlock.lock(); <span class="comment">// 加写锁</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            counts[index] += <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            wlock.unlock(); <span class="comment">// 释放写锁</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] get() &#123;</span><br><span class="line">        rlock.lock(); <span class="comment">// 加读锁</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> Arrays.copyOf(counts, counts.length);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            rlock.unlock(); <span class="comment">// 释放读锁</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>把读写操作分别用读锁和写锁来加锁，在读取时，多个线程可以同时获得读锁，这样就大大提高了并发读的执行效率。</p><p>使用<code>ReadWriteLock</code>时，适用条件是同一个数据，有大量线程读取，但仅有少数线程修改。</p><p>例如，一个论坛的帖子，回复可以看做写入操作，它是不频繁的，但是，浏览可以看做读取操作，是非常频繁的，这种情况就可以使用<code>ReadWriteLock</code>。</p><h3 id="StampedLock"><a href="#StampedLock" class="headerlink" title="StampedLock"></a>StampedLock</h3><p>前面介绍的<code>ReadWriteLock</code>可以解决多线程同时读，但只有一个线程能写的问题。</p><p>如果我们深入分析<code>ReadWriteLock</code>，会发现它有个潜在的问题：如果有线程正在读，写线程需要等待读线程释放锁后才能获取写锁，即读的过程中不允许写，这是一种悲观的读锁。</p><p>要进一步提升并发执行效率，Java 8引入了新的读写锁：<code>StampedLock</code>。</p><p><code>StampedLock</code>和<code>ReadWriteLock</code>相比，改进之处在于：<strong>读的过程中也允许获取写锁后写入</strong>！这样一来，我们读的数据就可能不一致，所以，需要一点额外的代码来判断读的过程中是否有写入，这种读锁是一种乐观锁。</p><p>乐观锁的意思就是乐观地估计读的过程中大概率不会有写入，因此被称为乐观锁。反过来，悲观锁则是读的过程中拒绝有写入，也就是写入必须等待。<strong>显然乐观锁的并发效率更高，但一旦有小概率的写入导致读取的数据不一致，需要能检测出来，再读一遍就行。</strong></p><p>我们来看例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> StampedLock stampedLock = <span class="keyword">new</span> StampedLock();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> x;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> y;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">move</span><span class="params">(<span class="keyword">double</span> deltaX, <span class="keyword">double</span> deltaY)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> stamp = stampedLock.writeLock(); <span class="comment">// 获取写锁</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            x += deltaX;</span><br><span class="line">            y += deltaY;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            stampedLock.unlockWrite(stamp); <span class="comment">// 释放写锁</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">distanceFromOrigin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> stamp = stampedLock.tryOptimisticRead(); <span class="comment">// 获得一个乐观读锁</span></span><br><span class="line">        <span class="comment">// 注意下面两行代码不是原子操作</span></span><br><span class="line">        <span class="comment">// 假设 x,y = (100,200)</span></span><br><span class="line">        <span class="keyword">double</span> currentX = x;</span><br><span class="line">        <span class="comment">// 此处已读取到 x=100，但 x,y 可能被写线程修改为(300,400)</span></span><br><span class="line">        <span class="keyword">double</span> currentY = y;</span><br><span class="line">        <span class="comment">// 此处已读取到 y，如果没有写入，读取是正确的(100,200)</span></span><br><span class="line">        <span class="comment">// 如果有写入，读取是错误的(100,400)</span></span><br><span class="line">        <span class="keyword">if</span> (!stampedLock.validate(stamp)) &#123; <span class="comment">// 检查乐观读锁后是否有其他写锁发生,有的话 则再用悲观锁读一遍</span></span><br><span class="line">            stamp = stampedLock.readLock(); <span class="comment">// 获取一个悲观读锁</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                currentX = x;</span><br><span class="line">                currentY = y;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                stampedLock.unlockRead(stamp); <span class="comment">// 释放悲观读锁</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.sqrt(currentX * currentX + currentY * currentY);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和<code>ReadWriteLock</code>相比，写入的加锁是完全一样的，不同的是读取。注意到<strong>首先我们通过<code>tryOptimisticRead()</code>获取一个乐观读锁，并返回版本号</strong>。接着进行读取，读取完成后，我们<strong>通过<code>validate()</code>去验证版本号</strong>，如果在读取过程中没有写入，版本号不变，验证成功，我们就可以放心地继续后续操作。如果在读取过程中有写入，版本号会发生变化，验证将失败。在失败的时候，我们再通过获取悲观读锁再次读取。由于写入的概率不高，程序在绝大部分情况下可以通过乐观读锁获取数据，极少数情况下使用悲观读锁获取数据。</p><blockquote><p>注意一开始用乐观锁读入时，允许其他线程获取写锁后写入，但这样会导致读的数据就可能不一致，所以需要判断读的过程中是否有写入（允许写入和是否有写入是两回事）</p><p>若有写入则再通过获取悲观读锁再次读取，使用悲观锁读取时不允许其他线程获取写锁后写入。</p></blockquote><p>可见，<code>StampedLock</code>把读锁细分为乐观读和悲观读，能进一步提升并发效率。但这也是有代价的：一是代码更加复杂，二是**<code>StampedLock</code>是不可重入锁，不能在一个线程中反复获取同一个锁**。</p><p><code>StampedLock</code>还提供了更复杂的将悲观读锁升级为写锁的功能，它主要使用在 if-then-update 的场景：即先读，如果读的数据满足条件，就返回，如果读的数据不满足条件，再尝试写。</p><h3 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a><a href="https://zhuanlan.zhihu.com/p/98593407">Semaphore</a></h3><p>前面我们讲了各种锁的实现，本质上锁的目的是保护一种受限资源，保证同一时刻只有一个线程能访问（ReentrantLock），或者只有一个线程能写入（ReadWriteLock）。</p><p>还有一种受限资源，它需要保证同一时刻最多有 N 个线程能访问，比如同一时刻最多创建100个数据库连接，最多允许10个用户下载等。</p><p>这种限制数量的锁，如果用 Lock 数组来实现，就太麻烦了，这种情况就可以使用<code>Semaphore</code>。</p><h4 id="1-Semaphore-是什么"><a href="#1-Semaphore-是什么" class="headerlink" title="1. Semaphore 是什么"></a>1. Semaphore 是什么</h4><p>Semaphore 通常我们叫它信号量， 可以用来控制同时访问特定资源的线程数量，通过协调各个线程，以保证合理的使用资源。</p><p>可以把它简单的理解成我们停车场入口立着的那个显示屏，每有一辆车进入停车场显示屏就会显示剩余车位减1，每有一辆车从停车场出去，显示屏上显示的剩余车辆就会加1，当显示屏上的剩余车位为0时，停车场入口的栏杆就不会再打开，车辆就无法进入停车场了，直到有一辆车从停车场出去为止。</p><h4 id="2-使用场景"><a href="#2-使用场景" class="headerlink" title="2. 使用场景"></a>2. 使用场景</h4><p>通常用于那些资源有明确访问数量限制的场景，常用于限流 。</p><p>比如：数据库连接池，同时进行连接的线程有数量限制，连接不能超过一定的数量，当连接达到了限制数量后，后面的线程只能排队等前面的线程释放了数据库连接才能获得数据库连接。</p><p>比如：停车场场景，车位数量有限，同时只能容纳多少台车，车位满了之后只有等里面的车离开停车场外面的车才可以进入。</p><h4 id="3-Semaphore-常用方法说明"><a href="#3-Semaphore-常用方法说明" class="headerlink" title="3. Semaphore 常用方法说明"></a>3. Semaphore 常用方法说明</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">acquire()  </span><br><span class="line">获取一个令牌，在获取到令牌、或者被其他线程调用中断之前线程一直处于阻塞状态。</span><br><span class="line"></span><br><span class="line">acquire(<span class="keyword">int</span> permits)  </span><br><span class="line">获取一个令牌，在获取到令牌、或者被其他线程调用中断、或超时之前线程一直处于阻塞状态。</span><br><span class="line">    </span><br><span class="line">acquireUninterruptibly() </span><br><span class="line">获取一个令牌，在获取到令牌之前线程一直处于阻塞状态（忽略中断）。</span><br><span class="line">    </span><br><span class="line">tryAcquire()</span><br><span class="line">尝试获得令牌，返回获取令牌成功或失败，不阻塞线程。</span><br><span class="line"></span><br><span class="line">tryAcquire(<span class="keyword">long</span> timeout, TimeUnit unit)</span><br><span class="line">尝试获得令牌，在超时时间内循环尝试获取，直到尝试获取成功或超时返回，不阻塞线程。</span><br><span class="line"></span><br><span class="line">release()</span><br><span class="line">释放一个令牌，唤醒一个获取令牌不成功的阻塞线程。</span><br><span class="line"></span><br><span class="line">hasQueuedThreads()</span><br><span class="line">等待队列里是否还存在等待线程。</span><br><span class="line"></span><br><span class="line">getQueueLength()</span><br><span class="line">获取等待队列里阻塞的线程数。</span><br><span class="line"></span><br><span class="line">drainPermits()</span><br><span class="line">清空令牌把可用令牌数置为<span class="number">0</span>，返回清空令牌的数量。</span><br><span class="line"></span><br><span class="line">availablePermits()</span><br><span class="line">返回可用的令牌数量。</span><br></pre></td></tr></table></figure><h4 id="4-用-semaphore-实现停车场提示牌功能"><a href="#4-用-semaphore-实现停车场提示牌功能" class="headerlink" title="4. 用 semaphore 实现停车场提示牌功能"></a>4. 用 semaphore 实现停车场提示牌功能</h4><p>每个停车场入口都有一个提示牌，上面显示着停车场的剩余车位还有多少，当剩余车位为0时，不允许车辆进入停车场，直到停车场里面有车离开停车场，这时提示牌上会显示新的剩余车位数。</p><p><strong>业务场景 ：</strong></p><p>1、停车场容纳总停车量10。</p><p>2、当一辆车进入停车场后，显示牌的剩余车位数响应的减1.</p><p>3、每有一辆车驶出停车场后，显示牌的剩余车位数响应的加1。</p><p>4、停车场剩余车位不足时，车辆只能在外面等待。</p><p><strong>代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestCar</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//停车场同时容纳的车辆10</span></span><br><span class="line">    <span class="keyword">private</span>  <span class="keyword">static</span>  Semaphore semaphore = <span class="keyword">new</span> Semaphore(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//模拟100辆车进入停车场</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">100</span>;i++)&#123;</span><br><span class="line">            </span><br><span class="line">            Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;====&quot;</span>+Thread.currentThread().getName()+<span class="string">&quot;来到停车场&quot;</span>);</span><br><span class="line">                        <span class="keyword">if</span>(semaphore.availablePermits()==<span class="number">0</span>)&#123;</span><br><span class="line">                            System.out.println(<span class="string">&quot;车位不足，请耐心等待&quot;</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                        semaphore.acquire();<span class="comment">//获取令牌尝试进入停车场</span></span><br><span class="line">                        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;成功进入停车场&quot;</span>);</span><br><span class="line">                        Thread.sleep(<span class="keyword">new</span> Random().nextInt(<span class="number">10000</span>));<span class="comment">//模拟车辆在停车场停留的时间</span></span><br><span class="line">                        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;驶出停车场&quot;</span>);</span><br><span class="line">                        semaphore.release();<span class="comment">//释放令牌，腾出停车场车位</span></span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,i+<span class="string">&quot;号车&quot;</span>);</span><br><span class="line"></span><br><span class="line">            thread.start();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Concurrent-集合"><a href="#Concurrent-集合" class="headerlink" title="Concurrent 集合"></a>Concurrent 集合</h3><p>我们在前面已经通过<code>ReentrantLock</code>和<code>Condition</code>实现了一个<code>BlockingQueue</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TaskQueue</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Condition condition = lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> Queue&lt;String&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addTask</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            queue.add(s);</span><br><span class="line">            condition.signalAll();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (queue.isEmpty()) &#123;</span><br><span class="line">                condition.await();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> queue.remove();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>BlockingQueue</code>的意思就是说，<strong>当一个线程调用这个<code>TaskQueue</code>的<code>getTask()</code>方法时，该方法内部可能会让线程变成等待状态，直到队列条件满足不为空，线程被唤醒后，<code>getTask()</code>方法才会返回</strong>。</p><p>因为<code>BlockingQueue</code>非常有用，所以我们不必自己编写，可以直接使用 Java 标准库的<code>java.util.concurrent</code>包提供的线程安全的集合：<code>ArrayBlockingQueue</code>。</p><p>除了<code>BlockingQueue</code>外，针对<code>List</code>、<code>Map</code>、<code>Set</code>、<code>Deque</code>等，<code>java.util.concurrent</code>包也提供了对应的并发集合类。我们归纳一下：</p><table><thead><tr><th align="left">interface</th><th align="left">non-thread-safe</th><th align="left">thread-safe</th></tr></thead><tbody><tr><td align="left">List</td><td align="left">ArrayList</td><td align="left">CopyOnWriteArrayList</td></tr><tr><td align="left">Map</td><td align="left">HashMap</td><td align="left">ConcurrentHashMap</td></tr><tr><td align="left">Set</td><td align="left">HashSet / TreeSet</td><td align="left">CopyOnWriteArraySet</td></tr><tr><td align="left">Queue</td><td align="left">ArrayDeque / LinkedList</td><td align="left">ArrayBlockingQueue / LinkedBlockingQueue</td></tr><tr><td align="left">Deque</td><td align="left">ArrayDeque / LinkedList</td><td align="left">LinkedBlockingDeque</td></tr></tbody></table><p>使用这些并发集合与使用非线程安全的集合类完全相同。我们以<code>ConcurrentHashMap</code>为例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, String&gt; map = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line"><span class="comment">// 在不同的线程读写:</span></span><br><span class="line">map.put(<span class="string">&quot;A&quot;</span>, <span class="string">&quot;1&quot;</span>);</span><br><span class="line">map.put(<span class="string">&quot;B&quot;</span>, <span class="string">&quot;2&quot;</span>);</span><br><span class="line">map.get(<span class="string">&quot;A&quot;</span>, <span class="string">&quot;1&quot;</span>);</span><br></pre></td></tr></table></figure><p>因为所有的同步和加锁的逻辑都在集合内部实现，对外部调用者来说，只需要正常按接口引用，其他代码和原来的非线程安全代码完全一样。即当我们需要多线程访问时，把：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br></pre></td></tr></table></figure><p>改为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, String&gt; map = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br></pre></td></tr></table></figure><p>就可以了。</p><p><code>java.util.Collections</code>工具类还提供了一个旧的线程安全集合转换器，可以这么用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Map unsafeMap = <span class="keyword">new</span> HashMap();</span><br><span class="line">Map threadSafeMap = Collections.synchronizedMap(unsafeMap);</span><br></pre></td></tr></table></figure><p>但是它实际上是用一个包装类包装了非线程安全的<code>Map</code>，然后对所有读写方法都用<code>synchronized</code>加锁，这样获得的线程安全集合的性能比<code>java.util.concurrent</code>集合要低很多，所以不推荐使用。</p><h3 id="Atomic"><a href="#Atomic" class="headerlink" title="Atomic"></a>Atomic</h3><h4 id="Atomic-简介"><a href="#Atomic-简介" class="headerlink" title="Atomic 简介"></a>Atomic 简介</h4><p><strong>解决并发的<a href="https://so.csdn.net/so/search?q=%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8&spm=1001.2101.3001.7020">线程安全</a>问题有两种方式：</strong></p><ol><li><strong>等待唤醒机制</strong><br>如果抢不到锁，就将线程挂起，当锁释放的时候，然后将其唤醒重新抢锁。</li><li><strong>自旋 CAS</strong><br>自旋就是设置循环 CAS 抢锁的意思，当 CAS 成功的时候才会退出循环</li></ol><table><thead><tr><th>名称</th><th>适用场景</th></tr></thead><tbody><tr><td>等待唤醒机制</td><td>当长时间都无法抢到锁的时候，还是将线程挂起，然后等待唤醒的好。因为等待和唤醒牵扯到线程挂起和切换，会导致从用户态到内核态的切换，并且线程切换会导致上下文的切换，现场保存什么的，会比较浪费资源</td></tr><tr><td>自旋 CAS</td><td>当短时间内就可以获取到锁的时候，自旋 CAS 比较合适，短时间的自旋 CAS 肯定会比线程切换消耗的资源要少，如果要是时间长的话，就不太划算了，因为自旋 CAS 会一直占用 CPU</td></tr></tbody></table><p><strong>Atomic 原子类就是利用自旋 CAS 来保证线程安全的。</strong></p><p>我们以<code>AtomicInteger</code>为例，它提供的主要操作有：</p><ul><li>增加值并返回新值：<code>int addAndGet(int delta)</code></li><li>加1后返回新值：<code>int incrementAndGet()</code></li><li>获取当前值：<code>int get()</code></li><li>用 CAS 方式设置：<code>int compareAndSet(int expect, int update)</code></li></ul><h4 id="Atomic-例子"><a href="#Atomic-例子" class="headerlink" title="Atomic 例子"></a>Atomic 例子</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestAtomic</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// lock 加锁方式</span></span><br><span class="line">    Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="keyword">int</span> id = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAgeByLock</span><span class="params">()</span></span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        id++;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Atomic 原子类方式</span></span><br><span class="line">    AtomicLong atolong = <span class="keyword">new</span> AtomicLong(<span class="number">0</span>);</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getNextId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> atolong.incrementAndGet();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h4><p>如果我们自己通过 CAS 编写<code>incrementAndGet()</code>，它大概长这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">incrementAndGet</span><span class="params">(AtomicInteger <span class="keyword">var</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> prev, next;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        prev = <span class="keyword">var</span>.get();</span><br><span class="line">        next = prev + <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">while</span> ( ! <span class="keyword">var</span>.compareAndSet(prev, next));</span><br><span class="line">    <span class="keyword">return</span> next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>CAS 是指，在这个操作中，如果<code>AtomicInteger</code>的当前值是<code>prev</code>，即<strong>内存中的值没变</strong>，那么就更新为<code>next</code>，返回<code>true</code>。如果<code>AtomicInteger</code>的当前值不是<code>prev</code>，即<strong>内存中的值变了</strong>，就什么也不干，返回<code>false</code>。通过 CAS 操作并配合<code>do ... while</code>循环，即使其他线程修改了<code>AtomicInteger</code>的值，最终的结果也是正确的。</p><p>我们利用<code>AtomicLong</code>可以编写一个多线程安全的全局唯一 ID 生成器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IdGenerator</span> </span>&#123;</span><br><span class="line">    AtomicLong <span class="keyword">var</span> = <span class="keyword">new</span> AtomicLong(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getNextId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">var</span>.incrementAndGet();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通常情况下，我们并不需要直接用<code>do ... while</code>循环调用<code>compareAndSet</code>实现复杂的并发操作，而是用<code>incrementAndGet()</code>这样的封装好的方法，因此，使用起来非常简单。</p><p>在高度竞争的情况下，还可以使用 Java 8提供的<code>LongAdder</code>和<code>LongAccumulator</code>。</p><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>使用<code>java.util.concurrent.atomic</code>提供的原子操作可以简化多线程编程：</p><ul><li>原子操作实现了无锁的线程安全；</li><li>适用于计数器，累加器等。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OGC标准</title>
      <link href="/2024/07/19/OGC%E6%A0%87%E5%87%86/"/>
      <url>/2024/07/19/OGC%E6%A0%87%E5%87%86/</url>
      
        <content type="html"><![CDATA[<h1 id="版本1"><a href="#版本1" class="headerlink" title="版本1"></a>版本1</h1><p><img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/20240719153741.png" alt="image.png|869"></p><h3 id="WMS-服务"><a href="#WMS-服务" class="headerlink" title="WMS 服务"></a>WMS 服务</h3><p>WMS 服务全称是 Web Map Service （web 地图服务），目前 OGC 提供的 WMS 最新版本为1.3.0，并提供了如下的操作接口：</p><ul><li>GetCapabilities：获取服务中的要素及支持的操作<br>  请求格式支持 KVP 和 SOAP，其主要参数如下：<br>  <img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/20240719153857.png" alt="image.png"></li><li>GetMap：获取地图数据<br>  请求格式支持 KVP 和 SOAP，其主要参数如下：<br>  <img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/20240719153917.png" alt="image.png"></li><li>GetFeatureInfo：获取 getMap 响应地图上某一点的特征数据信息<br>  请求格式支持 KVP 和 SOAP，其主要参数如下：<br>  <img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/QQ_1721374774440.png" alt="QQ_1721374774440.png"><h3 id="WFS-服务"><a href="#WFS-服务" class="headerlink" title="WFS 服务"></a>WFS 服务</h3>WFS 服务，全称是 Web Feature Service (web 要素服务)，目前 OGC 提供的 WFS 最新版本为2.0.2，并且提供如下几种操作：</li><li>GetCapabilities： 获取服务中的要素及支持的操作<br>  请求格式支持 KVP 和 SOAP，其请求参数如下：<br>  <img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/QQ_1721374851406.png" alt="QQ_1721374851406.png"></li><li>DescribeFeatureType： 获取地理要素类型的 GML 应用模式描述文档<br>  请求格式支持 KVP 和 SOAP，其请求参数如下：<br>  <img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/QQ_1721374908935.png" alt="QQ_1721374908935.png"></li><li>GetFeature： 根据条件查询地理要素信息<br>  请求格式支持 KVP 和 SOAP，其请求参数如下：<br>  <img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/20240719154239.png"></li></ul><h3 id="WCS-服务"><a href="#WCS-服务" class="headerlink" title="WCS 服务"></a>WCS 服务</h3><p>WCS 服务，全称为 Web Coverage Service（web 栅格服务），目前 OGC 提供的 WCS 的最新版本为2.1，并提供了如下几种操作：</p><ul><li>Getcapabilities: 获取服务中的要素及支持的操作<br>  请求格式支持 KVP 和 SOAP，其请求参数如下：<br>  <img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/20240719154320.png" alt="image.png"></li><li>DescribeCoverage: 返回标识覆盖范围的文档描述<br>  请求格式支持 KVP 和 SOAP，其请求参数如下：<br>  <img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/20240719154341.png" alt="image.png"></li><li>GetCoverage: 获取服务器上元数据与请求数据的覆盖数据<br>  请求格式支持 KVP 和 SOAP，其请求参数如下：<br>  <img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/20240719154402.png" alt="image.png"></li></ul><h3 id="WMTS-服务"><a href="#WMTS-服务" class="headerlink" title="WMTS 服务"></a>WMTS 服务</h3><p>WMTS 服务，全称是 Web Map Tile Service (web 地图切片服务)，目前 OGC 提供的最新版本是1.0.0，WMTS 是 OGC 首个支持 restful 风格的服务标准，提供了如下几种操作：</p><ul><li>GetCapabilities：获取服务的<a href="https://so.csdn.net/so/search?q=%E5%85%83%E6%95%B0%E6%8D%AE&spm=1001.2101.3001.7020">元数据</a>信息<br>  请求格式支持 KVP，SOAP 和 RESTFUL，其请求参数如下：<br>  <img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/20240719154421.png" alt="image.png"></li><li>GetTile：获取服务的切片信息<br>  请求格式支持 KVP，SOAP 和 RESTFUL，其请求参数如下：<br>  <img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/QQ_1721375085831.png" alt="QQ_1721375085831.png"></li><li>GetFeatureInfo：获取点选的要素信息<br>  请求格式支持 KVP，SOAP 和 RESTFUL，其请求参数如下：<br>  <img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/20240719154506.png" alt="image.png"></li></ul><h1 id="版本2"><a href="#版本2" class="headerlink" title="版本2"></a>版本2</h1><h2 id="一、什么是-OGC？"><a href="#一、什么是-OGC？" class="headerlink" title="一、什么是 OGC？"></a>一、什么是 OGC？</h2><p><a href="http://www.opengeospatial.org/">OGC</a>，全称是开放<strong>地理空间信息联盟</strong>(Open Geospatial Consortium)，是一个非盈利的国际标准组织，它制定了数据和服务的一系列标准，GIS厂商按照这个标准进行开发可保证<strong>空间数据</strong>的互操作。（来源<a href="https://baike.baidu.com/item/OGC/6466060">百度百科</a>）</p><h2 id="二、OGC-定义了些什么东西？"><a href="#二、OGC-定义了些什么东西？" class="headerlink" title="二、OGC 定义了些什么东西？"></a>二、OGC 定义了些什么东西？</h2><p>OGC 基于 http 或者说是 web 的空间数据操作技术，主要涉及 Web Service 的相关技术。与 ISO/TC211一同推出</p><ul><li>基于 Web 服务（XML）的空间数据互操作实现规范（<strong>本文主要阐述</strong>）</li><li>用于空间数据传输与转换的地理信息标记语言 GML</li><li>提出了一个能无缝集成各种在线空间处理和位置服务的框架即 OWS (OGC Web Service)</li></ul><blockquote><p><strong>意义</strong>：使得分布式空间处理系统能够通过 XML 和 HTTP 技术进行交互，并为各种在线空间数据资源、来自传感器的信息、空间处理服务和位置服务，基于 Web 的发现、访问、集成、分析、利用和可视化提供互操作框架。</p></blockquote><h2 id="三、基于-Web-服务（XML）的空间数据互操作实现规范"><a href="#三、基于-Web-服务（XML）的空间数据互操作实现规范" class="headerlink" title="三、基于 Web 服务（XML）的空间数据互操作实现规范"></a>三、基于 Web 服务（XML）的空间数据互操作实现规范</h2><p><img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/20240719153741.png" alt="image.png|869"></p><h3 id="3-1-WMS"><a href="#3-1-WMS" class="headerlink" title="3.1 WMS"></a>3.1 WMS</h3><h4 id="3-1-1-定义"><a href="#3-1-1-定义" class="headerlink" title="3.1.1 定义"></a>3.1.1 定义</h4><ul><li>Web 地图服务（WMS）利用具有地理空间位置信息的数据制作地图</li><li>一个 WMS 可以动态地生成具有地理参考数据的地图</li><li>这些地图通常用 GIF、JPEG 或 PNG 等图像格式，或者 SVG、KML、VML 和 WebCGM 等矢量图形格式来表现。</li><li>使用者通过指定的参数获取相应的地图图片。<h4 id="3-1-2-接口"><a href="#3-1-2-接口" class="headerlink" title="3.1.2 接口"></a>3.1.2 接口</h4></li></ul><table><thead><tr><th align="left">接口名称</th><th align="left">接口说明</th></tr></thead><tbody><tr><td align="left">GetCapabilities</td><td align="left">返回服务级元数据，它是对服务信息内容和要求参数的一种描述</td></tr><tr><td align="left">GetMap</td><td align="left">获取地图图片。该操作根据客户端发出的请求参数在服务端进行检索，服务器端返回一个地图图像，其地理空间参数和大小参数是已经明确定义的，返回的地图图像可以是 GIF、JPEG、PNG 或 SVG 格式。</td></tr><tr><td align="left">GetFeatureinfo</td><td align="left">返回显示在地图上的某些特殊要素的信息。该操作根据用户所请求的 X、Y 坐标或感兴趣的图层，返回地图上某些特殊要素的信息，信息以 HTML，GML 或 ASCII 的格式表示。</td></tr></tbody></table><h5 id="3-1-2-1-GetCapabilities-操作请求方法实现参数"><a href="#3-1-2-1-GetCapabilities-操作请求方法实现参数" class="headerlink" title="3.1.2.1 GetCapabilities 操作请求方法实现参数"></a>3.1.2.1 GetCapabilities 操作请求方法实现参数</h5><table><thead><tr><th>参数名称</th><th>参数个数</th><th>参数类型和值</th></tr></thead><tbody><tr><td>service</td><td>1个(必选)</td><td>字符类型，服务类型值为“WMS”</td></tr><tr><td>request</td><td>1个(必选)</td><td>字符类型，请求的操作名称，值为“GetCapabilities”</td></tr><tr><td>version</td><td>0或1个(可选)</td><td>字符类型，值为请求的 WMS 的版本号</td></tr><tr><td>format</td><td>0或1个(可选)</td><td>MIME 类型，值为服务元数据的输出格式</td></tr><tr><td>updateSequence</td><td>0或1个(可选)</td><td>字符类型，可取的值有 none、any、equal、lower、higher，用来表示缓存数据更新的方式</td></tr></tbody></table><h5 id="3-1-2-2-GetMap-操作请求方法实现参数"><a href="#3-1-2-2-GetMap-操作请求方法实现参数" class="headerlink" title="3.1.2.2 GetMap 操作请求方法实现参数"></a>3.1.2.2 GetMap 操作请求方法实现参数</h5><table><thead><tr><th>参数名称</th><th>参数个数</th><th>参数类型和值</th></tr></thead><tbody><tr><td>service</td><td>1个(必选)</td><td>字符类型，服务类型标识值为“WMS”</td></tr><tr><td>request</td><td>1个(必选)</td><td>字符类型，值为“GetMap”</td></tr><tr><td>version</td><td>1个(必选)</td><td>字符类型，值为请求的 WMS 的版本号</td></tr><tr><td>layers</td><td>1个(必选)</td><td>字符类型，值为一个或多个地图图层列表，多个图层之间用”,”隔开</td></tr><tr><td>styles</td><td>1个(必选)</td><td>字符类型，值为请求图层的地图渲染样式</td></tr><tr><td>CRS</td><td>1个(必选)</td><td>字符类型，值为坐标参照系统</td></tr><tr><td>BBOX</td><td>1个(必选)</td><td>Wkt 格式，值为某个 CRS 下的地图边界范围的坐标序列</td></tr><tr><td>width</td><td>1个(必选)</td><td>整型类型，值为地图图片的像素宽度</td></tr><tr><td>height</td><td>1个(必选)</td><td>整型类型，值为地图图片的像素高度</td></tr><tr><td>format</td><td>1个(必选)</td><td>字符类型，值为地图的输出格式</td></tr><tr><td>transparent</td><td>0或1个(可选)</td><td>字符类型，值为 true 或者 false，用来表示地图图层是否透明(默认情况下是不透明的)</td></tr><tr><td>bgcolor</td><td>0或1个(可选)</td><td>值为十六进制的 RGB 值，表示地图的背景颜色</td></tr><tr><td>exceptions</td><td>0或1个(可选)</td><td>值为 WMS 的异常信息报告的格式(默认情况下是 XML 格式)</td></tr><tr><td>time</td><td>0或1个(可选)</td><td>时间类型，值为时间值，表示需要在图层中有时间信息</td></tr><tr><td>elevation</td><td>0或1个(可选)</td><td>数字类型，值为高程值，表示需要在图层中有高程信息</td></tr></tbody></table><h5 id="3-1-2-3-GetFeatureInfo-操作请求方法实现参数"><a href="#3-1-2-3-GetFeatureInfo-操作请求方法实现参数" class="headerlink" title="3.1.2.3 GetFeatureInfo 操作请求方法实现参数"></a>3.1.2.3 GetFeatureInfo 操作请求方法实现参数</h5><table><thead><tr><th>参数名称</th><th>参数个数</th><th>参数类型和值</th></tr></thead><tbody><tr><td>service</td><td>1个(必选)</td><td>字符类型，服务类型标识值为“WMS”</td></tr><tr><td>request</td><td>1个(必选)</td><td>字符类型，值为“GetFeatureInfo”</td></tr><tr><td>version</td><td>1个(必选)</td><td>字符类型，值为请求的 WMS 的版本号</td></tr><tr><td>map request part</td><td>1个(必选)</td><td>字符类型，值为获得地图的部分操作参数</td></tr><tr><td>query_layers</td><td>1个(必选)</td><td>字符类型，值为查询的一个或多个地图图层列表，多个图层之间用”,”隔开</td></tr><tr><td>info_format</td><td>1个(必选)</td><td>MIME 类型，值为请求信息的返回类型</td></tr><tr><td>I</td><td>1个(必选)</td><td>整型类型，值为待查询点的在地图图片上的像素列号</td></tr><tr><td>J</td><td>1个(必选)</td><td>整型类型，值为待查询点的在地图图片上的像素行号</td></tr><tr><td>feature_count</td><td>0或1个(可选)</td><td>整型类型，值为返回信息中的要素的个数(默认是1)</td></tr><tr><td>exceptions</td><td>0或1个(可选)</td><td>值为 WMS 的异常信息报告的格式(默认情况下是 XML 格式)</td></tr></tbody></table><h3 id="3-2WFS"><a href="#3-2WFS" class="headerlink" title="3.2WFS"></a>3.2WFS</h3><h4 id="3-2-1-定义"><a href="#3-2-1-定义" class="headerlink" title="3.2.1 定义"></a>3.2.1 定义</h4><ul><li>Web 要素服务（WFS）返回的是要素级的 GML 编码，并提供对要素的增加、修改、删除等事务操作，是对 Web 地图服务的进一步深入</li><li>回结果的是 XML 格式的 WFS 服务元数据文档<h4 id="3-2-2-接口"><a href="#3-2-2-接口" class="headerlink" title="3.2.2 接口"></a>3.2.2 接口</h4></li></ul><table><thead><tr><th>接口名称</th><th>接口说明</th></tr></thead><tbody><tr><td>GetCapabilities</td><td>GetCapabilities 请求用于查询 WFS 服务的能力信息，包括支持的操作、支持的格式、空间坐标、包含的资源等。它主要的目的是使客户端在使用 GetFeature 请求前可以对 WFS 服务有一个基本的了解，从而可以设置正确的参数。</td></tr><tr><td>DescribeFeatureType</td><td>返回描述可以提供服务的任何要素结构的 XML 文档，即图层描述信息</td></tr><tr><td>GetFeature</td><td>为一个获取要素实例的请求提供服务，通过 GetFeature 操作可以由指定的属性条件、空间条件或者两者叠加的条件进行空间查询。</td></tr><tr><td>Transaction</td><td>为事务请求提供服务，使客户端可对服务器端所提供的地图要素类执插入，更新，删除等命令</td></tr><tr><td>GetGmlObject</td><td>通过 XLink 获取 GML 对象</td></tr><tr><td>LockFeature</td><td>处理在一个事务期间对一个或多个要素类型实例上锁的请求</td></tr></tbody></table><h5 id="3-2-2-1-GetCapabilities-操作请求方法实现参数"><a href="#3-2-2-1-GetCapabilities-操作请求方法实现参数" class="headerlink" title="3.2.2.1 GetCapabilities 操作请求方法实现参数"></a>3.2.2.1 GetCapabilities 操作请求方法实现参数</h5><table><thead><tr><th>参数名称</th><th>参数个数</th><th>参数类型和值</th></tr></thead><tbody><tr><td>service</td><td>1个(必选)</td><td>字符类型，服务类型值为“WFS”</td></tr><tr><td>request</td><td>1个(必选)</td><td>字符类型，请求的操作名称，值为“GetCapabilities”</td></tr><tr><td>versions</td><td>0或1个(可选)</td><td>字符类型，值为请求的 WFS 的版本号</td></tr></tbody></table><h5 id="3-2-2-2-DescribeFeatureType-操作请求方法实现参数"><a href="#3-2-2-2-DescribeFeatureType-操作请求方法实现参数" class="headerlink" title="3.2.2.2 DescribeFeatureType 操作请求方法实现参数"></a>3.2.2.2 DescribeFeatureType 操作请求方法实现参数</h5><table><thead><tr><th>参数名称</th><th>参数个数</th><th>参数类型和值</th></tr></thead><tbody><tr><td>service</td><td>1个(必选)</td><td>字符类型，服务类型值为“WFS”</td></tr><tr><td>request</td><td>1个(必选)</td><td>字符类型，请求的操作名称，值为“DescribeFeatureType”</td></tr><tr><td>typeName</td><td>0或1个(可选)</td><td>字符类型，值为要素类型的列表，多个值之间用“，”隔开，默认解析包括的全部要素类型</td></tr><tr><td>outputFormat</td><td>0或1个(可选)</td><td>MIME 类型，值为输出格式</td></tr></tbody></table><h5 id="3-2-2-3-GetFeature-操作请求方法实现参数"><a href="#3-2-2-3-GetFeature-操作请求方法实现参数" class="headerlink" title="3.2.2.3 GetFeature 操作请求方法实现参数"></a>3.2.2.3 GetFeature 操作请求方法实现参数</h5><table><thead><tr><th>参数名称</th><th>参数个数</th><th>参数类型和值</th></tr></thead><tbody><tr><td>service</td><td>1个(必选)</td><td>字符类型，服务类型标识值为“WFS”</td></tr><tr><td>request</td><td>1个(必选)</td><td>字符类型，请求的操作值为“GetFeature”</td></tr><tr><td>typeName</td><td>1个(必选)</td><td>字符类型，值为请求的要素类型的名称，多个名称之间用“，”隔开</td></tr><tr><td>version</td><td>0或1个(可选)</td><td>字符类型，值为请求的 WFS 的版本号</td></tr><tr><td>outputFormat</td><td>0或1个(可选)</td><td>MIME 类型，值为输出格式</td></tr><tr><td>resultType</td><td>0或1个(可选)</td><td>字符类型，值为请求的结果类型</td></tr><tr><td>propertyName</td><td>0或1个(可选)</td><td>字符类型，值为请求要素的属性名，多个值之间用“，”隔开</td></tr><tr><td>featureVersion</td><td>0或1个(可选)</td><td>字符类型，值为要素的版本，值为 ALL 返回请求的要素的所有版本，没有值默认为返回请求要素的最新版本</td></tr><tr><td>maxFeature</td><td>0或1个(可选)</td><td>整型类型，值为请求要素的最大数，默认值为满足查询的所有结果集</td></tr><tr><td>expiry</td><td>0或1个(可选)</td><td>数字类型，要素被锁定的时间</td></tr><tr><td>SRSName</td><td>0或1个(可选)</td><td>字符类型，值为坐标系统名</td></tr><tr><td>featureID</td><td>0或1个(可选)</td><td>字符类型，值为要素的 ID，多个 ID 之间用“，”隔开</td></tr><tr><td>filter</td><td>0或1个(可选)</td><td>请求要素的过滤条件</td></tr><tr><td>bBox</td><td>0或1个(可选)</td><td>Wkt 格式，请求指定要素查询范围，可以替代 featureId 和 filter 参数</td></tr><tr><td>sortby</td><td>0或1个(可选)</td><td>字符类型，查询结果属性值的排序依据</td></tr></tbody></table><h3 id="3-3WCS"><a href="#3-3WCS" class="headerlink" title="3.3WCS"></a>3.3WCS</h3><h4 id="3-3-1-定义"><a href="#3-3-1-定义" class="headerlink" title="3.3.1 定义"></a>3.3.1 定义</h4><ul><li>Web 栅格服务面向空间影像数据</li><li>将包含地理位置值的地理空间数据作为“栅格（Coverage）”在网上相互交换</li><li>允许用户访问“Coverage”数据，如卫星影像、数字高程数据等，也就是栅格数据<h4 id="3-3-2-接口"><a href="#3-3-2-接口" class="headerlink" title="3.3.2 接口"></a>3.3.2 接口</h4></li></ul><table><thead><tr><th>接口名称</th><th>接口说明</th></tr></thead><tbody><tr><td>GetCapabilities</td><td>返回描述服务和数据集的 XML 文档</td></tr><tr><td>DescribeCoverage</td><td>在 GetCapabilities 确定什么样的查询可以执行、什么样的数据能够获取之后执行的，它使用通用的栅格格式返回地理位置的值或属性</td></tr><tr><td>GetCoverage</td><td>允许客户端请求由具体的 WCS 服务器提供的任一覆盖层的完全描述</td></tr></tbody></table><h5 id="3-3-2-1-GetCapabilities-操作请求方法实现参数"><a href="#3-3-2-1-GetCapabilities-操作请求方法实现参数" class="headerlink" title="3.3.2.1 GetCapabilities 操作请求方法实现参数"></a>3.3.2.1 GetCapabilities 操作请求方法实现参数</h5><table><thead><tr><th>参数名称</th><th>参数个数</th><th>参数类型和值</th></tr></thead><tbody><tr><td>SERVICE</td><td>1个（必选）</td><td>字符类型，服务类型为“WCS”</td></tr><tr><td>REQUEST</td><td>1个（必选）</td><td>字符类型，请求的操作名称，值为“GetCapabilities”</td></tr><tr><td>ACCEPTVERSIONS</td><td>0或1个（可选）</td><td>字符类型，值为请求的 WMTS 的版本号</td></tr><tr><td>SECTIONS</td><td>0或1个（可选）</td><td>字符类型，请求元数据文档0或多个节的名称，多个名称之间用“，”隔开，不须按顺序排列。值为空默认返回整个元数据文档</td></tr><tr><td>UPDATESEQUENCE</td><td>0或1个（可选）</td><td>字符类型，值为 increased，为空时默认返回最新的元数据文档</td></tr><tr><td>ACCEPTFORMATS</td><td>0或1个（可选）</td><td>字符类型，接受的格式</td></tr></tbody></table><h5 id="3-3-2-2-DescribeCoverage-操作请求方法实现参数"><a href="#3-3-2-2-DescribeCoverage-操作请求方法实现参数" class="headerlink" title="3.3.2.2 DescribeCoverage 操作请求方法实现参数"></a>3.3.2.2 DescribeCoverage 操作请求方法实现参数</h5><table><thead><tr><th>参数名称</th><th>参数个数</th><th>参数类型和值</th></tr></thead><tbody><tr><td>VERSION</td><td>1个（必选）</td><td>字符类型，值为请求的 WCS 的版本号</td></tr><tr><td>SERVICE</td><td>1个（必选）</td><td>字符类型，服务类型为“WCS”</td></tr><tr><td>REQUEST</td><td>1个（必选）</td><td>字符类型，请求的操作名称，值为“DescribeCoverage”</td></tr><tr><td>IDENTIFIERS</td><td>1个（必选）</td><td>字符类型，标识符</td></tr></tbody></table><h5 id="3-3-2-3-GetCoverage-操作请求方法实现参数"><a href="#3-3-2-3-GetCoverage-操作请求方法实现参数" class="headerlink" title="3.3.2.3 GetCoverage 操作请求方法实现参数"></a>3.3.2.3 GetCoverage 操作请求方法实现参数</h5><table><thead><tr><th>参数名称</th><th>参数个数</th><th>参数类型和值</th></tr></thead><tbody><tr><td>VERSION</td><td>1个（必选）</td><td>字符类型，值为请求的 WCS 的版本号</td></tr><tr><td>SERVICE</td><td>1个（必选）</td><td>字符类型，服务类型为“WCS”</td></tr><tr><td>REQUEST</td><td>1个（必选）</td><td>字符类型，请求的操作名称，值为“GetCoverage”</td></tr><tr><td>coverage</td><td>1个（必选）</td><td>字符类型，请求的图层名称</td></tr><tr><td>BBOX</td><td>1个（必选）</td><td>字符类型，请求的图层显示范围</td></tr><tr><td>CRS</td><td>1个（必选）</td><td>字符类型，请求的坐标系代码</td></tr><tr><td>FORMAT</td><td>1个（必选）</td><td>字符类型，请求图片格式</td></tr></tbody></table><h3 id="3-4WMTS"><a href="#3-4WMTS" class="headerlink" title="3.4WMTS"></a>3.4WMTS</h3><h4 id="3-4-1-定义"><a href="#3-4-1-定义" class="headerlink" title="3.4.1 定义"></a>3.4.1 定义</h4><ul><li>和 WMS 并列的重要 OGC 规范之一</li><li>采用缓存技术能够缓解 WebGIS 服务器端数据处理的压力，提高交互响应速度</li><li>目前各种缓存技术相互兼容的一种方法<h4 id="3-4-2-接口"><a href="#3-4-2-接口" class="headerlink" title="3.4.2 接口"></a>3.4.2 接口</h4></li></ul><table><thead><tr><th>接口名称</th><th>接口描述</th></tr></thead><tbody><tr><td>GetCapabilities</td><td>获取 WMTS 的能力文档（即元数据文档），里面包含服务的所有信息</td></tr><tr><td>GetTile</td><td>获取地图瓦片。该操作根据客户端发出的请求参数在服务端进行检索，服务器端返回地图瓦片图像。</td></tr><tr><td>GetFeatureInfo</td><td>通过在 WMTS 图层上指定一定的条件，返回指定的地图瓦片内容对应的要素信息</td></tr></tbody></table><h5 id="3-4-2-1-GetCapabilities-操作请求方法实现参数"><a href="#3-4-2-1-GetCapabilities-操作请求方法实现参数" class="headerlink" title="3.4.2.1 GetCapabilities 操作请求方法实现参数"></a>3.4.2.1 GetCapabilities 操作请求方法实现参数</h5><table><thead><tr><th>参数名称</th><th>参数个数</th><th>参数类型和值</th></tr></thead><tbody><tr><td>service</td><td>1个(必选)</td><td>字符类型，服务类型值为“WMTS”</td></tr><tr><td>request</td><td>1个(必选)</td><td>字符类型，请求的操作名称，值为“GetCapabilities”</td></tr><tr><td>acceptVersions</td><td>0或1个(可选)</td><td>字符类型，值为请求的 WMTS 的版本号</td></tr><tr><td>sections</td><td>0或1个(可选)</td><td>字符类型，请求元数据文档0或多个节的名称，多个名称之间用“，”隔开，不须按顺序排列。值为空默认返回整个元数据文档</td></tr><tr><td>updateSequence</td><td>0或1个(可选)</td><td>字符类型，值为 increased，为空时默认返回最新的元数据文档</td></tr><tr><td>acceptFormat</td><td>0或1个(可选)</td><td>MIME 类型，值为服务元数据的输出格式</td></tr></tbody></table><h5 id="3-4-2-2-GetTile-操作请求方法实现参数"><a href="#3-4-2-2-GetTile-操作请求方法实现参数" class="headerlink" title="3.4.2.2 GetTile 操作请求方法实现参数"></a>3.4.2.2 GetTile 操作请求方法实现参数</h5><table><thead><tr><th>参数名称</th><th>参数个数</th><th>参数类型和值</th></tr></thead><tbody><tr><td>service</td><td>1个(必选)</td><td>字符类型，服务类型标识值为“WMTS”</td></tr><tr><td>request</td><td>1个(必选)</td><td>字符类型，请求的操作值为“GetTile”</td></tr><tr><td>version</td><td>1个(必选)</td><td>字符类型，值为请求的 WMTS 的版本号</td></tr><tr><td>layer</td><td>1个(必选)</td><td>字符类型，值为请求的图层名称</td></tr><tr><td>style</td><td>1个(必选)</td><td>字符类型，值为请求图层的渲染样式</td></tr><tr><td>format</td><td>1个(必选)</td><td>字符类型，值为瓦片地图的输出格式</td></tr><tr><td>tileMatrixSet</td><td>1个(必选)</td><td>字符类型，瓦片矩阵数据集，其值在服务的元数据文档中指定</td></tr><tr><td>tileMatrix</td><td>1个(必选)</td><td>字符类型，瓦片矩阵，其值在服务的元数据文档中指定</td></tr><tr><td>tileRow</td><td>1个(必选)</td><td>整型类型，值为大于0的整数，表示瓦片矩阵的行号</td></tr><tr><td>tileCol</td><td>1个(必选)</td><td>整型类型，值为大于0的整数，表示瓦片矩阵的列号</td></tr><tr><td>Other sample dimensions</td><td>0或1个(可选)</td><td>字符类型，其他允许的参数</td></tr></tbody></table><h5 id="3-4-2-3-GetFeatureInfo-操作请求方法实现参数"><a href="#3-4-2-3-GetFeatureInfo-操作请求方法实现参数" class="headerlink" title="3.4.2.3 GetFeatureInfo 操作请求方法实现参数"></a>3.4.2.3 GetFeatureInfo 操作请求方法实现参数</h5><table><thead><tr><th>service</th><th>1个(必选)</th><th>字符类型，服务类型值为“WMTS”</th></tr></thead><tbody><tr><td>request</td><td>1个(必选)</td><td>字符类型，请求的操作值为“GetFeatureInfo”</td></tr><tr><td>version</td><td>1个(必选)</td><td>字符类型，值为请求的 WMTS 的版本号</td></tr><tr><td>J</td><td>1个(必选)</td><td>整型类型，值为大于0的整数，表示瓦片上一指定像素点的行号</td></tr><tr><td>I</td><td>1个(必选)</td><td>整型类型，值为大于0的整数，表示瓦片上一指定像素点的列号</td></tr><tr><td>info_format</td><td>1个(必选)</td><td>MIME 类型，值为请求信息的返回类型</td></tr><tr><td>layer, style, format, Sample dimension, tileMatrixSet, tileMatrix, tileRow, tileCol</td><td>1个(必选)</td><td>这些参数的值应与请求 GetTile 的相应参数保持一致</td></tr></tbody></table>]]></content>
      
      
      
        <tags>
            
            <tag> GIS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>geoserver_learn</title>
      <link href="/2024/07/19/geoserver_learn/"/>
      <url>/2024/07/19/geoserver_learn/</url>
      
        <content type="html"><![CDATA[<p>TARGET DECK: Temp</p><h2 id="geoserver-实现跨域"><a href="#geoserver-实现跨域" class="headerlink" title="geoserver 实现跨域"></a>geoserver 实现跨域</h2><p>在 tomcat 服务部署文件中 找到 Geoserver 服务安装目录下 WEB-INF 文件夹的 web.xml 文件（D:…\apache-tomcat-9.0.41\webapps\geoserver\WEB-INF\web.xml）<br>找到下面两段被注释代码，并解除注释</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- Uncomment following filter to enable CORS <span class="keyword">in</span> Tomcat. Do not forget the second config block further down.</span><br><span class="line">    &lt;filter&gt;</span><br><span class="line">      <span class="xml"><span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>cross-origin<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span></span><br><span class="line">      <span class="xml"><span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>org.apache.catalina.filters.CorsFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span></span><br><span class="line">      <span class="xml"><span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>cors.allowed.origins<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>*<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span></span><br><span class="line">      <span class="xml"><span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>cors.allowed.methods<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>GET,POST,PUT,DELETE,HEAD,OPTIONS<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span></span><br><span class="line">      <span class="xml"><span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>cors.allowed.headers<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>*<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span></span><br><span class="line">    &lt;/filter&gt;</span><br><span class="line">--&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;!-- Uncomment following filter to enable CORS </span><br><span class="line">    &lt;filter-mapping&gt;</span><br><span class="line">        <span class="xml"><span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>cross-origin<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span></span><br><span class="line">        <span class="xml"><span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span></span><br><span class="line">    &lt;/filter-mapping&gt;</span><br><span class="line">--&gt;</span><br></pre></td></tr></table></figure><p><strong>注意：</strong>上面的第一段代码实现 <code>在tomcat服务器上，允许GeoServer跨域访问的</code>。在该web.xml文件中，同样注释了 <code>Jett服务器上，允许GeoServer跨域访问</code> 的代码，经测试，只能取消相应服务器的 <code>允许跨域访问</code> 注释，不然会出现不能运行 GeoServer 服务的问题<br>上述方法是修改 GeoServer 的配置实现跨域，也可以通过修改 tomcat 服务实现允许访问，方法如下：</p><ol><li>下载 cors-filter.jar 和 java-property-utils.jar，地址如下<br> <a href="https://mvnrepository.com/artifact/com.thetransactioncompany/cors-filter/2.9.1">https://mvnrepository.com/artifact/com.thetransactioncompany/cors-filter/2.9.1</a><br> <a href="https://mvnrepository.com/artifact/com.thetransactioncompany/java-property-utils/1.16">https://mvnrepository.com/artifact/com.thetransactioncompany/java-property-utils/1.16</a></li><li> 将下载的两个 jar 包 拷贝至 tomcat 的安装路径下 lib 文件夹中，如：D:…\apache-tomcat-9.0.41\lib</li></ol><p>最后，重启 tomcat，解决问题</p><h2 id="geoserver-使用QGIS-保存的图层样式"><a href="#geoserver-使用QGIS-保存的图层样式" class="headerlink" title="geoserver 使用QGIS 保存的图层样式"></a>geoserver 使用QGIS 保存的图层样式</h2><p>导出矢量图层样式<br>右击图层，选择属性按钮<br><img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/QQ_1721370014161.png" alt="QQ_1721370014161.png|634"></p><p>使用 SLD4raster 导出栅格数据样式<br><img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/QQ_1721371478756.png" alt="QQ_1721371478756.png|624"><br><img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/QQ_1721371610113.png" alt="QQ_1721371610113.png"></p>]]></content>
      
      
      
        <tags>
            
            <tag> None </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>openLayer学习</title>
      <link href="/2024/07/18/openLayer%E5%AD%A6%E4%B9%A0/"/>
      <url>/2024/07/18/openLayer%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<p>TARGET DECK: Temp</p><h2 id="读取"><a href="#读取" class="headerlink" title="读取"></a>读取</h2><h3 id="读取-shp-文件"><a href="#读取-shp-文件" class="headerlink" title="读取 shp 文件"></a>读取 shp 文件</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm i shpjs</span><br><span class="line"><span class="keyword">import</span> shp <span class="keyword">from</span> <span class="string">&#x27;shpjs&#x27;</span>; <span class="comment">// shp转geoJson</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 上传shp(压缩包)  利用shpjs转为geojson</span></span><br><span class="line"><span class="keyword">const</span> handlePreview: UploadProps[<span class="string">&#x27;onPreview&#x27;</span>] = <span class="function">(<span class="params">uploadFile</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> name = uploadFile.name;</span><br><span class="line">  <span class="keyword">const</span> extension = name.split(<span class="string">&#x27;.&#x27;</span>)[<span class="number">1</span>];</span><br><span class="line">  <span class="keyword">if</span> (extension != <span class="string">&#x27;zip&#x27;</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(extension);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> reader = <span class="keyword">new</span> FileReader();</span><br><span class="line">    <span class="keyword">if</span> (uploadFile.raw) &#123;</span><br><span class="line">      <span class="keyword">const</span> fileData = uploadFile.raw;</span><br><span class="line">      reader.readAsArrayBuffer(fileData);</span><br><span class="line">      reader.onload = <span class="keyword">async</span> (e) =&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (e.target) &#123;</span><br><span class="line">          <span class="keyword">const</span> shpData = e.target.result;</span><br><span class="line">          <span class="keyword">const</span> geojson = <span class="keyword">await</span> shp(shpData); <span class="comment">// shp转geojson</span></span><br><span class="line">          <span class="keyword">const</span> inputShpLayer = <span class="keyword">new</span> VectorLayer(&#123;</span><br><span class="line">            <span class="attr">source</span>: <span class="keyword">new</span> VectorSource(&#123;</span><br><span class="line">              <span class="attr">features</span>: <span class="keyword">new</span> GeoJSON().readFeatures(geojson),</span><br><span class="line">              <span class="attr">format</span>: <span class="keyword">new</span> GeoJSON(),</span><br><span class="line">            &#125;),</span><br><span class="line">          &#125;);</span><br><span class="line">          map.value?.addLayer(inputShpLayer);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="加载底图"><a href="#加载底图" class="headerlink" title="加载底图"></a>加载底图</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 加载天地图</span></span><br><span class="line"> <span class="keyword">const</span> tileLayer = <span class="keyword">new</span> TileLayer(&#123;</span><br><span class="line">   <span class="attr">visible</span>: <span class="literal">true</span>,</span><br><span class="line">   <span class="attr">source</span>: <span class="keyword">new</span> XYZ(&#123; <span class="attr">url</span>: <span class="string">&#x27;http://wprd0&#123;1-4&#125;.is.autonavi.com/appmaptile?lang=zh_cn&amp;size=1&amp;style=7&amp;x=&#123;x&#125;&amp;y=&#123;y&#125;&amp;z=&#123;z&#125;&#x27;</span> &#125;),</span><br><span class="line"> &#125;);</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 加载WMS服务</span></span><br><span class="line"> <span class="keyword">const</span> imageLayer = <span class="keyword">new</span> ImageLayer(&#123;</span><br><span class="line">   <span class="attr">source</span>: <span class="keyword">new</span> ImageWMS(&#123;</span><br><span class="line">     <span class="attr">url</span>: <span class="string">&#x27;http://localhost:8080/geoserver/postgis/wms&#x27;</span>,</span><br><span class="line">     <span class="attr">params</span>: &#123; <span class="attr">layers</span>: <span class="string">&#x27;postgis:D4DTQYC&#x27;</span> &#125;,</span><br><span class="line">   &#125;),</span><br><span class="line"> &#125;);</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 加载WFS服务</span></span><br><span class="line"> <span class="keyword">const</span> FeatureLayer = <span class="keyword">new</span> VectorLayer(&#123;</span><br><span class="line">   <span class="attr">source</span>: <span class="keyword">new</span> VectorSource(&#123;</span><br><span class="line">     <span class="attr">url</span>: <span class="string">&#x27;http://localhost:8080/geoserver/postgis/ows?service=WFS&amp;version=1.0.0&amp;request=GetFeature&amp;typeName=postgis%3AD4DTQYC&amp;maxFeatures=50&amp;outputFormat=application%2Fjson&#x27;</span>,</span><br><span class="line">     <span class="attr">format</span>: <span class="keyword">new</span> GeoJSON(),</span><br><span class="line">   &#125;),</span><br><span class="line">   <span class="attr">style</span>: <span class="keyword">new</span> Style(&#123;</span><br><span class="line">     <span class="attr">stroke</span>: <span class="keyword">new</span> Stroke(&#123;</span><br><span class="line">       <span class="attr">color</span>: <span class="string">&#x27;#0000ff&#x27;</span>,</span><br><span class="line">       <span class="attr">width</span>: <span class="number">2</span>,</span><br><span class="line">     &#125;),</span><br><span class="line">   &#125;),</span><br><span class="line"> &#125;);</span><br></pre></td></tr></table></figure><h2 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h2><p>增删改查</p><h3 id="拖拽加载geojson"><a href="#拖拽加载geojson" class="headerlink" title="拖拽加载geojson"></a>拖拽加载geojson</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 拖拽加载GeoJson</span></span><br><span class="line">  <span class="keyword">const</span> inputSource = <span class="keyword">new</span> VectorSource();</span><br><span class="line">  <span class="keyword">const</span> inputLayer = <span class="keyword">new</span> VectorLayer(&#123;</span><br><span class="line">    <span class="attr">source</span>: inputSource,</span><br><span class="line">  &#125;);</span><br><span class="line">  map.value?.addLayer(inputLayer);</span><br><span class="line">  map.value?.addInteraction(</span><br><span class="line">    <span class="keyword">new</span> DragAndDrop(&#123;</span><br><span class="line">      <span class="attr">source</span>: inputSource,</span><br><span class="line">      <span class="attr">formatConstructors</span>: [GeoJSON],</span><br><span class="line">    &#125;),</span><br><span class="line">  );</span><br></pre></td></tr></table></figure><p>显示效果</p>]]></content>
      
      
      
        <tags>
            
            <tag> None </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS红宝书学习</title>
      <link href="/2024/07/13/JS%E7%BA%A2%E5%AE%9D%E4%B9%A6%E5%AD%A6%E4%B9%A0/"/>
      <url>/2024/07/13/JS%E7%BA%A2%E5%AE%9D%E4%B9%A6%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="JS红宝书学习"><a href="#JS红宝书学习" class="headerlink" title="JS红宝书学习"></a>JS红宝书学习</h1><h2 id="第一章-什么是-JavaScript"><a href="#第一章-什么是-JavaScript" class="headerlink" title="第一章 什么是 JavaScript"></a>第一章 什么是 JavaScript</h2><p>JavaScript 是一门用来与网页交互的脚本语言，包含以下三个组成部分。</p><ul><li>ECMAScript：由 ECMA-262定义并提供核心功能。</li><li>文档对象模型（DOM）：提供与网页内容交互的方法和接口。<ul><li>DOM通过创建表示文档的树</li><li>DOM Core和DOM HTML</li></ul></li><li>浏览器对象模型（BOM）：提供与浏览器交互的方法和接口。<h2 id="第二章-HTML-中的-JavaScript"><a href="#第二章-HTML-中的-JavaScript" class="headerlink" title="第二章 HTML 中的 JavaScript"></a>第二章 HTML 中的 JavaScript</h2><h3 id="lt-script-gt-元素"><a href="#lt-script-gt-元素" class="headerlink" title="&lt;script&gt;元素"></a>&lt;script&gt;元素</h3><h4 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h4>1、包含在&lt;script&gt;内的代码会被从上到下解释<br>2、标签位置：放在页面之前 -&gt; 页面会在处理 JavaScript 代码之前完全渲染页面<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 这里是页面内容 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;example1.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;example2.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h4>1、src</li><li>只会下载并执行脚本文件，从而忽略标签内代码</li><li>可以是路径或者 URL<br>2、defer 推迟执行脚本<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>Example HTML Page<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">defer</span> <span class="attr">src</span>=<span class="string">&quot;example1.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">defer</span> <span class="attr">src</span>=<span class="string">&quot;example2.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 这里是页面内容 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li>脚本会被延迟到整个页面都解析完毕后再运行，即立即下载，但延迟执行。</li><li>标记为 defer 的脚本按照它们出现的次序延迟执行，重点在于它们之间 可能存在依赖关系。</li><li>第一个推迟的脚本会在第二个推迟的脚本之前执行，而且两者都会在 DOMContentLoaded 事件之前执行。<br>3、async 异步执行脚本</li><li>脚本会被延迟到整个页面都解析完毕后再运行，即立即下载，但异步执行。</li><li>标记为 async 的脚本并不保证能按照它们出现的次序执行，重点在于它们之间没有依赖关系</li><li>异步脚本保证会在页面的 load 事件前执行，但可能会在 DOMContentLoaded之前或之后<br>4、动态加载脚本<h4 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h4>虽然可以直接在 HTML 文件中嵌入 JavaScript 代码，但通常认为最佳实践是尽可能将 JavaScript 代码放在外部文件中。不过这个<br>最佳实践并不是明确的强制性规则。推荐使用外部文件的理由如下。</li><li>可维护性。JavaScript 代码如果分散到很多 HTML 页面，会导致维护困难。而用一个目录保存所有 JavaScript 文件，则更容易维护，这样开发者就可以独立于使用它们的 HTML 页面来编辑代码。</li><li>缓存。浏览器会根据特定的设置缓存所有外部链接的 JavaScript 文件，<strong>这意味着如果两个页面都用到同一个文件，则该文件只需下载一次。这最终意味着页面加载更快。</strong></li><li>适应未来。通过把 JavaScript 放到外部文件中，就不必考虑用 XHTML 或前面提到的注释黑科技。包含外部 JavaScript 文件的语法在 HTML 和 XHTML 中是一样的。</li></ul><h3 id="文档模式"><a href="#文档模式" class="headerlink" title="文档模式"></a>文档模式</h3><p>混杂模式（quirks mode）、标准模式（standards mode）、准标准模式（almost standards mode）</p><p>H5中，标准模式通过下列文档类型声明开启：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- HTML5 --&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="lt-noscript-gt-元素"><a href="#lt-noscript-gt-元素" class="headerlink" title="&lt;noscript&gt;元素"></a>&lt;noscript&gt;元素</h3><p>&lt;noscript&gt;元素可以包含任何可以出现在&lt;body&gt;中的HTML元素，&lt;script&gt;除外。<br>在下列两种情况下，浏览器将显示包含在&lt;noscript&gt;中的内容：</p><ul><li>浏览器不支持脚本；</li><li>浏览器对脚本的支持被关闭。<br>任何一个条件被满足，包含在&lt;noscript&gt;中的内容就会被渲染。否则，浏览器不会渲染&lt;noscript&gt;中的内容。<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>Example HTML Page<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">defer</span>=<span class="string">&quot;defer&quot;</span> <span class="attr">src</span>=<span class="string">&quot;example1.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">defer</span>=<span class="string">&quot;defer&quot;</span> <span class="attr">src</span>=<span class="string">&quot;example2.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">noscript</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>This page requires a JavaScript-enabled browser.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">noscript</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>这个例子是在脚本不可用时让浏览器显示一段话。如果浏览器支持脚本，则用户永远不会看到它。<h2 id="第三章-语言基础"><a href="#第三章-语言基础" class="headerlink" title="第三章 语言基础"></a>第三章 语言基础</h2><h3 id="特性-1"><a href="#特性-1" class="headerlink" title="特性"></a>特性</h3>1、区分大小写<br>2、标识符使用驼峰大小写形式，即第一个单词的首字母小写，后面每个单词的首字母大写<h3 id="严格模式"><a href="#严格模式" class="headerlink" title="严格模式"></a>严格模式</h3></li><li>要对整个脚本启用严格模式，在脚本开头加上这一行：<br><code>&quot;use strict&quot;;</code></li><li>也可以单独指定一个函数在严格模式下执行，只要把这个预处理指令放到函数体开头即可<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doSomething</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="meta">&quot;use strict&quot;</span>;</span><br><span class="line"><span class="comment">// 函数体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="声明变量的关键字"><a href="#声明变量的关键字" class="headerlink" title="声明变量的关键字"></a>声明变量的关键字</h3></li></ul><p><strong>var</strong></p><ul><li>函数作用域</li><li>声明提升</li><li>同一作用域可重复声明 <em>由于声明会被提升，JS引擎会自动将多余的声明在作用域顶部合并为一个声明</em></li><li>使用 var在全局作用域中声明的变量会成为 window 对象的属性</li></ul><p><strong>let</strong></p><ul><li>块作用域（<strong>任何一对花括号中的语句集都属于一个块</strong>）<em>块作用域是函数作用域的子集</em></li><li>无声明提升( 暂时性死区)<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// name 会被提升</span></span><br><span class="line"><span class="built_in">console</span>.log(name); <span class="comment">// undefined </span></span><br><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;Matt&#x27;</span>; </span><br><span class="line"><span class="comment">// age 不会被提升</span></span><br><span class="line"><span class="built_in">console</span>.log(age); <span class="comment">// ReferenceError：age 没有定义</span></span><br><span class="line"><span class="keyword">let</span> age = <span class="number">26</span>;</span><br></pre></td></tr></table></figure></li><li>同一作用域不可重复声明，但可以嵌套声明 <em>因为无声明提升</em></li><li>使用 let 在全局作用域中声明的变量不会成为 window 对象的属性<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;Matt&#x27;</span>; </span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.name); <span class="comment">// &#x27;Matt&#x27; </span></span><br><span class="line"><span class="keyword">let</span> age = <span class="number">26</span>; </span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.age); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure></li><li>for 循环中的 let 声明<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) &#123; </span><br><span class="line"> <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(i), <span class="number">0</span>) </span><br><span class="line">&#125;   <span class="comment">// 会输出 5、5、5、5、5</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) &#123; </span><br><span class="line"> <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(i), <span class="number">0</span>) </span><br><span class="line">&#125;   <span class="comment">// 会输出 0、1、2、3、4</span></span><br></pre></td></tr></table></figure>  之所以会这样，是因为在退出循环时，迭代变量保存的是导致循环退出的值：5。在之后执行超时逻辑时，所有的 i 都是同一个变量，因而输出的都是同一个最终值。<br>  而在使用 let 声明迭代变量时，JavaScript 引擎在后台会为每个迭代循环声明一个新的迭代变量。每个 setTimeout 引用的都是不同的变量实例，所以 console.log 输出的是我们期望的值，也就是循环执行过程中每个迭代变量的值。</li></ul><p><strong>const</strong></p><ul><li>const 的行为与 let 基本相同，唯一一个重要的区别是用它<strong>声明变量时必须同时初始化变量，且尝试修改 const 声明的变量会导致运行时错误</strong>。</li><li>const 声明的限制只适用于它指向的变量的引用。换句话说，<strong>如果 const 变量引用的是一个对象，那么修改这个对象内部的属性并不违反 const 的限制</strong>。</li><li><strong>JavaScript 引擎会为 for 循环中的 let 声明分别创建独立的变量实例</strong>，虽然 const 变量跟 let 变量很相似，但是不能用 const 来声明迭代变量（因为迭代变量会自增）：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;&#125; <span class="comment">// TypeError：给常量赋值</span></span><br></pre></td></tr></table></figure>不过，如果你只想用 const 声明一个不会被修改的 for 循环变量，那也是可以的。也就是说，每<br>次迭代只是创建一个新变量。<strong>这对 for-of 和 for-in 循环特别有意义</strong>：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> i = <span class="number">0</span>; </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> j = <span class="number">7</span>; i &lt; <span class="number">5</span>; ++i) &#123; </span><br><span class="line"> <span class="built_in">console</span>.log(j); </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// 7, 7, 7, 7, 7 </span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> &#123;<span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span>&#125;) &#123; </span><br><span class="line"> <span class="built_in">console</span>.log(key); </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// a, b </span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> value <span class="keyword">of</span> [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]) &#123; </span><br><span class="line"> <span class="built_in">console</span>.log(value); </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// 1, 2, 3, 4, 5</span></span><br></pre></td></tr></table></figure><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3>6种简单数据类型（也称为原始类型）：Undefined、Null、Boolean、Number、String 和 Symbol<br>1种复杂数据类型： Object（对象）<h4 id="typeof-操作符"><a href="#typeof-操作符" class="headerlink" title="typeof 操作符"></a>typeof 操作符</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> message = <span class="string">&quot;some string&quot;</span>; </span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> message); <span class="comment">// &quot;string&quot; </span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span>(message)); <span class="comment">// &quot;string&quot; </span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="number">95</span>); <span class="comment">// &quot;number&quot;</span></span><br></pre></td></tr></table></figure></li><li>对未初始化的变量调用 typeof 时，返回的结果是”undefined”<br>对未声明的变量调用 typeof 时，返回的结果还是”undefined”</li><li>逻辑上讲，null 值表示一个空对象指针，所以typeof 传一个 null 会返回”object”<h4 id="Number-类型"><a href="#Number-类型" class="headerlink" title="Number 类型"></a>Number 类型</h4></li><li><strong>浮点数</strong></li><li><strong>值的范围</strong><br>  Infinity<br>  isFinite()函数</li><li><strong>NaN</strong><br>  任何涉及 NaN 的操作始终返回 NaN<br>  NaN 不等于包括 NaN 在内的任何值<br>  isNaN()函数  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">isNaN</span>(<span class="literal">NaN</span>)); <span class="comment">// true </span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">isNaN</span>(<span class="number">10</span>)); <span class="comment">// false，10 是数值</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">isNaN</span>(<span class="string">&quot;10&quot;</span>)); <span class="comment">// false，可以转换为数值 10 </span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">isNaN</span>(<span class="string">&quot;blue&quot;</span>)); <span class="comment">// true，不可以转换为数值</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">isNaN</span>(<span class="literal">true</span>)); <span class="comment">// false，可以转换为数值 1</span></span><br></pre></td></tr></table></figure></li><li><strong>数值转换</strong><br> Number()：null返回 0、undefined返回 NaN、<em>空字符串返回0</em><br> parseInt()：接收第二个参数用于指定底数（进制数）、<em>空字符串返回 NaN</em><br> parseFloat()：只解析十进制值、”22.34.5”将转换成 22.34<blockquote><p>对对象调用上述方法，则先调用对象的 valueOf（）方法，对其返回值进行转换，如果转换结果是 NaN，则再调用 toString()方法，对其返回值进行转换。</p></blockquote><h4 id="String-类型"><a href="#String-类型" class="headerlink" title="String 类型"></a>String 类型</h4><h5 id="字符串的特点"><a href="#字符串的特点" class="headerlink" title="字符串的特点"></a>字符串的特点</h5>ECMAScript 中的字符串是不可变的（immutable），意思是一旦创建，它们的值就不能变了。要修改某个变量中的字符串值，必须先销毁原始的字符串，然后将包含新值的另一个字符串保存到该变量，如下所示：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> lang = <span class="string">&quot;Java&quot;</span>; </span><br><span class="line">lang = lang + <span class="string">&quot;Script&quot;</span>; </span><br></pre></td></tr></table></figure>这里，变量 lang 一开始包含字符串”Java”。紧接着，lang 被重新定义为包含”Java”和”Script”的组合，也就是”JavaScript”。整个过程首先会分配一个足够容纳 10 个字符的空间，然后填充上”Java”和”Script”。最后销毁原始的字符串”Java”和字符串”Script”<h5 id="转换为字符串"><a href="#转换为字符串" class="headerlink" title="转换为字符串"></a>转换为字符串</h5></li></ul><p><strong>toString()方法</strong><br>toString()方法可见于数值、布尔值、对象和字符串值。（没错，字符串值也有 toString()方法，该方法只是简单地返回自身的一个副本。）null 和 undefined 值没有 toString()方法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> age = <span class="number">11</span>; </span><br><span class="line"><span class="keyword">let</span> ageAsString = age.toString(); <span class="comment">// 字符串&quot;11&quot; </span></span><br><span class="line"><span class="keyword">let</span> found = <span class="literal">true</span>; </span><br><span class="line"><span class="keyword">let</span> foundAsString = found.toString(); <span class="comment">// 字符串&quot;true&quot;</span></span><br></pre></td></tr></table></figure><p><strong>String()函数</strong></p><ul><li>如果值有 toString()方法，则调用该方法（不传参数）并返回结果。</li><li>如果值是 null，返回”null”。</li><li>如果值是 undefined，返回”undefined”。<h5 id="模板字面量"><a href="#模板字面量" class="headerlink" title="模板字面量"></a>模板字面量</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 现在，可以用模板字面量这样实现：</span></span><br><span class="line"><span class="keyword">let</span> interpolatedTemplateLiteral = </span><br><span class="line"> <span class="string">`<span class="subst">$&#123; value &#125;</span> to the <span class="subst">$&#123; exponent &#125;</span> power is <span class="subst">$&#123; value * value &#125;</span>`</span>;</span><br></pre></td></tr></table></figure></li><li>任何插入的变量也会从它们最接近的作用域中取值</li><li>所有插入的值都会使用 toString()强制转型为字符串，而且任何 JavaScript 表达式都可以用于插值<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">`Hello, <span class="subst">$&#123; <span class="string">` World `</span> &#125;</span>!`</span>); <span class="comment">// Hello, World! </span></span><br><span class="line"><span class="comment">// 将表达式转换为字符串时会调用 toString()：</span></span><br><span class="line"><span class="keyword">let</span> foo = &#123; <span class="attr">toString</span>: <span class="function">() =&gt;</span> <span class="string">&#x27;World&#x27;</span> &#125;; </span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`Hello, <span class="subst">$&#123; foo &#125;</span>!`</span>); <span class="comment">// Hello, World! </span></span><br><span class="line"><span class="comment">// 在插值表达式中可以调用函数和方法：</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">capitalize</span>(<span class="params">word</span>) </span>&#123; </span><br><span class="line"> <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123; word[<span class="number">0</span>].toUpperCase() &#125;</span><span class="subst">$&#123; word.slice(<span class="number">1</span>) &#125;</span>`</span>; </span><br><span class="line">&#125; </span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123; capitalize(<span class="string">&#x27;hello&#x27;</span>) &#125;</span>, <span class="subst">$&#123; capitalize(<span class="string">&#x27;world&#x27;</span>) &#125;</span>!`</span>); <span class="comment">// Hello, World!</span></span><br></pre></td></tr></table></figure><h5 id="模板字面量标签函数"><a href="#模板字面量标签函数" class="headerlink" title="模板字面量标签函数"></a>模板字面量标签函数</h5>模板字面量也支持定义标签函数（tag function），而通过标签函数可以自定义插值行为。标签函数会接收被插值记号分隔后的模板和对每个表达式求值的结果<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">6</span>; </span><br><span class="line"><span class="keyword">let</span> b = <span class="number">9</span>; </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">simpleTag</span>(<span class="params">strings, aValExpression, bValExpression, sumExpression</span>) </span>&#123; </span><br><span class="line"> <span class="built_in">console</span>.log(strings);  <span class="comment">// [&quot;&quot;, &quot; + &quot;, &quot; = &quot;, &quot;&quot;] </span></span><br><span class="line"> <span class="built_in">console</span>.log(aValExpression);  <span class="comment">// 6 </span></span><br><span class="line"> <span class="built_in">console</span>.log(bValExpression);  <span class="comment">// 9 </span></span><br><span class="line"> <span class="built_in">console</span>.log(sumExpression);  <span class="comment">// 15 </span></span><br><span class="line"> <span class="keyword">return</span> <span class="string">&#x27;foobar&#x27;</span>; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">let</span> untaggedResult = <span class="string">`<span class="subst">$&#123; a &#125;</span> + <span class="subst">$&#123; b &#125;</span> = <span class="subst">$&#123; a + b &#125;</span>`</span>; </span><br><span class="line"><span class="keyword">let</span> taggedResult = simpleTag<span class="string">`<span class="subst">$&#123; a &#125;</span> + <span class="subst">$&#123; b &#125;</span> = <span class="subst">$&#123; a + b &#125;</span>`</span>; </span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(untaggedResult); <span class="comment">// &quot;6 + 9 = 15&quot; </span></span><br><span class="line"><span class="built_in">console</span>.log(taggedResult); <span class="comment">// &quot;foobar&quot;</span></span><br></pre></td></tr></table></figure>因为表达式参数的数量是可变的，所以通常应该使用剩余操作符（rest operator）将它们收集到一个<br>数组中：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">6</span>; </span><br><span class="line"><span class="keyword">let</span> b = <span class="number">9</span>; </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">simpleTag</span>(<span class="params">strings, ...expressions</span>) </span>&#123; </span><br><span class="line"> <span class="built_in">console</span>.log(strings); </span><br><span class="line"> <span class="keyword">for</span>(<span class="keyword">const</span> expression <span class="keyword">of</span> expressions) &#123; </span><br><span class="line"> <span class="built_in">console</span>.log(expression); </span><br><span class="line"> &#125; </span><br><span class="line"> <span class="keyword">return</span> <span class="string">&#x27;foobar&#x27;</span>; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">let</span> taggedResult = simpleTag<span class="string">`<span class="subst">$&#123; a &#125;</span> + <span class="subst">$&#123; b &#125;</span> = <span class="subst">$&#123; a + b &#125;</span>`</span>; </span><br><span class="line"><span class="comment">// [&quot;&quot;, &quot; + &quot;, &quot; = &quot;, &quot;&quot;] </span></span><br><span class="line"><span class="comment">// 6 </span></span><br><span class="line"><span class="comment">// 9 </span></span><br><span class="line"><span class="comment">// 15 </span></span><br><span class="line"><span class="built_in">console</span>.log(taggedResult); <span class="comment">// &quot;foobar&quot;</span></span><br></pre></td></tr></table></figure><h3 id="操作符"><a href="#操作符" class="headerlink" title="操作符"></a>操作符</h3><h4 id="一元操作符"><a href="#一元操作符" class="headerlink" title="一元操作符"></a>一元操作符</h4><h4 id="位操作符"><a href="#位操作符" class="headerlink" title="位操作符"></a>位操作符</h4>ECMAScript中的所有数值都以 IEEE 754 64 位格式存储，但位操作并不直接应用到 64 位表示，而是先把值转换为<strong>32 位</strong>整数，再进行位操作，之后再把结果转换为 64 位。</li></ul><p><strong>有符号整数</strong>使用 32 位的前 31 位表示整数值。第 32 位表示数值的符号，如 0 表示正，1 表示负。<br><strong>负值</strong>以一种称为<strong>二补数（或补码</strong>的二进制编码存储。一个数值的二补数通过如下 3 个步骤计算得到：<br> (1) 确定绝对值的二进制表示（如，对于18，先确定 18 的二进制表示）；<br> (2) 找到数值的一补数（或反码），换句话说，就是每个 0 都变成 1，每个 1 都变成 0；<br> (3) 给结果加 1。</p><h4 id="布尔操作符"><a href="#布尔操作符" class="headerlink" title="布尔操作符"></a>布尔操作符</h4><ul><li>逻辑非</li><li>逻辑与</li><li>逻辑或<h4 id="乘性操作符"><a href="#乘性操作符" class="headerlink" title="乘性操作符"></a>乘性操作符</h4></li><li>乘法操作符</li><li>除法操作符</li><li>取模操作符<h4 id="指数操作符"><a href="#指数操作符" class="headerlink" title="指数操作符"></a>指数操作符</h4>ECMAScript 7 新增了指数操作符，<strong>Math.pow()</strong> 现在有了自己的操作符**，结果是一样的：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.pow(<span class="number">3</span>, <span class="number">2</span>); <span class="comment">// 9 </span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">3</span> ** <span class="number">2</span>); <span class="comment">// 9 </span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.pow(<span class="number">16</span>, <span class="number">0.5</span>); <span class="comment">// 4 </span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">16</span>** <span class="number">0.5</span>); <span class="comment">// 4 </span></span><br></pre></td></tr></table></figure>不仅如此，指数操作符也有自己的指数赋值操作符**=，该操作符执行指数运算和结果的赋值操作：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> squared = <span class="number">3</span>; </span><br><span class="line">squared **= <span class="number">2</span>; </span><br><span class="line"><span class="built_in">console</span>.log(squared); <span class="comment">// 9</span></span><br></pre></td></tr></table></figure><h4 id="加性操作符"><a href="#加性操作符" class="headerlink" title="加性操作符"></a>加性操作符</h4><h4 id="关系操作符"><a href="#关系操作符" class="headerlink" title="关系操作符"></a>关系操作符</h4>关系操作符执行比较两个值的操作，包括小于（&lt;）、大于（&gt;）、小于等于（&lt;=）和大于等于（&gt;=），用法跟数学课上学的一样。这几个操作符都返回布尔值。</li><li>如果操作数都是数值，则执行数值比较。</li><li>如果操作数都是字符串，则逐个比较字符串中对应字符的编码。</li><li>如果有任一操作数是数值，则将另一个操作数转换为数值，执行数值比较。</li><li>如果有任一操作数是对象，则调用其 valueOf()方法，取得结果后再根据前面的规则执行比较。</li><li>如果没有 valueOf()操作符，则调用 toString()方法，取得结果后再根据前面的规则执行比较。</li><li>如果有任一操作数是布尔值，则将其转换为数值再执行比较。<h4 id="相等操作符"><a href="#相等操作符" class="headerlink" title="相等操作符"></a>相等操作符</h4></li></ul><p><strong>等于和不等于</strong><br> 这两个操作符都<em>会先进行类型转换</em>（通常称为强制类型转换）再确定操作数是否相等<br><strong>全等和不全等</strong><br> 这两个操作符<em>不会进行类型转换</em>（通常称为强制类型转换）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> result1 = (<span class="string">&quot;55&quot;</span> != <span class="number">55</span>); <span class="comment">// false，转换后相等</span></span><br><span class="line"><span class="keyword">let</span> result2 = (<span class="string">&quot;55&quot;</span> !== <span class="number">55</span>); <span class="comment">// true，不相等，因为数据类型不同</span></span><br></pre></td></tr></table></figure><h4 id="条件操作符"><a href="#条件操作符" class="headerlink" title="条件操作符"></a>条件操作符</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">variable = boolean_expression ? true_value : false_value;</span><br></pre></td></tr></table></figure><h4 id="赋值操作符"><a href="#赋值操作符" class="headerlink" title="赋值操作符"></a>赋值操作符</h4><h4 id="逗号操作符"><a href="#逗号操作符" class="headerlink" title="逗号操作符"></a>逗号操作符</h4><h3 id="语句"><a href="#语句" class="headerlink" title="语句"></a>语句</h3><h4 id="if-语句"><a href="#if-语句" class="headerlink" title="if 语句"></a>if 语句</h4><h4 id="do-while-语句"><a href="#do-while-语句" class="headerlink" title="do-while 语句"></a>do-while 语句</h4><p>循环体内的代码至少执行一次</p><h4 id="while-语句"><a href="#while-语句" class="headerlink" title="while 语句"></a>while 语句</h4><p>while 循环体内的代码有可能不会执行</p><h4 id="for-语句"><a href="#for-语句" class="headerlink" title="for 语句"></a>for 语句</h4><h4 id="for-in-语句"><a href="#for-in-语句" class="headerlink" title="for-in 语句"></a>for-in 语句</h4><p>for-in 语句是一种严格的迭代语句，用于枚举对象中的非符号键属性</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> propName <span class="keyword">in</span> <span class="built_in">window</span>) &#123; </span><br><span class="line"> <span class="built_in">document</span>.write(propName); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了确保局部变量不被修改，推荐使用 const</p><h4 id="for-of-语句"><a href="#for-of-语句" class="headerlink" title="for-of 语句"></a>for-of 语句</h4><p>for-of 语句是一种严格的迭代语句，用于遍历可迭代对象的元素</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> el <span class="keyword">of</span> [<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span>]) &#123; </span><br><span class="line"> <span class="built_in">document</span>.write(el); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了确保局部变量不被修改，推荐使用 const</p><h4 id="标签语句"><a href="#标签语句" class="headerlink" title="标签语句"></a>标签语句</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">start: <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; count; i++) &#123; </span><br><span class="line"> <span class="built_in">console</span>.log(i); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="break-和-continue-语句"><a href="#break-和-continue-语句" class="headerlink" title="break 和 continue 语句"></a>break 和 continue 语句</h4><p>break 语句用于立即退出循环，强制执行循环后的下一条语句。<br>continue 语句也用于立即退出循环，但会再次从循环顶部开始执行</p><h4 id="with-语句-不推荐使用"><a href="#with-语句-不推荐使用" class="headerlink" title="with 语句  (不推荐使用)"></a>with 语句  (不推荐使用)</h4><h4 id="switch-语句"><a href="#switch-语句" class="headerlink" title="switch 语句"></a>switch 语句</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (<span class="string">&quot;hello world&quot;</span>) &#123; </span><br><span class="line"> <span class="keyword">case</span> <span class="string">&quot;hello&quot;</span> + <span class="string">&quot; world&quot;</span>: </span><br><span class="line"> <span class="built_in">console</span>.log(<span class="string">&quot;Greeting was found.&quot;</span>); </span><br><span class="line"> <span class="keyword">break</span>; </span><br><span class="line"> <span class="keyword">case</span> <span class="string">&quot;goodbye&quot;</span>: </span><br><span class="line"> <span class="built_in">console</span>.log(<span class="string">&quot;Closing was found.&quot;</span>); </span><br><span class="line"> <span class="keyword">break</span>; </span><br><span class="line"> <span class="keyword">default</span>: </span><br><span class="line"> <span class="built_in">console</span>.log(<span class="string">&quot;Unexpected message was found.&quot;</span>); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="第四章-变量、作用域与内存"><a href="#第四章-变量、作用域与内存" class="headerlink" title="第四章 变量、作用域与内存"></a>第四章 变量、作用域与内存</h2><h3 id="原始值与引用值"><a href="#原始值与引用值" class="headerlink" title="原始值与引用值"></a>原始值与引用值</h3><p><strong>原始值</strong>（primitive value）就是最简单的数据，保存原始值的变量是按值（by value）访问的，因为我们操作的就是存储在变量中的实际值。<br><strong>引用值</strong>（reference value）则是由多个值构成的对象，保存引用值的变量是按引用（by reference）访问的，<br>在操作对象时，实际上操作的是对该对象的引用（reference）而非实际的对象本身。</p><p>注意，原始类型的初始化可以只使用原始字面量形式。如果使用的是 new 关键字，则 JavaScript 会<br>创建一个 Object 类型的实例，但其行为类似原始值。下面来看看这两种初始化方式的差异：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> name1 = <span class="string">&quot;Nicholas&quot;</span>; </span><br><span class="line"><span class="keyword">let</span> name2 = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">&quot;Matt&quot;</span>); </span><br><span class="line">name1.age = <span class="number">27</span>; </span><br><span class="line">name2.age = <span class="number">26</span>; </span><br><span class="line"><span class="built_in">console</span>.log(name1.age); <span class="comment">// undefined </span></span><br><span class="line"><span class="built_in">console</span>.log(name2.age); <span class="comment">// 26 </span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> name1); <span class="comment">// string </span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> name2); <span class="comment">// object</span></span><br></pre></td></tr></table></figure><h4 id="复制值时"><a href="#复制值时" class="headerlink" title="复制值时"></a>复制值时</h4><p><strong>原始值的复制</strong><br>复制的是值，两个变量可以独立使用，互不干扰</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> num1 = <span class="number">5</span>; </span><br><span class="line"><span class="keyword">let</span> num2 = num1; </span><br></pre></td></tr></table></figure><p><img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/20240714105838.png" alt="image.png|180"><br><strong>引用值的复制</strong><br>复制的是指针，一个对象上面的变化会在另一个对象上反映出来</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj1 = <span class="keyword">new</span> <span class="built_in">Object</span>(); </span><br><span class="line"><span class="keyword">let</span> obj2 = obj1; </span><br><span class="line">obj1.name = <span class="string">&quot;Nicholas&quot;</span>; </span><br><span class="line"><span class="built_in">console</span>.log(obj2.name); <span class="comment">// &quot;Nicholas&quot;</span></span><br></pre></td></tr></table></figure><p><img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/20240714105954.png" alt="image.png"></p><h4 id="传递参数时"><a href="#传递参数时" class="headerlink" title="传递参数时"></a>传递参数时</h4><p>ECMAScript 中所有函数的参数都是按值传递的<br><strong>原始值</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addTen</span>(<span class="params">num</span>) </span>&#123; </span><br><span class="line"> num += <span class="number">10</span>; </span><br><span class="line"> <span class="keyword">return</span> num; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">let</span> count = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">let</span> result = addTen(count); </span><br><span class="line"><span class="built_in">console</span>.log(count); <span class="comment">// 20，没有变化</span></span><br><span class="line"><span class="built_in">console</span>.log(result); <span class="comment">// 30</span></span><br></pre></td></tr></table></figure><p>函数 addTen()有一个参数 num，它其实是一个局部变量。在调用时，变量 count 作为参数传入。count 的值是 20，这个值被复制到参数 num 以便在 addTen()内部使用。在函数内部，参数 num的值被加上了 10，但这不会影响函数外部的原始变量 count。参数 num 和变量 count 互不干扰<br><strong>引用值</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setName</span>(<span class="params">obj</span>) </span>&#123; </span><br><span class="line"> obj.name = <span class="string">&quot;Nicholas&quot;</span>; </span><br><span class="line"> obj = <span class="keyword">new</span> <span class="built_in">Object</span>(); </span><br><span class="line"> obj.name = <span class="string">&quot;Greg&quot;</span>; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">let</span> person = <span class="keyword">new</span> <span class="built_in">Object</span>(); </span><br><span class="line">setName(person); </span><br><span class="line"><span class="built_in">console</span>.log(person.name); <span class="comment">// &quot;Nicholas&quot;</span></span><br></pre></td></tr></table></figure><p>当 obj 在函数内部被重写时，它变成了一个指向本地对象的指针。而那个本地对象在函数执行结束时就被销毁了</p><h4 id="instanceof-操作符"><a href="#instanceof-操作符" class="headerlink" title="instanceof 操作符"></a>instanceof 操作符</h4><p>typeof 操作符最适合用来判断一个变量是否为原始类型。更确切地说，它是判断一个变量是否为字符串、数值、布尔值或 undefined 的最好方式</p><p>如果变量是给定引用类型（由其原型链决定）的实例，则 instanceof 操作符返回 true</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(person <span class="keyword">instanceof</span> <span class="built_in">Object</span>); <span class="comment">// 变量 person 是 Object 吗？</span></span><br><span class="line"><span class="built_in">console</span>.log(colors <span class="keyword">instanceof</span> <span class="built_in">Array</span>); <span class="comment">// 变量 colors 是 Array 吗？</span></span><br><span class="line"><span class="built_in">console</span>.log(pattern <span class="keyword">instanceof</span> <span class="built_in">RegExp</span>); <span class="comment">// 变量 pattern 是 RegExp 吗？</span></span><br></pre></td></tr></table></figure><h3 id="执行上下文与作用域"><a href="#执行上下文与作用域" class="headerlink" title="执行上下文与作用域"></a>执行上下文与作用域</h3>]]></content>
      
      
      
        <tags>
            
            <tag> JS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>nvm下载与使用</title>
      <link href="/2024/07/13/nvm%E4%B8%8B%E8%BD%BD%E4%B8%8E%E4%BD%BF%E7%94%A8/"/>
      <url>/2024/07/13/nvm%E4%B8%8B%E8%BD%BD%E4%B8%8E%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="下载与安装"><a href="#下载与安装" class="headerlink" title="下载与安装"></a>下载与安装</h2><h3 id="1-下载地址"><a href="#1-下载地址" class="headerlink" title="1. 下载地址"></a>1. 下载地址</h3><p><a href="https://github.com/coreybutler/nvm-windows/releases">Site Unreachable</a><br>![[Pasted image 20240116162233.png|475]]</p><h3 id="2-两个路径"><a href="#2-两个路径" class="headerlink" title="2. 两个路径"></a>2. 两个路径</h3><p><img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/202401161625479.png" alt="image.png|475"><br><img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/202401161626799.png" alt="image.png|475"></p><h3 id="3-安装好后，查看一下对应的文件夹及环境变量（环境变量自动配置）"><a href="#3-安装好后，查看一下对应的文件夹及环境变量（环境变量自动配置）" class="headerlink" title="3. 安装好后，查看一下对应的文件夹及环境变量（环境变量自动配置）"></a>3. 安装好后，查看一下对应的文件夹及环境变量（环境变量自动配置）</h3><p><img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/202401161627385.png" alt="image.png"></p><h3 id="4-nvm-换镜像源"><a href="#4-nvm-换镜像源" class="headerlink" title="4. nvm 换镜像源"></a>4. nvm 换镜像源</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">node_mirror: https://npm.taobao.org/mirrors/node/</span><br><span class="line">npm_mirror: https://npm.taobao.org/mirrors/npm/</span><br></pre></td></tr></table></figure><h3 id="5-安装所需的-node-版本"><a href="#5-安装所需的-node-版本" class="headerlink" title="5. 安装所需的 node 版本"></a>5. 安装所需的 node 版本</h3><p><code>nvm list available</code> 查看当前可用版本<br><img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/202401161630347.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nvm install 16.20.0 下载</span><br><span class="line">nvm use 16.20.0 切换到已安装的版本</span><br></pre></td></tr></table></figure><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">nvm install &lt;version&gt;        <span class="comment">//安装指定版本的 Node.js。</span></span><br><span class="line">#例如，nvm install <span class="number">16.20</span><span class="number">.0</span> 将安装 Node.js 的 <span class="number">16.20</span><span class="number">.0</span> 版本。</span><br><span class="line">nvm use &lt;version&gt;            <span class="comment">//切换使用指定版本的 Node.js。</span></span><br><span class="line">#例如，nvm use <span class="number">16.20</span><span class="number">.0</span> 将设置当前会话中使用 Node.js 的 <span class="number">16.20</span><span class="number">.0</span> 版本。</span><br><span class="line">nvm list                     <span class="comment">//列出已安装的所有 Node.js 版本。</span></span><br><span class="line">#例如，nvm list 它将显示已安装的版本列表，并在当前使用的版本旁边加上一个箭头标记。</span><br><span class="line">nvm alias &lt;name&gt; &lt;version&gt;   <span class="comment">//创建一个别名以便更方便地引用特定的 Node.js 版本。</span></span><br><span class="line">#例如，nvm alias <span class="keyword">default</span> <span class="number">16.20</span><span class="number">.0</span> 将创建一个名为 <span class="string">&quot;default&quot;</span> 的别名，指向 Node.js 的 <span class="number">16.20</span><span class="number">.0</span> 版本。</span><br><span class="line">nvm uninstall &lt;version&gt;      <span class="comment">//卸载指定的 Node.js 版本。</span></span><br><span class="line">#例如，nvm uninstall <span class="number">16.20</span><span class="number">.0</span> 将卸载 Node.js 的 <span class="number">16.20</span><span class="number">.0</span> 版本。</span><br><span class="line">nvm current                  <span class="comment">//显示当前正在使用的 Node.js 版本。</span></span><br><span class="line">#例如，nvm current 将显示正使用的V16<span class="number">.20</span><span class="number">.0</span> 版本</span><br><span class="line">nvm use <span class="keyword">default</span>              <span class="comment">//切换到默认的 Node.js 版本（由 nvm alias 命令设置的别名）。</span></span><br><span class="line">#例如，nvm use <span class="keyword">default</span> 将切换到刚刚设置<span class="keyword">default</span>别名的<span class="number">16.20</span><span class="number">.0</span>版本</span><br><span class="line">nvm exec &lt;version&gt; &lt;command&gt; <span class="comment">//在指定版本的 Node.js 环境中执行特定的命令。</span></span><br><span class="line">#例如，nvm exec <span class="number">16.20</span><span class="number">.0</span> node app.js 将使用 Node.js 的 <span class="number">16.20</span><span class="number">.0</span> 版本来运行 app.js 文件。</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 元技能 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
