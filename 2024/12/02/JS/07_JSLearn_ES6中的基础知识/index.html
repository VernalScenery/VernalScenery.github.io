<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>07_JSLearn_ES6中的基础知识 | 春和景明的记事本</title><meta name="author" content="Scenery"><meta name="copyright" content="Scenery"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="1 对象字面量增强(Enhanced object literals)1、属性的简写（Property Shorthand） 123456789101112var name &amp;#x3D; &amp;quot;why&amp;quot;;var age &amp;#x3D; 18;&amp;#x2F;&amp;#x2F; ES5var obj &amp;#x3D; &amp;amp;#123;  name: na"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://vernalscenery.github.io/2024/12/02/JS/07_JSLearn_ES6%E4%B8%AD%E7%9A%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=4.13.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '07_JSLearn_ES6中的基础知识',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-12-15 17:56:15'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><link rel="stylesheet" href="/css/style.css"><meta name="generator" content="Hexo 5.4.2"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/./img/1.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">82</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">15</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/./img/1.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="春和景明的记事本"><span class="site-name">春和景明的记事本</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">07_JSLearn_ES6中的基础知识</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-12-02T00:25:42.000Z" title="发表于 2024-12-02 08:25:42">2024-12-02</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-12-15T09:56:15.324Z" title="更新于 2024-12-15 17:56:15">2024-12-15</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">9.2k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>36分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="07_JSLearn_ES6中的基础知识"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="1-对象字面量增强-Enhanced-object-literals"><a href="#1-对象字面量增强-Enhanced-object-literals" class="headerlink" title="1 对象字面量增强(Enhanced object literals)"></a>1 对象字面量增强(Enhanced object literals)</h2><p>1、属性的简写（Property Shorthand）</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&quot;why&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> age = <span class="number">18</span>;</span><br><span class="line"><span class="comment">// ES5</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>: name,</span><br><span class="line">  <span class="attr">age</span>: age</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// ES6</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  name,</span><br><span class="line">  age</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>2、方法的简写（Method Shorthand）</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ES5</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="attr">foo</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ES6</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><span style="color: #badc58; font-weight: 550;">注意：</span>箭头函数的 <code>this</code>指向上层作用域</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="attr">baz</span>: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line">obj.<span class="title function_">baz</span>() <span class="comment">// windows</span></span><br></pre></td></tr></table></figure>

<p>3、计算属性名（Computed Property Names）</p>
<ul>
<li>在 ES6 之前，对象的属性名必须是静态的，不能动态计算。</li>
<li>ES6 允许使用方括号 <code>[]</code> 来定义动态计算的属性名。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&quot;why&quot;</span>;</span><br><span class="line"><span class="comment">// ES5</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line">obj[name + <span class="number">123</span>] = <span class="string">&#x27;hehehehe&#x27;</span>;</span><br><span class="line"><span class="comment">// ES6</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123; </span><br><span class="line">	[name + <span class="number">123</span>]: <span class="string">&#x27;hehehehe&#x27;</span> </span><br><span class="line">&#125;;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj[name + <span class="number">123</span>]); <span class="comment">// hehehehe</span></span><br></pre></td></tr></table></figure>

<h2 id="2-解构Destructuring"><a href="#2-解构Destructuring" class="headerlink" title="2 解构Destructuring"></a>2 解构Destructuring</h2><h3 id="2-1-数组的解构"><a href="#2-1-数组的解构" class="headerlink" title="2.1 数组的解构"></a>2.1 数组的解构</h3><p>1、基本解构：直接从数组中提取元素并赋值给变量</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> names = [<span class="string">&#x27;abc&#x27;</span>, <span class="string">&#x27;cba&#x27;</span>, <span class="string">&#x27;nba&#x27;</span>];</span><br><span class="line"><span class="keyword">var</span> [item1, item2, item3] = names;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(item1, item2, item3); <span class="comment">// 输出: abc cba nba</span></span><br></pre></td></tr></table></figure>

<p>2、解构后面的元素：可以跳过前面的元素，直接解构后面的元素</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> [, , itemz] = names;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(itemz); <span class="comment">// 输出: nba</span></span><br></pre></td></tr></table></figure>

<p>3、解构出一个元素，其余元素放到一个新数组中：使用扩展运算符 <code>...</code> 可以将剩余的元素收集到一个新的数组中</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> [itemx, ...newNames] = names;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(itemx, newNames); <span class="comment">// 输出: abc [ &#x27;cba&#x27;, &#x27;nba&#x27; ]</span></span><br></pre></td></tr></table></figure>

<p>4、解构的默认值：- 可以为解构的变量提供默认值，当数组中对应位置的元素不存在时，使用默认值</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> [itema, itemb, itemc, itemd = <span class="string">&#x27;aaa&#x27;</span>] = names;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(itemd); <span class="comment">// 输出: aaa</span></span><br></pre></td></tr></table></figure>

<h3 id="2-2-对象的解构"><a href="#2-2-对象的解构" class="headerlink" title="2.2 对象的解构"></a>2.2 对象的解构</h3><p>1、基本解构：直接从对象中提取属性并赋值给同名变量</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;why&quot;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">18</span>,</span><br><span class="line">  <span class="attr">height</span>: <span class="number">1.88</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> &#123; name, age, height &#125; = obj;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(name, age, height); <span class="comment">// 输出: why 18 1.88</span></span><br></pre></td></tr></table></figure>

<p>2、解构特定属性：只解构对象中的特定属性</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> &#123; age &#125; = obj;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(age); <span class="comment">// 输出: 18</span></span><br></pre></td></tr></table></figure>

<p>3、重命名解构变量：可以为解构的属性指定不同的变量名</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> &#123; <span class="attr">name</span>: newName &#125; = obj;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(newName); <span class="comment">// 输出: why</span></span><br></pre></td></tr></table></figure>

<p>4、解构时提供默认值：可以为解构的变量提供默认值，当对象中对应属性不存在时，使用默认值</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> &#123; <span class="attr">address</span>: newAddress = <span class="string">&quot;广州市&quot;</span> &#125; = obj;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(newAddress); <span class="comment">// 输出: 广州市</span></span><br></pre></td></tr></table></figure>

<p>5、函数参数解构：可以在函数参数中使用对象解构，使函数参数更加简洁</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">info</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(info.<span class="property">name</span>, info.<span class="property">age</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">foo</span>(obj); <span class="comment">// 输出: why 18</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">bar</span>(<span class="params">&#123; name, age &#125;</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(name, age);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">bar</span>(obj); <span class="comment">// 输出: why 18</span></span><br></pre></td></tr></table></figure>

<h2 id="3-var-let-const"><a href="#3-var-let-const" class="headerlink" title="3 var/let/const"></a>3 var/let/const</h2><h3 id="3-1-var关键字"><a href="#3-1-var关键字" class="headerlink" title="3.1 var关键字"></a>3.1 <code>var</code>关键字</h3><ul>
<li>函数级作用域：<code>var</code> 声明的变量在函数内部有效，或者在全局作用域中有效。</li>
<li>变量提升：<code>var</code> 声明的变量会被提升到其作用域的顶部，但赋值不会被提升。</li>
<li>可以重复声明：同一个作用域内可以多次声明同一个变量，不会报错。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 函数级作用域</span></span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> x = <span class="number">10</span>;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(x); <span class="comment">// 输出: 10</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(x); <span class="comment">// 输出: 10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 变量提升</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a); <span class="comment">// 输出: undefined</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a); <span class="comment">// 输出: 10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以重复声明</span></span><br><span class="line"><span class="keyword">var</span> b = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">var</span> b = <span class="number">20</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(b); <span class="comment">// 输出: 20</span></span><br></pre></td></tr></table></figure>

<h3 id="3-2-let关键字"><a href="#3-2-let关键字" class="headerlink" title="3.2 let关键字"></a>3.2 <code>let</code>关键字</h3><ul>
<li>块级作用域：<code>let</code> 声明的变量只在当前代码块<code>&#123;&#125;</code> 内有效。</li>
<li>没有变量提升：<code>let</code> 声明的变量不会被提升到作用域顶部，必须先声明后使用。</li>
<li>不可重复声明：同一个作用域内不能重复声明同一个变量。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 块级作用域</span></span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> x = <span class="number">10</span>;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(x); <span class="comment">// 输出: 10</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(x); <span class="comment">// ReferenceError: x is not defined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 没有变量提升</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(foo) <span class="comment">// ReferenceError: Cannot access &#x27;foo&#x27; before initialization</span></span><br><span class="line"><span class="keyword">let</span> foo = <span class="string">&quot;foo&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 不可重复声明</span></span><br><span class="line"><span class="keyword">let</span> y = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">let</span> y = <span class="number">30</span>; <span class="comment">// SyntaxError: Identifier &#x27;y&#x27; has already been declared</span></span><br></pre></td></tr></table></figure>

<h3 id="3-3-const关键字"><a href="#3-3-const关键字" class="headerlink" title="3.3 const关键字"></a>3.3 <code>const</code>关键字</h3><ul>
<li>块级作用域：<code>const</code> 声明的变量也只在当前代码块 <code>&#123;&#125;</code> 内有效。</li>
<li>不可重新赋值：<code>const</code> 声明的变量一旦赋值后，不能再被重新赋值。</li>
<li>必须初始化：<code>const</code> 声明的变量必须在声明时初始化。</li>
<li>引用类型可变：对于引用类型（如对象、数组），虽然不能重新赋值，但可以修改其内部属性或元素。</li>
</ul>
<p>const 本质上是传递的值不可以修改：</p>
<ul>
<li>对于基本类型（如字符串、数字、布尔值），const 声明的变量值不可改变。</li>
<li>对于引用类型（如对象、数组），虽然不能重新赋值，但可以修改其内部属性或元素。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引用类型可变</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;Alice&quot;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// obj = &#123;&#125;; // TypeError: Assignment to constant variable.</span></span><br><span class="line">obj.<span class="property">name</span> = <span class="string">&quot;Bob&quot;</span>;</span><br><span class="line">obj.<span class="property">age</span> = <span class="number">25</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj); <span class="comment">// 输出: &#123; name: &#x27;Bob&#x27;, age: 25 &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="comment">// arr = [4, 5, 6]; // TypeError: Assignment to constant variable.</span></span><br><span class="line">arr.<span class="title function_">push</span>(<span class="number">4</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr); <span class="comment">// 输出: [1, 2, 3, 4]</span></span><br></pre></td></tr></table></figure>

<p>通过 let/const 定义的变量名是不可以重复定义：</p>
<ul>
<li>在同一个作用域内，不能重复声明同一个变量。</li>
</ul>
<h3 id="3-4-作用域提升-（hoisting）"><a href="#3-4-作用域提升-（hoisting）" class="headerlink" title="3.4 作用域提升 （hoisting）"></a>3.4 作用域提升 （hoisting）</h3><ul>
<li>**<code>var</code>**：变量会被提升到其作用域的顶部，但赋值不会被提升。在声明之前访问变量会得到 <code>undefined</code>。</li>
<li>**<code>let</code> 和 <code>const</code>**：变量也会被提升到其作用域的顶部，但在声明之前访问会抛出 <code>ReferenceError</code>。这是因为它们在声明之前处于“暂时性死区”（TDZ）</li>
</ul>
<p><img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/20241203200100.png"></p>
<h4 id="3-4-1-暂时性死区-（Temporal-Dead-Zone-TDZ）"><a href="#3-4-1-暂时性死区-（Temporal-Dead-Zone-TDZ）" class="headerlink" title="3.4.1 暂时性死区 （Temporal Dead Zone, TDZ）"></a>3.4.1 暂时性死区 （Temporal Dead Zone, TDZ）</h4><ul>
<li><strong>创建阶段</strong>：<code>let</code> 和 <code>const</code> 声明的变量在它们所在的词法环境被实例化时会被创建，但它们在声明之前是不可访问的。</li>
<li><strong>访问限制</strong>：在声明之前访问这些变量会导致 <code>ReferenceError</code>。</li>
</ul>
<p><span style="color: #badc58; font-weight: 550;">解释：</span></p>
<ul>
<li><strong>词法环境实例化</strong>：当一个词法环境（如函数或块）被创建时，所有 <code>let</code> 和 <code>const</code> 声明的变量都会被创建，但它们的初始状态是“未初始化”。</li>
<li><strong>求值阶段</strong>：当代码执行到 <code>let</code> 或 <code>const</code> 声明时，变量会被初始化并赋值，此时它们才可被访问。</li>
</ul>
<h3 id="3-5-let-const和window关系"><a href="#3-5-let-const和window关系" class="headerlink" title="3.5 let-const和window关系"></a>3.5 let-const和window关系</h3><p><img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/20241202214927.png" alt="image.png"></p>
<p><code>var</code>阶段</p>
<p><img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/20241202214941.png" alt="image.png"></p>
<p><code>let/const</code>阶段</p>
<p><img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/20241202215003.png" alt="image.png"></p>
<p><code>window</code> 对象是浏览器环境中的全局对象。在早期的 JavaScript 实现中，<code>window</code> 对象被用来存储所有的全局变量和函数。然而，随着 ES6 的引入，<code>let</code> 和 <code>const</code> 的出现改变了这一行为。</p>
<blockquote>
<p>ES6之前：window对象就是早期的 GO对象，VO，GO 是早期的说法</p>
</blockquote>
<ul>
<li>**<code>var</code>**：声明的变量会被添加到 <code>window</code> 对象上。</li>
<li>**<code>let</code> 和 <code>const</code>**：声明的变量不会被添加到 <code>window</code> 对象上，而是存储在当前的词法环境中。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> foo = <span class="string">&#x27;foo&#x27;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">window</span>.<span class="property">foo</span>); <span class="comment">// 输出: undefined</span></span><br></pre></td></tr></table></figure>

<p>根据最新的 ECMAScript 标准，每个执行上下文（execution context）都有一个关联的变量环境（variable environment）和词法环境（lexical environment）。这些环境记录（environment record）用于存储变量和函数声明。</p>
<ul>
<li><strong>变量环境</strong>：用于存储 <code>var</code> 声明的变量和函数声明。</li>
<li><strong>词法环境</strong>：用于存储 <code>let</code> 和 <code>const</code> 声明的变量。</li>
</ul>
<p>二者的具体的实现细节取决于 JavaScript 引擎。例如，V8 引擎（Chrome 和 Node.js 使用的引擎）使用一个哈希表（<code>VariableMap</code>）来存储这些变量</p>
<p><img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/20241202215614.png" alt="image.png"></p>
<h4 id="3-5-1-执行上下文（Execution-Context）"><a href="#3-5-1-执行上下文（Execution-Context）" class="headerlink" title="3.5.1 执行上下文（Execution Context）"></a>3.5.1 执行上下文（Execution Context）</h4><p>每个 JavaScript 函数调用或全局代码执行时，都会创建一个<strong>新的</strong>执行上下文。执行上下文是 JavaScript 引擎用来管理函数调用和全局代码执行的机制。</p>
<ul>
<li><strong>在全局执行上下文中</strong>，变量环境和词法环境是相同的。全局变量和函数声明会被添加到这两个环境中。</li>
<li><strong>在函数执行上下文中</strong>，变量环境和词法环境是独立的，不会影响其他函数或全局环境。</li>
<li><strong>嵌套函数的执行上下文</strong>也会有自己的变量环境和词法环境，但它们可以访问外层函数的变量环境和词法环境。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">outer</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> outerVar = <span class="string">&#x27;outerVar&#x27;</span>;</span><br><span class="line">    <span class="keyword">let</span> outerLet = <span class="string">&#x27;outerLet&#x27;</span>;</span><br><span class="line">    <span class="keyword">const</span> outerConst = <span class="string">&#x27;outerConst&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">inner</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> innerVar = <span class="string">&#x27;innerVar&#x27;</span>;</span><br><span class="line">        <span class="keyword">let</span> innerLet = <span class="string">&#x27;innerLet&#x27;</span>;</span><br><span class="line">        <span class="keyword">const</span> innerConst = <span class="string">&#x27;innerConst&#x27;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(outerVar); <span class="comment">// 输出: outerVar</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(outerLet); <span class="comment">// 输出: outerLet</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(outerConst); <span class="comment">// 输出: outerConst</span></span><br><span class="line"></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(innerVar); <span class="comment">// 输出: innerVar</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(innerLet); <span class="comment">// 输出: innerLet</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(innerConst); <span class="comment">// 输出: innerConst</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">inner</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">outer</span>();</span><br></pre></td></tr></table></figure>

<p>在这个例子中：</p>
<ul>
<li><strong><code>outerVar</code><strong>、</strong><code>outerLet</code></strong> 和 **<code>outerConst</code>**：被添加到 <code>outer</code> 函数的变量环境和词法环境中。</li>
<li><strong><code>innerVar</code><strong>、</strong><code>innerLet</code></strong> 和 **<code>innerConst</code>**：被添加到 <code>inner</code> 函数的变量环境和词法环境中。</li>
</ul>
<p><span style="color: #badc58; font-weight: 550;">每个执行上下文都有两个重要的组成部分：</span></p>
<ul>
<li><strong>变量环境（VariableEnvironment）</strong>：用于存储 <code>var</code> 声明的变量和函数声明。</li>
<li><strong>词法环境（LexicalEnvironment）</strong>：用于存储 <code>let</code> 和 <code>const</code> 声明的变量。</li>
</ul>
<h4 id="3-5-2-变量环境（VariableEnvironment）"><a href="#3-5-2-变量环境（VariableEnvironment）" class="headerlink" title="3.5.2 变量环境（VariableEnvironment）"></a>3.5.2 变量环境（VariableEnvironment）</h4><ul>
<li><strong>变量环境</strong> 是一个环境记录（Environment Record），用于存储变量和函数声明。</li>
<li>对于全局代码，变量环境和词法环境是同一个对象。</li>
<li>对于函数代码，参数也会被添加到变量环境中。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">example</span>(<span class="params">a, b</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> x = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">let</span> y = <span class="number">20</span>;</span><br><span class="line">    <span class="keyword">const</span> z = <span class="number">30</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 全局执行上下文</span></span><br><span class="line"><span class="keyword">var</span> globalVar = <span class="string">&quot;global&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> globalLet = <span class="string">&quot;globalLet&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> globalConst = <span class="string">&quot;globalConst&quot;</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>在全局执行上下文中，<code>globalVar</code> 会被添加到变量环境中，<code>globalLet</code> 和 <code>globalConst</code> 会被添加到词法环境中。</li>
<li>在 <code>example</code> 函数的执行上下文中，<code>a</code> 和 <code>b</code> 参数会被添加到变量环境中，<code>x</code> 会被添加到变量环境中，<code>y</code> 和 <code>z</code> 会被添加到词法环境中。</li>
</ul>
<h4 id="3-5-3-环境记录（Environment-Record）"><a href="#3-5-3-环境记录（Environment-Record）" class="headerlink" title="3.5.3 环境记录（Environment Record）"></a>3.5.3 环境记录（Environment Record）</h4><ul>
<li><strong>环境记录</strong> 是一个对象，用于存储变量和函数声明的具体信息。</li>
<li>变量环境和词法环境都是环境记录的实例。</li>
</ul>
<h4 id="3-5-4-var、let-和-const-的区别"><a href="#3-5-4-var、let-和-const-的区别" class="headerlink" title="3.5.4 var、let 和 const 的区别"></a>3.5.4 <code>var</code>、<code>let</code> 和 <code>const</code> 的区别</h4><ul>
<li>**<code>var</code>**：声明的变量会被添加到变量环境中，并且在全局作用域中会被添加到 <code>window</code> 对象上。</li>
<li>**<code>let</code> 和 <code>const</code>**：声明的变量会被添加到词法环境中，并且不会被添加到 <code>window</code> 对象上。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 全局执行上下文</span></span><br><span class="line"><span class="keyword">var</span> globalVar = <span class="string">&quot;global&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> globalLet = <span class="string">&quot;globalLet&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> globalConst = <span class="string">&quot;globalConst&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">window</span>.<span class="property">globalVar</span>); <span class="comment">// 输出: &quot;global&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">window</span>.<span class="property">globalLet</span>); <span class="comment">// 输出: undefined</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">window</span>.<span class="property">globalConst</span>); <span class="comment">// 输出: undefined</span></span><br></pre></td></tr></table></figure>

<h3 id="3-6-let-const的块级作用域"><a href="#3-6-let-const的块级作用域" class="headerlink" title="3.6 let/const的块级作用域"></a>3.6 let/const的块级作用域</h3><p>ES6之前，JavaScript只会形成两个作用域：</p>
<ul>
<li>全局作用域</li>
<li>函数作用域</li>
</ul>
<p><img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/20241202221614.png" alt="image.png"></p>
<p>ES5中放到一个<strong>块代码</strong>中定义的变量，外面是可以访问的：</p>
<p><img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/20241202221631.png" alt="image.png"></p>
<p>所以这里的括号<code>&#123;&#125;</code>形同虚设</p>
<p>在ES6中新增了块级作用域，并且通过<code>let</code>、<code>const</code>、<code>function</code>、<code>class</code>声明的标识符是具备块级作用域的限制的</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ES6的代码块级作用域</span></span><br><span class="line"><span class="comment">// 对let/const/function/class声明的类型是有效</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">let</span> foo = <span class="string">&#x27;why&#x27;</span>;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">bar</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;bar&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">Person</span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(foo); <span class="comment">// foo is not defined</span></span><br><span class="line"><span class="comment">// 不同的浏览器有不同实现的(大部分浏览器为了兼容以前的代码, 让function是没有块级作用域)</span></span><br><span class="line"><span class="title function_">bar</span>();</span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> <span class="title class_">Person</span>(); <span class="comment">// Person is not defined</span></span><br></pre></td></tr></table></figure>

<p><span style="color: #badc58; font-weight: 550;">其中：</span></p>
<p>**<code>function</code>**：在ES6规范中，<code>function</code> 声明在块级作用域内应该具有块级作用域。然而，许多浏览器为了向后兼容，仍然将 <code>function</code> 声明提升到最近的函数或全局作用域，而不是块级作用域。这种行为被称为“函数声明提升到块级作用域”。</p>
<h4 id="3-6-1-块级作用域语句"><a href="#3-6-1-块级作用域语句" class="headerlink" title="3.6.1 块级作用域语句"></a>3.6.1 块级作用域语句</h4><p>在JavaScript中，块级作用域主要通过 <code>let</code> 和 <code>const</code> 关键字来实现。块级作用域可以在多种语句和结构中出现，包括但不限于 <code>if</code> 语句、<code>switch</code> 语句和 <code>for</code> 循环。以下是对这些块级作用域语句的详细说明：</p>
<p>1、<strong>if 语句</strong>：if 语句中的代码块可以形成块级作用域。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> foo = <span class="string">&quot;foo&quot;</span>;</span><br><span class="line">  <span class="keyword">let</span> bar = <span class="string">&quot;bar&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(foo); <span class="comment">// 输出: foo</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(bar); <span class="comment">// ReferenceError: bar is not defined</span></span><br></pre></td></tr></table></figure>

<p>2、<strong>switch 语句</strong>：switch 语句中的代码块可以形成块级作用域。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> color = <span class="string">&quot;red&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> (color) &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="string">&quot;red&quot;</span>:</span><br><span class="line">    <span class="keyword">var</span> foo = <span class="string">&quot;foo&quot;</span>;</span><br><span class="line">    <span class="keyword">let</span> bar = <span class="string">&quot;bar&quot;</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(foo); <span class="comment">// 输出: foo</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(bar); <span class="comment">// ReferenceError: bar is not defined</span></span><br></pre></td></tr></table></figure>

<p>3、<strong>for 循环</strong>：for 循环中的代码块可以形成块级作用域。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">  <span class="comment">// console.log(&quot;Hello World &quot; + i);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(i); <span class="comment">// 输出: 10</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; <span class="number">10</span>; j++) &#123;</span><br><span class="line">  <span class="comment">// console.log(&quot;Hello World &quot; + j);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(j); <span class="comment">// ReferenceError: j is not defined</span></span><br></pre></td></tr></table></figure>

<p>4、<strong>其他块级结构</strong>：任何用 {} 包围的代码块都可以形成块级作用域。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="keyword">let</span> foo = <span class="string">&quot;foo&quot;</span>;</span><br><span class="line">  <span class="keyword">const</span> bar = <span class="string">&quot;bar&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(foo); <span class="comment">// ReferenceError: foo is not defined</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(bar); <span class="comment">// ReferenceError: bar is not defined</span></span><br></pre></td></tr></table></figure>

<h4 id="3-6-2-块级作用域的应用"><a href="#3-6-2-块级作用域的应用" class="headerlink" title="3.6.2 块级作用域的应用"></a>3.6.2 块级作用域的应用</h4><p>块级作用域在JavaScript中提供了更细粒度的变量管理，特别是在循环和条件语句中。以下是一些块级作用域的典型应用场景，以及如何利用 <code>let</code> 和 <code>const</code> 关键字来解决常见问题。</p>
<ul>
<li><strong>循环中的闭包问题</strong>：使用 <code>let</code> 可以确保每次迭代中的变量是独立的。</li>
<li><strong>避免变量污染</strong>：使用 <code>let</code> 和 <code>const</code> 可以确保变量只在需要的范围内生效。</li>
<li><strong>临时变量</strong>：使用 <code>let</code> 或 <code>const</code> 定义临时变量，确保这些变量不会影响到其他部分的代码。</li>
<li><strong>块级作用域内的函数</strong>：在块级作用域内定义的函数不会污染外部作用域。</li>
<li><strong>常量声明</strong>：使用 <code>const</code> 声明常量，确保这些常量在声明后不能被重新赋值。</li>
</ul>
<h5 id="循环中的闭包问题"><a href="#循环中的闭包问题" class="headerlink" title="循环中的闭包问题"></a>循环中的闭包问题</h5><p>在使用 <code>var</code> 声明变量时，由于变量提升和函数作用域的原因，闭包中捕获的变量可能会导致意外的行为。使用 <code>let</code> 可以解决这个问题。</p>
<p><span style="color: #badc58; font-weight: 550;">使用var的问题</span></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> btns = <span class="variable language_">document</span>.<span class="title function_">getElementsByTagName</span>(<span class="string">&#x27;button&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; btns.<span class="property">length</span>; i++) &#123;</span><br><span class="line">  btns[i].<span class="property">onclick</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;第&quot;</span> + i + <span class="string">&quot;个按钮被点击&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 点击任何一个按钮，都会输出 &quot;第3个按钮被点击&quot;（假设btns.length为3）</span></span><br></pre></td></tr></table></figure>

<p>由于 <code>var</code> 声明的变量 <code>i</code> 具有函数作用域或全局作用域，所有事件处理函数都引用同一个变量 <code>i</code>。在循环结束后，<code>i</code> 的值是 <code>btns.length</code>，因此所有按钮的点击事件都会输出 “第3个按钮被点击”（假设 <code>btns.length</code> 为 3）。`</p>
<p><span style="color: #badc58; font-weight: 550;">使用立即执行函数表达式（IIFE）解决问题</span></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> btns = <span class="variable language_">document</span>.<span class="title function_">getElementsByTagName</span>(<span class="string">&#x27;button&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; btns.<span class="property">length</span>; i++) &#123;</span><br><span class="line">  (<span class="keyword">function</span> (<span class="params">n</span>) &#123;</span><br><span class="line">    btns[i].<span class="property">onclick</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;第&#x27;</span> + n + <span class="string">&#x27;个按钮被点击&#x27;</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;)(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 点击第n个按钮，会正确输出 &quot;第n个按钮被点击&quot;</span></span><br></pre></td></tr></table></figure>

<p>通过使用 IIFE，每次循环中的 <code>i</code> 被传递给 IIFE 作为一个新的局部变量 <code>n</code>，从而确保每个事件处理函数引用的是独立的变量 <code>n</code>。</p>
<p><span style="color: #badc58; font-weight: 550;">使用let解决问题</span></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> btns = <span class="variable language_">document</span>.<span class="title function_">getElementsByTagName</span>(<span class="string">&#x27;button&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; btns.<span class="property">length</span>; i++) &#123;</span><br><span class="line">  btns[i].<span class="property">onclick</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;第&quot;</span> + i + <span class="string">&quot;个按钮被点击&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 点击第n个按钮，会正确输出 &quot;第n个按钮被点击&quot;</span></span><br></pre></td></tr></table></figure>

<p>由于 <code>let</code> 声明的变量 <code>i</code> 具有块级作用域，每次循环中的 <code>i</code> 都是独立的。因此，每个按钮的点击事件处理函数引用的是各自独立的 <code>i</code>，点击第 <code>n</code> 个按钮会正确输出 “第n个按钮被点击”。</p>
<h5 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h5><p><span style="color: #badc58; font-weight: 550;">for 循环中不可以使用const</span></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> names = [<span class="string">&#x27;abc&#x27;</span>, <span class="string">&#x27;cba&#x27;</span>, <span class="string">&#x27;nba&#x27;</span>];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> i = <span class="number">0</span>; i &lt; names.<span class="property">length</span>; i++) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(names[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">const</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(names[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">const</span> i = <span class="number">1</span>;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(names[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">const</span> i = <span class="number">2</span>;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(names[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>因为这里<code>i++</code>尝试修改<code>const</code>声明的变量<code>i</code></p>
<p><span style="color: #badc58; font-weight: 550;">for…of: ES6新增的遍历数组(对象)</span></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> item <span class="keyword">of</span> names) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(item);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">const</span> item = <span class="string">&#x27;abc&#x27;</span>;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(item);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">const</span> item = <span class="string">&#x27;cba&#x27;</span>;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(item);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里const声明的item后续没有被修改</p>
<h3 id="3-7-var、let、const的选择"><a href="#3-7-var、let、const的选择" class="headerlink" title="3.7 var、let、const的选择"></a>3.7 var、let、const的选择</h3><p><img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/20241203200507.png" alt="image.png"></p>
<h2 id="4-模板字符串"><a href="#4-模板字符串" class="headerlink" title="4 模板字符串"></a>4 模板字符串</h2><p>在ES6之前，如果我们想要将字符串和一些动态的变量（标识符）拼接到一起，是非常麻烦和丑陋的（ugly）</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ES6之前拼接字符串和其他标识符</span></span><br><span class="line"><span class="keyword">const</span> name = <span class="string">&quot;why&quot;</span></span><br><span class="line"><span class="keyword">const</span> age = <span class="number">18</span></span><br><span class="line"><span class="keyword">const</span> height = <span class="number">1.88</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;my name is &quot;</span> + name + <span class="string">&quot;, age is &quot;</span> + age + <span class="string">&quot;, height is &quot;</span> + height)</span><br></pre></td></tr></table></figure>

<p>ES6允许我们使用字符串模板来嵌入JS的变量或者表达式来进行拼接</p>
<ul>
<li>首先，我们会使用 ` ` 符号来编写字符串，称之为模板字符串</li>
<li>其次，在模板字符串中，我们可以通过 <code>$&#123;expression&#125;</code> 来嵌入动态的内容；</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ES6提供模板字符串 ``</span></span><br><span class="line"><span class="keyword">const</span> message = <span class="string">`my name is <span class="subst">$&#123;name&#125;</span>, age is <span class="subst">$&#123;age&#125;</span>, height is <span class="subst">$&#123;height&#125;</span>`</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(message)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> info = <span class="string">`age double is <span class="subst">$&#123;age * <span class="number">2</span>&#125;</span>`</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(info)</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">doubleAge</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> age * <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> info2 = <span class="string">`double age is <span class="subst">$&#123;doubleAge()&#125;</span>`</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(info2)</span><br></pre></td></tr></table></figure>

<p>模板字符串还有另外一种用法：<strong>标签模板字符串（Tagged Template Literals）</strong></p>
<ul>
<li><strong>静态部分</strong>：<code>[&#39;Hello&#39;, &#39;Wo&#39;, &#39;rld&#39;]</code></li>
<li><strong>动态部分</strong>：<code>[&#39;why&#39;, 18]</code></li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">arr, name, age</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;arr:&#x27;</span>, arr);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;name:&#x27;</span>, name);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;age:&#x27;</span>, age);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> name = <span class="string">&#x27;why&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> age = <span class="number">18</span>;</span><br><span class="line">foo<span class="string">`Hello<span class="subst">$&#123;name&#125;</span>Wo<span class="subst">$&#123;age&#125;</span>rld`</span>;</span><br></pre></td></tr></table></figure>

<p><img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/20241203201626.png" alt="image.png"></p>
<p><span style="color: #badc58; font-weight: 550;">应用场景举例：React的styled-components库</span></p>
<p><img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/20241203201859.png" alt="image.png"></p>
<h2 id="5-函数相关"><a href="#5-函数相关" class="headerlink" title="5 函数相关"></a>5 函数相关</h2><h3 id="5-1-函数的默认参数"><a href="#5-1-函数的默认参数" class="headerlink" title="5.1 函数的默认参数"></a>5.1 函数的默认参数</h3><p>ES5以及之前给参数默认值</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">m, n</span>) &#123;</span><br><span class="line">  m = m || <span class="string">&#x27;aaa&#x27;</span>;</span><br><span class="line">  n = n || <span class="string">&#x27;bbb&#x27;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(m, n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种写法传入<code>0</code>或 <code>null</code>这种布尔值为 <code>false</code>的时候有 bug</p>
<p><span style="color: #badc58; font-weight: 550;">1、ES6可以给函数参数提供默认值</span></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">m = <span class="string">&#x27;aaa&#x27;</span>, n = <span class="string">&#x27;bbb&#x27;</span></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(m, n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">foo</span>();</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><span style="color: #badc58; font-weight: 550;">2、对象参数和默认值以及解构</span></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">printInfo</span>(<span class="params">&#123; name, age &#125; = &#123; name: <span class="string">&#x27;why&#x27;</span>, age: <span class="number">18</span> &#125;</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(name, age);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">printInfo</span>(&#123; <span class="attr">name</span>: <span class="string">&#x27;kobe&#x27;</span>, <span class="attr">age</span>: <span class="number">40</span> &#125;); <span class="comment">// kobe 40</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 另外一种写法</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">printInfo1</span>(<span class="params">&#123; name = <span class="string">&#x27;why&#x27;</span>, age = <span class="number">18</span> &#125; = &#123;&#125;</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(name, age);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">printInfo1</span>(); <span class="comment">// why 18</span></span><br></pre></td></tr></table></figure>

<p><span style="color: #badc58; font-weight: 550;">3、有默认值的形参最好放到最后</span></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">bar</span>(<span class="params">x, y, z = <span class="number">30</span></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(x, y, z);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">bar</span>(<span class="number">10</span>, <span class="number">20</span>) <span class="comment">// 10 20 30</span></span><br></pre></td></tr></table></figure>

<p><span style="color: #badc58; font-weight: 550;">4、有默认值时函数的length属性</span></p>
<p>根据 JavaScript 的规范，函数的 <code>length</code> 属性只计算从左到右第一个带有默认值的参数之前的参数数量。这意味着一旦遇到带有默认值的参数，后续的所有参数都不会被计入 <code>length</code> 属性中</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">baz</span>(<span class="params">x, y, z, m, n = <span class="number">30</span></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(x, y, z, m, n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(baz.<span class="property">length</span>); <span class="comment">// 4</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">baz</span>(<span class="params">x, y, z = <span class="number">30</span>, m, n</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(x, y, z, m, n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(baz.<span class="property">length</span>); <span class="comment">// 22</span></span><br></pre></td></tr></table></figure>

<h3 id="5-2-函数的剩余参数"><a href="#5-2-函数的剩余参数" class="headerlink" title="5.2 函数的剩余参数"></a>5.2 函数的剩余参数</h3><p>ES6中引用了<code>rest parameter</code>，可以将不定数量的参数放入到一个数组中：</p>
<ul>
<li>如果最后一个参数是 <code>...</code> 为前缀的，那么它会将剩余的参数放到该参数中，并且作为一个数组；</li>
<li>剩余参数必须放到最后一个位置，否则会报错</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">m, n, ...args</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(m, n);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(args);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">arguments</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">foo</span>(<span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>, <span class="number">60</span>);</span><br></pre></td></tr></table></figure>

<p><img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/20241203203550.png" alt="image.png"></p>
<p><span style="color: #badc58; font-weight: 550;">剩余参数和arguments 的区别</span></p>
<p><img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/20241203203636.png" alt="image.png"></p>
<h3 id="5-3-箭头函数"><a href="#5-3-箭头函数" class="headerlink" title="5.3 箭头函数"></a>5.3 箭头函数</h3><ul>
<li><strong>没有 <code>this</code> 绑定</strong>：箭头函数没有自己的 <code>this</code> 绑定，它会捕获其所在上下文的 <code>this</code> 值。</li>
<li><strong>没有 <code>arguments</code> 对象</strong>：箭头函数没有自己的 <code>arguments</code> 对象。在箭头函数内部，<code>arguments</code> 对象不可用。</li>
<li><strong>没有 <code>prototype</code> 属性</strong>：箭头函数没有 <code>prototype</code> 属性，因此不能用作构造函数。</li>
</ul>
<p>箭头函数没有有显式原型，即箭头函数没有自己的 <code>prototype</code> 属性。这导致箭头函数不能用作构造函数，也不能通过 <code>new</code> 关键字来创建对象实例</p>
<p><strong>传统函数</strong>：传统函数有 <code>prototype</code> 属性，可以作为构造函数使用</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"><span class="keyword">const</span> f = <span class="keyword">new</span> <span class="title function_">foo</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(f.<span class="property">__proto__</span> == foo.<span class="property"><span class="keyword">prototype</span></span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p><strong>箭头函数</strong>：箭头函数没有 <code>prototype</code> 属性，不能作为构造函数使用。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title function_">bar</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>, <span class="variable language_">arguments</span>); <span class="comment">// arguments is not defined</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="title function_">bar</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(bar.<span class="property"><span class="keyword">prototype</span></span>); <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> b = <span class="keyword">new</span> <span class="title function_">bar</span>(); <span class="comment">// bar is not a constructor</span></span><br></pre></td></tr></table></figure>

<h2 id="6-展开语法-Spread-syntax"><a href="#6-展开语法-Spread-syntax" class="headerlink" title="6 展开语法(Spread syntax)"></a>6 展开语法(Spread syntax)</h2><ul>
<li>可以在<strong>函数调用/数组构造</strong>时，将数组表达式或者string在语法层面展开；</li>
<li>还可以在<strong>构造字面量对象</strong>时, 将对象表达式按key-value的方式展开；-&gt; ES2018（ES9）中添加的新特性</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> names = [<span class="string">&quot;abc&quot;</span>, <span class="string">&quot;cba&quot;</span>, <span class="string">&quot;nba&quot;</span>]</span><br><span class="line"><span class="keyword">const</span> name = <span class="string">&quot;why&quot;</span></span><br><span class="line"><span class="keyword">const</span> info = &#123;<span class="attr">name</span>: <span class="string">&quot;why&quot;</span>, <span class="attr">age</span>: <span class="number">18</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1.函数调用时</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">x, y, z</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(x, y, z)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// foo.apply(null, names)</span></span><br><span class="line"><span class="title function_">foo</span>(...names)</span><br><span class="line"><span class="title function_">foo</span>(...name)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.构造数组时</span></span><br><span class="line"><span class="keyword">const</span> newNames = [...names, ...name]</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(newNames)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.构建对象字面量时ES2018(ES9)</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123; ...info, <span class="attr">address</span>: <span class="string">&quot;广州市&quot;</span>, ...names &#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj)</span><br></pre></td></tr></table></figure>

<p><img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/20241203205412.png" alt="image.png"></p>
<p><span style="color: #9c88ff; font-weight: 550;">展开运算符其实是一种浅拷贝</span></p>
<p><span style="color: #badc58; font-weight: 550;">浅拷贝（Shallow Copy）</span></p>
<ul>
<li><strong>定义</strong>：浅拷贝创建一个新的对象，然后将原始对象的属性复制到新对象中。如果属性是基本数据类型（如字符串、数字、布尔值等），则直接复制其值；如果属性是引用数据类型（如对象、数组等），则复制引用（即指向同一内存地址）。</li>
<li><strong>特点</strong>：修改新对象中的引用数据类型会影响原始对象中的相应部分。</li>
</ul>
<p><span style="color: #badc58; font-weight: 550;">深拷贝（Deep Copy）</span></p>
<ul>
<li><strong>定义</strong>：深拷贝创建一个新的对象，并递归地将原始对象的所有属性复制到新对象中。无论是基本数据类型还是引用数据类型，都会创建新的副本。</li>
<li><strong>特点</strong>：修改新对象中的任何部分都不会影响原始对象。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> info = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;why&#x27;</span>,</span><br><span class="line">  <span class="attr">friend</span>: &#123; <span class="attr">name</span>: <span class="string">&#x27;kobe&#x27;</span> &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj = &#123; ...info, <span class="attr">name</span>: <span class="string">&#x27;coderwhy&#x27;</span> &#125;;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj);</span><br><span class="line"></span><br><span class="line">obj.<span class="property">friend</span>.<span class="property">name</span> = <span class="string">&#x27;james&#x27;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">friend</span>.<span class="property">name</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(info.<span class="property">friend</span>.<span class="property">name</span>);</span><br></pre></td></tr></table></figure>

<p><img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/20241203205620.png" alt="image.png"></p>
<h2 id="7-数值的表示"><a href="#7-数值的表示" class="headerlink" title="7 数值的表示"></a>7 数值的表示</h2><p>在ES6中规范了二进制和八进制的写法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> num1 = <span class="number">100</span> <span class="comment">// 十进制</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// b -&gt; binary</span></span><br><span class="line"><span class="keyword">const</span> num2 = <span class="number">0b100</span> <span class="comment">// 二进制</span></span><br><span class="line"><span class="comment">// o -&gt; octonary</span></span><br><span class="line"><span class="keyword">const</span> num3 = <span class="number">0o100</span> <span class="comment">// 八进制</span></span><br><span class="line"><span class="comment">// x -&gt; hexadecimal</span></span><br><span class="line"><span class="keyword">const</span> num4 = <span class="number">0x100</span> <span class="comment">// 十六进制</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(num1, num2, num3, num4)</span><br></pre></td></tr></table></figure>

<p>另外在ES2021新增特性：数字过长时，可以使用_作为连接符，方便阅读</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 大的数值的连接符(ES2021 ES12)</span></span><br><span class="line"><span class="keyword">const</span> num = <span class="number">10_000_000_000_000_000</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(num)</span><br></pre></td></tr></table></figure>

<h2 id="8-Symbol"><a href="#8-Symbol" class="headerlink" title="8 Symbol"></a>8 Symbol</h2><blockquote>
<p>ES6 引入了 <code>Symbol</code> 类型，这是一种新的原始数据类型，表示唯一的、不可变的值。<code>Symbol</code> 主要用于创建对象的唯一属性键，避免属性名冲突。</p>
</blockquote>
<p><img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/20241203213255.png" alt="image.png"></p>
<h3 id="8-1-创建-Symbol"><a href="#8-1-创建-Symbol" class="headerlink" title="8.1 创建 Symbol"></a>8.1 创建 Symbol</h3><p>使用 Symbol() 函数创建一个新的 Symbol 值。每个 Symbol 值都是唯一的。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> sym1 = <span class="title class_">Symbol</span>();</span><br><span class="line"><span class="keyword">const</span> sym2 = <span class="title class_">Symbol</span>();</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(sym1 === sym2); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<h3 id="8-2-添加描述"><a href="#8-2-添加描述" class="headerlink" title="8.2 添加描述"></a>8.2 添加描述</h3><p>为了调试和识别，可以给 Symbol 添加一个可选的描述。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> symWithDesc = <span class="title class_">Symbol</span>(<span class="string">&#x27;des&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(symWithDesc.<span class="property">description</span>); <span class="comment">// &quot;des&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(symWithDesc.<span class="title function_">toString</span>()); <span class="comment">// &quot;Symbol(des)&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="8-3-作为对象属性"><a href="#8-3-作为对象属性" class="headerlink" title="8.3 作为对象属性"></a>8.3 作为对象属性</h3><p>Symbol 常用于创建对象的唯一属性键，避免与其他属性名冲突。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.在定义对象字面量时使用</span></span><br><span class="line"><span class="keyword">const</span> s1 = <span class="title class_">Symbol</span>(<span class="string">&#x27;key1&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  [s1]: <span class="string">&#x27;value1&#x27;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.新增属性</span></span><br><span class="line"><span class="keyword">const</span> s2 = <span class="title class_">Symbol</span>(<span class="string">&#x27;key2&#x27;</span>);</span><br><span class="line">obj[s2] = <span class="string">&quot;value2&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.Object.defineProperty方式</span></span><br><span class="line"><span class="keyword">const</span> s3 = <span class="title class_">Symbol</span>(<span class="string">&#x27;key3&#x27;</span>)</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(obj, s3, &#123;</span><br><span class="line">  <span class="attr">enumerable</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">configurable</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">writable</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">value</span>: <span class="string">&quot;value3&quot;</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj[s1], obj[s2], obj[s3]); <span class="comment">// value1 value2 value3</span></span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>：不能通过<code>.</code>语法获取</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">s1</span>)</span><br></pre></td></tr></table></figure>

<h3 id="8-4-获取所有Symbol的key"><a href="#8-4-获取所有Symbol的key" class="headerlink" title="8.4 获取所有Symbol的key"></a>8.4 获取所有Symbol的key</h3><p>使用<code>Symbol</code>作为<code>key</code>的属性名,在<code>遍历/Object.keys</code>等中是获取不到这些<code>Symbol</code>值</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">keys</span>(obj)) <span class="comment">// []</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">getOwnPropertyNames</span>(obj)) <span class="comment">// []</span></span><br></pre></td></tr></table></figure>

<p>需要<code>Object.getOwnPropertySymbols</code>来获取所有<code>Symbol</code>的<code>key</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">getOwnPropertySymbols</span>(obj)) </span><br><span class="line"><span class="keyword">const</span> sKeys = <span class="title class_">Object</span>.<span class="title function_">getOwnPropertySymbols</span>(obj)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> sKey <span class="keyword">of</span> sKeys) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(obj[sKey])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/20241203214316.png" alt="image.png"></p>
<h3 id="8-5-全局-Symbol-注册表"><a href="#8-5-全局-Symbol-注册表" class="headerlink" title="8.5 全局 Symbol 注册表"></a>8.5 全局 Symbol 注册表</h3><p>使用 <code>Symbol.for(key)</code> 方法可以在全局 Symbol 注册表中创建或检索 Symbol。</p>
<p>具有相同键的 Symbol 是相同的。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> sym1 = <span class="title class_">Symbol</span>.<span class="title function_">for</span>(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> sym2 = <span class="title class_">Symbol</span>.<span class="title function_">for</span>(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(sym1 === sym2); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>获取 Symbol 描述</p>
<p>使用 <code>Symbol.keyFor(symbol)</code> 方法可以从全局注册表中获取 Symbol 的描述。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> sym = <span class="title class_">Symbol</span>.<span class="title function_">for</span>(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Symbol</span>.<span class="title function_">keyFor</span>(sym)); <span class="comment">// &quot;foo&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> localSym = <span class="title class_">Symbol</span>(<span class="string">&#x27;bar&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Symbol</span>.<span class="title function_">keyFor</span>(localSym)); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>

<h3 id="8-6-内置-Symbol"><a href="#8-6-内置-Symbol" class="headerlink" title="8.6 内置 Symbol"></a>8.6 内置 Symbol</h3><p>ES6 提供了一些内置的 Symbol 值，用于定义对象的行为，例如 <code>Symbol.iterator</code>、<code>Symbol.toStringTag</code> 等。</p>
<h4 id="8-6-1-Symbol-toStringTag"><a href="#8-6-1-Symbol-toStringTag" class="headerlink" title="8.6.1 Symbol.toStringTag"></a>8.6.1 <code>Symbol.toStringTag</code></h4><ul>
<li><strong>用途</strong>：<code>Symbol.toStringTag</code> 用于定义对象的默认字符串描述，通常在调用 <code>Object.prototype.toString.call(obj)</code> 时返回。</li>
<li><strong>作用</strong>：帮助开发者更容易地识别对象的类型，特别是在自定义对象时。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  [<span class="title class_">Symbol</span>.<span class="property">toStringTag</span>]: <span class="string">&#x27;MyObject&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="title function_">toString</span>()); <span class="comment">// &quot;[object MyObject]&quot;</span></span><br></pre></td></tr></table></figure>

<p>在这个示例中，<code>obj</code> 对象的 <code>toString</code> 方法返回 <code>&quot;[object MyObject]&quot;</code>，而不是默认的 <code>&quot;[object Object]&quot;</code>。</p>
<h4 id="8-6-2-Symbol-iterator"><a href="#8-6-2-Symbol-iterator" class="headerlink" title="8.6.2 Symbol.iterator"></a>8.6.2 <code>Symbol.iterator</code></h4><ul>
<li><strong>用途</strong>：<code>Symbol.iterator</code> 定义了对象的默认迭代器，使得对象可以使用 <code>for...of</code> 循环或其他迭代机制进行遍历。</li>
<li><strong>作用</strong>：允许自定义对象实现可迭代协议，使其能够被 <code>for...of</code> 循环等迭代器消费。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> myIterable = &#123;</span><br><span class="line">  [<span class="title class_">Symbol</span>.<span class="property">iterator</span>]() &#123;</span><br><span class="line">    <span class="keyword">let</span> step = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">const</span> iterator = &#123;</span><br><span class="line">      <span class="title function_">next</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (step &lt; <span class="number">5</span>) &#123;</span><br><span class="line">          step++;</span><br><span class="line">          <span class="keyword">return</span> &#123; <span class="attr">value</span>: step, <span class="attr">done</span>: <span class="literal">false</span> &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123; <span class="attr">value</span>: <span class="literal">undefined</span>, <span class="attr">done</span>: <span class="literal">true</span> &#125;;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> iterator;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> num <span class="keyword">of</span> myIterable) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(num); <span class="comment">// 输出: 1, 2, 3, 4, 5</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，<code>myIterable</code> 对象实现了 <code>Symbol.iterator</code> 方法，使其可以被 <code>for...of</code> 循环遍历，每次迭代返回一个从 1 到 5 的数值。</p>
<h2 id="9-Set"><a href="#9-Set" class="headerlink" title="9 Set"></a>9 Set</h2><h3 id="9-1-set-的基础使用"><a href="#9-1-set-的基础使用" class="headerlink" title="9.1 set 的基础使用"></a>9.1 set 的基础使用</h3><ul>
<li><strong>数组</strong>：数组是一种线性数据结构，可以存储任意类型的值，并且允许重复的值。</li>
<li><strong>Set</strong>：Set 是一种集合数据结构，只能存储唯一的值，<strong>不允许重复的值</strong></li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> set = <span class="keyword">new</span> <span class="title class_">Set</span>();</span><br><span class="line">set.<span class="title function_">add</span>(<span class="number">10</span>);</span><br><span class="line">set.<span class="title function_">add</span>(<span class="number">20</span>);</span><br><span class="line">set.<span class="title function_">add</span>(<span class="number">40</span>);</span><br><span class="line">set.<span class="title function_">add</span>(<span class="number">333</span>);</span><br><span class="line">set.<span class="title function_">add</span>(<span class="number">10</span>); <span class="comment">// 重复的值不会被添加</span></span><br></pre></td></tr></table></figure>

<p><img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/20241204180420.png" alt="image.png"></p>
<p><span style="color: #badc58; font-weight: 550;">添加对象时特别注意</span></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 添加的对象的引用地址不同</span></span><br><span class="line">set.<span class="title function_">add</span>(&#123;&#125;);</span><br><span class="line">set.<span class="title function_">add</span>(&#123;&#125;); <span class="comment">// 每个对象都是不同的实例，所以会被添加两次</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加的对象的引用地址相同</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123;&#125;;</span><br><span class="line">set.<span class="title function_">add</span>(obj);</span><br><span class="line">set.<span class="title function_">add</span>(obj); <span class="comment">// 同一个对象实例，不会被重复添加</span></span><br></pre></td></tr></table></figure>

<p><span style="color: #badc58; font-weight: 550;"> 对数组去重</span></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">33</span>, <span class="number">10</span>, <span class="number">26</span>, <span class="number">30</span>, <span class="number">33</span>, <span class="number">26</span>];</span><br><span class="line"><span class="keyword">const</span> arrSet = <span class="keyword">new</span> <span class="title class_">Set</span>(arr);</span><br><span class="line"><span class="keyword">const</span> newArr = [...arrSet]; <span class="comment">// 使用扩展运算符将 Set 转换为数组</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(newArr); <span class="comment">// 输出: [33, 10, 26, 30]</span></span><br></pre></td></tr></table></figure>

<h3 id="9-2-set-的方法"><a href="#9-2-set-的方法" class="headerlink" title="9.2 set 的方法"></a>9.2 set 的方法</h3><p><img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/20241204181214.png" alt="image.png"></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">arrSet.<span class="title function_">add</span>(<span class="number">100</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arrSet); <span class="comment">// 输出: Set &#123; 33, 10, 26, 30, 100 &#125;</span></span><br><span class="line"></span><br><span class="line">arrSet.<span class="title function_">delete</span>(<span class="number">33</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arrSet); <span class="comment">// 输出: Set &#123; 10, 26, 30, 100 &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arrSet.<span class="title function_">has</span>(<span class="number">100</span>)); <span class="comment">// 输出: true</span></span><br><span class="line"></span><br><span class="line">arrSet.<span class="title function_">clear</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arrSet); <span class="comment">// 输出: Set(0) &#123;&#125;</span></span><br></pre></td></tr></table></figure>

<p><span style="color: #badc58; font-weight: 550;">对 Set 进行遍历</span></p>
<ul>
<li><strong>forEach</strong>: 遍历 Set 中的每个元素</li>
<li><strong>for…of</strong>: 遍历 Set 中的每个元素</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">arrSet.<span class="title function_">forEach</span>(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(item);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> item <span class="keyword">of</span> arrSet) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(item);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="10-WeakSet"><a href="#10-WeakSet" class="headerlink" title="10 WeakSet"></a>10 WeakSet</h2><blockquote>
<p>和Set类似的另外一个数据结构称之为WeakSet，也是内部元素不能重复的数据结构</p>
</blockquote>
<h3 id="10-1-WeakSet-和-Set-的区别"><a href="#10-1-WeakSet-和-Set-的区别" class="headerlink" title="10.1 WeakSet 和 Set 的区别"></a>10.1 WeakSet 和 Set 的区别</h3><p>1、区别一：WeakSet中只能存放对象类型，<strong>不能存放基本数据类型</strong>；</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> weakSet = <span class="keyword">new</span> <span class="title class_">WeakSet</span>()</span><br><span class="line">weakSet.<span class="title function_">add</span>(<span class="number">10</span>) <span class="comment">// TypeError: Invalid value used in weak set</span></span><br></pre></td></tr></table></figure>

<p>2、区别二：WeakSet对元素的引用是<strong>弱引用</strong>，如果没有其他引用对某个对象进行引用，那么GC可以对该对象进行回收；</p>
<ul>
<li><strong>强引用</strong>：当一个对象被强引用时，垃圾回收器不会回收这个对象，即使内存不足也不会回收。只要存在强引用，对象就会一直存在于内存中。</li>
<li><strong>弱引用</strong>：当一个对象只被弱引用时，垃圾回收器在下一次运行时会回收这个对象，即使内存充足也会回收。弱引用不会阻止对象被垃圾回收。</li>
</ul>
<p><span style="color: #badc58; font-weight: 550;">垃圾回收机制</span></p>
<ul>
<li><strong>强引用</strong>：垃圾回收器在进行垃圾回收时，会检查对象是否有强引用。如果有强引用，对象不会被回收。</li>
<li><strong>弱引用</strong>：垃圾回收器在进行垃圾回收时，会检查对象是否有弱引用。如果有弱引用且没有其他强引用，对象会被回收。</li>
</ul>
<p><span style="color: #badc58; font-weight: 550;">使用场景</span></p>
<ul>
<li><strong>强引用</strong>：适用于需要长时间保留的对象，确保对象在内存中不被回收。</li>
<li><strong>弱引用</strong>：适用于临时对象或缓存对象，这些对象在不再需要时可以被垃圾回收器回收，从而释放内存。</li>
</ul>
<p>强引用</p>
<p><code>set.add(obj)</code>保存的是 <code>obj</code>的内存地址</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> set = <span class="keyword">new</span> <span class="title class_">Set</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">name</span>: <span class="string">&quot;why&quot;</span> &#125;;</span><br><span class="line">set.<span class="title function_">add</span>(obj);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 建立的是强引用</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(set); <span class="comment">// 输出: Set &#123; &#123; name: &#x27;why&#x27; &#125; &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 即使 obj 被设置为 null，set 中的对象仍然存在</span></span><br><span class="line">obj = <span class="literal">null</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(set); <span class="comment">// 输出: Set &#123; &#123; name: &#x27;why&#x27; &#125; &#125;</span></span><br></pre></td></tr></table></figure>

<p><img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/20241204182613.png" alt="image.png"></p>
<p>弱引用</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> weakSet = <span class="keyword">new</span> <span class="title class_">WeakSet</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">name</span>: <span class="string">&quot;why&quot;</span> &#125;;</span><br><span class="line">weakSet.<span class="title function_">add</span>(obj);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 建立的是弱引用</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(weakSet); <span class="comment">// 输出: WeakSet &#123; &#123; name: &#x27;why&#x27; &#125; &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 当 obj 被设置为 null 时，weakSet 中的对象可能会被垃圾回收</span></span><br><span class="line">obj = <span class="literal">null</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(weakSet); <span class="comment">// 输出: WeakSet &#123;&#125; (如果垃圾回收已经执行)</span></span><br></pre></td></tr></table></figure>

<h3 id="10-2-WeakSet常见的方法"><a href="#10-2-WeakSet常见的方法" class="headerlink" title="10.2 WeakSet常见的方法"></a>10.2 WeakSet常见的方法</h3><p>没有 <code>clear</code></p>
<p><img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/20241204182810.png" alt="image.png"></p>
<p>不能遍历</p>
<p><img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/20241204182856.png" alt="image.png"></p>
<h3 id="10-3-WeakSet的应用场景"><a href="#10-3-WeakSet的应用场景" class="headerlink" title="10.3 WeakSet的应用场景"></a>10.3 WeakSet的应用场景</h3><ul>
<li><strong>缓存</strong>：可以使用 <code>WeakMap</code> 来实现缓存，当缓存对象不再被其他地方引用时，可以自动被垃圾回收。</li>
<li><strong>事件监听器</strong>：可以使用 <code>WeakSet</code> 来管理事件监听器，避免内存泄漏。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="title function_">running</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;running~&#x27;</span>, <span class="variable language_">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line"></span><br><span class="line">p.<span class="title function_">running</span>();  <span class="comment">// running~ Person &#123;&#125;</span></span><br><span class="line">p.<span class="property">running</span>.<span class="title function_">call</span>(&#123; <span class="attr">name</span>: <span class="string">&#x27;why&#x27;</span> &#125;); <span class="comment">// running~ &#123; name: &#x27;why&#x27; &#125;</span></span><br></pre></td></tr></table></figure>

<p>不想让通过非构造方法创建出来的对象调用<code>running</code>方法</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> personSet = <span class="keyword">new</span> <span class="title class_">WeakSet</span>();</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    personSet.<span class="title function_">add</span>(<span class="variable language_">this</span>); <span class="comment">// 每次构造实例时都加入到personSet集合中</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">running</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!personSet.<span class="title function_">has</span>(<span class="variable language_">this</span>)) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;不能通过非构造方法创建出来的对象调用running方法&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;running~&#x27;</span>, <span class="variable language_">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">p.<span class="title function_">running</span>();</span><br><span class="line">p.<span class="property">running</span>.<span class="title function_">call</span>(&#123; <span class="attr">name</span>: <span class="string">&#x27;why&#x27;</span> &#125;);</span><br></pre></td></tr></table></figure>

<p>若将 <code>p</code> 设置为 <code>null</code>，这意味着 <code>p</code> 不再引用原来的 <code>Person</code> 实例。由于 <code>WeakSet</code> 中的引用是弱引用，如果这个 <code>Person</code> 实例没有其他强引用，它可能会被垃圾回收器回收。</p>
<h2 id="11-Map"><a href="#11-Map" class="headerlink" title="11 Map"></a>11 Map</h2><blockquote>
<p>用于存储映射关系，即键值对</p>
</blockquote>
<h3 id="11-1-Map-和对象的区别"><a href="#11-1-Map-和对象的区别" class="headerlink" title="11.1 Map 和对象的区别"></a>11.1 Map 和对象的区别</h3><h4 id="11-1-1-键的类型"><a href="#11-1-1-键的类型" class="headerlink" title="11.1.1 键的类型"></a>11.1.1 键的类型</h4><ul>
<li><strong>对象</strong>：JavaScript 对象的键只能是<strong>字符串或符号（Symbol）</strong>。如果尝试使用其他类型的值（如数字或对象）作为键，它们会被隐式转换为字符串。</li>
<li><strong>Map</strong>：Map 的键可以是<strong>任何类型的值</strong>，包括对象、函数、基本数据类型等。</li>
</ul>
<h4 id="11-1-2-键的唯一性"><a href="#11-1-2-键的唯一性" class="headerlink" title="11.1.2 键的唯一性"></a>11.1.2 键的唯一性</h4><ul>
<li><strong>对象</strong>：虽然对象的键是唯一的，但由于键会被隐式转换为字符串，可能会导致意外的行为。例如，<code>&#123; [1]: &#39;a&#39;, [&#39;1&#39;]: &#39;b&#39; &#125;</code> 会覆盖键 <code>1</code> 的值。</li>
<li><strong>Map</strong>：Map 的键是严格唯一的，不会发生隐式转换，因此不会出现键冲突的问题。</li>
</ul>
<h4 id="11-1-3-动态大小"><a href="#11-1-3-动态大小" class="headerlink" title="11.1.3 动态大小"></a>11.1.3 动态大小</h4><ul>
<li><strong>对象</strong>：对象的大小是动态的，可以随时添加或删除属性。</li>
<li><strong>Map</strong>：Map 也有动态大小，可以随时添加或删除键值对。</li>
</ul>
<h4 id="11-1-4-内置方法"><a href="#11-1-4-内置方法" class="headerlink" title="11.1.4 内置方法"></a>11.1.4 内置方法</h4><ul>
<li><strong>对象</strong>：对象没有内置的方法来操作键值对，通常需要使用 <code>Object.keys</code>、<code>Object.values</code>、<code>Object.entries</code> 等方法。</li>
<li><strong>Map</strong>：Map 提供了丰富的内置方法，如 <code>set</code>、<code>get</code>、<code>has</code>、<code>delete</code>、<code>clear</code>、<code>size</code> 等，方便操作键值对。</li>
</ul>
<h4 id="11-1-5-遍历"><a href="#11-1-5-遍历" class="headerlink" title="11.1.5 遍历"></a>11.1.5 遍历</h4><ul>
<li><strong>对象</strong>：遍历对象的键值对通常使用 <code>for...in</code> 循环或 <code>Object.keys</code>、<code>Object.values</code>、<code>Object.entries</code> 方法。</li>
<li><strong>Map</strong>：Map 提供了多种遍历方法，如 <code>forEach</code>、<code>for...of</code> 循环等，可以直接遍历键值对。</li>
</ul>
<h4 id="11-1-6-性能"><a href="#11-1-6-性能" class="headerlink" title="11.1.6 性能"></a>11.1.6 性能</h4><ul>
<li><strong>对象</strong>：对象在查找、添加和删除键值对时性能较低，特别是对于大型对象，因为需要遍历整个对象。</li>
<li><strong>Map</strong>：Map 在查找、添加和删除键值对时性能较高，因为<strong>内部使用哈希表实现</strong>，平均时间复杂度为 O(1)。</li>
</ul>
<h3 id="11-2-Map-的常用方法"><a href="#11-2-Map-的常用方法" class="headerlink" title="11.2 Map 的常用方法"></a>11.2 Map 的常用方法</h3><p><img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/20241204184455.png" alt="image.png"></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj1 = &#123; <span class="attr">name</span>: <span class="string">&quot;why&quot;</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> obj2 = &#123; <span class="attr">name</span>: <span class="string">&quot;kobe&quot;</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line">map.<span class="title function_">set</span>(obj1, <span class="string">&quot;aaa&quot;</span>);</span><br><span class="line">map.<span class="title function_">set</span>(obj2, <span class="string">&quot;bbb&quot;</span>);</span><br><span class="line">map.<span class="title function_">set</span>(<span class="number">1</span>, <span class="string">&quot;ccc&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(map); <span class="comment">// 输出: Map(3) &#123; &#123; name: &#x27;why&#x27; &#125; =&gt; &#x27;aaa&#x27;, &#123; name: &#x27;kobe&#x27; &#125; =&gt; &#x27;bbb&#x27;, 1 =&gt; &#x27;ccc&#x27; &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> map2 = <span class="keyword">new</span> <span class="title class_">Map</span>([[obj1, <span class="string">&quot;aaa&quot;</span>], [obj2, <span class="string">&quot;bbb&quot;</span>], [<span class="number">2</span>, <span class="string">&quot;ddd&quot;</span>]]);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(map2); <span class="comment">// 输出: Map(3) &#123; &#123; name: &#x27;why&#x27; &#125; =&gt; &#x27;aaa&#x27;, &#123; name: &#x27;kobe&#x27; &#125; =&gt; &#x27;bbb&#x27;, 2 =&gt; &#x27;ddd&#x27; &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(map2.<span class="property">size</span>); <span class="comment">// 输出: 3</span></span><br><span class="line"></span><br><span class="line">map2.<span class="title function_">set</span>(<span class="string">&quot;why&quot;</span>, <span class="string">&quot;eee&quot;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(map2); <span class="comment">// 输出: Map(4) &#123; &#123; name: &#x27;why&#x27; &#125; =&gt; &#x27;aaa&#x27;, &#123; name: &#x27;kobe&#x27; &#125; =&gt; &#x27;bbb&#x27;, 2 =&gt; &#x27;ddd&#x27;, &#x27;why&#x27; =&gt; &#x27;eee&#x27; &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(map2.<span class="title function_">get</span>(<span class="string">&quot;why&quot;</span>)); <span class="comment">// 输出: eee</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(map2.<span class="title function_">has</span>(<span class="string">&quot;why&quot;</span>)); <span class="comment">// 输出: true</span></span><br><span class="line"></span><br><span class="line">map2.<span class="title function_">delete</span>(<span class="string">&quot;why&quot;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(map2); <span class="comment">// 输出: Map(3) &#123; &#123; name: &#x27;why&#x27; &#125; =&gt; &#x27;aaa&#x27;, &#123; name: &#x27;kobe&#x27; &#125; =&gt; &#x27;bbb&#x27;, 2 =&gt; &#x27;ddd&#x27; &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// map2.clear();</span></span><br><span class="line"><span class="comment">// console.log(map2); // 输出: Map(0) &#123;&#125;</span></span><br><span class="line"></span><br><span class="line">map2.<span class="title function_">forEach</span>(<span class="function">(<span class="params">value, key</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(value, key);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> [key, value] <span class="keyword">of</span> map2) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(key, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="12-WeakMap"><a href="#12-WeakMap" class="headerlink" title="12 WeakMap"></a>12 WeakMap</h2><blockquote>
<p>和Map类型相似的另外一个数据结构称之为WeakMap，也是以键值对的形式存在的</p>
</blockquote>
<h3 id="12-1-WeakMap-和-Map-的区别"><a href="#12-1-WeakMap-和-Map-的区别" class="headerlink" title="12.1 WeakMap 和 Map 的区别"></a>12.1 WeakMap 和 Map 的区别</h3><h4 id="12-1-1-键的类型"><a href="#12-1-1-键的类型" class="headerlink" title="12.1.1 键的类型"></a>12.1.1 键的类型</h4><ul>
<li><strong>Map</strong>：键可以是任何类型的值，包括对象、函数、基本数据类型等。</li>
<li><strong>WeakMap</strong>：键必须是对象。不允许使用基本数据类型（如字符串、数字、布尔值等）作为键。</li>
</ul>
<h4 id="12-1-2-引用类型"><a href="#12-1-2-引用类型" class="headerlink" title="12.1.2 引用类型"></a>12.1.2 引用类型</h4><ul>
<li><strong>Map</strong>：键和值都是强引用。只要键或值在 <code>Map</code> 中，它们就不会被垃圾回收器回收。</li>
<li><strong>WeakMap</strong>：键是弱引用，值是强引用。如果键对象没有其他强引用，垃圾回收器可以回收该键对象，同时也会从 <code>WeakMap</code> 中移除对应的键值对。</li>
</ul>
<h4 id="12-1-3-大小和迭代"><a href="#12-1-3-大小和迭代" class="headerlink" title="12.1.3 大小和迭代"></a>12.1.3 大小和迭代</h4><ul>
<li><strong>Map</strong>：提供了 <code>size</code> 属性和多种迭代方法（如 <code>forEach</code>、<code>for...of</code> 等），可以获取 <code>Map</code> 的大小并遍历键值对。</li>
<li><strong>WeakMap</strong>：没有 <code>size</code> 属性，也没有提供迭代方法。无法直接获取 <code>WeakMap</code> 的大小或遍历其键值对。</li>
</ul>
<h3 id="12-2-WeakMap常见的方法"><a href="#12-2-WeakMap常见的方法" class="headerlink" title="12.2 WeakMap常见的方法"></a>12.2 WeakMap常见的方法</h3><p><img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/20241204184939.png" alt="image.png"></p>
<h3 id="12-3-WeakMap的应用场景"><a href="#12-3-WeakMap的应用场景" class="headerlink" title="12.3 WeakMap的应用场景"></a>12.3 WeakMap的应用场景</h3><h4 id="12-3-1-响应式系统（如-Vue-3）"><a href="#12-3-1-响应式系统（如-Vue-3）" class="headerlink" title="12.3.1 响应式系统（如 Vue 3）"></a>12.3.1 响应式系统（如 Vue 3）</h4><p>在现代前端框架中，响应式系统是一个核心特性。Vue 3 使用 <code>Proxy</code> 和 <code>WeakMap</code> 来实现响应式数据绑定。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 应用场景(vue3响应式原理)</span></span><br><span class="line"><span class="keyword">const</span> obj1 = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;why&quot;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">18</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">obj1NameFn1</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;obj1NameFn1被执行&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">obj1NameFn2</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;obj1NameFn2被执行&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">obj1AgeFn1</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;obj1AgeFn1&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">obj1AgeFn2</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;obj1AgeFn2&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj2 = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;kobe&quot;</span>,</span><br><span class="line">  <span class="attr">height</span>: <span class="number">1.88</span>,</span><br><span class="line">  <span class="attr">address</span>: <span class="string">&quot;广州市&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">obj2NameFn1</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;obj2NameFn1被执行&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">obj2NameFn2</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;obj2NameFn2被执行&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1.创建WeakMap</span></span><br><span class="line"><span class="keyword">const</span> weakMap = <span class="keyword">new</span> <span class="title class_">WeakMap</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.收集依赖结构</span></span><br><span class="line"><span class="comment">// 2.1.对obj1收集的数据结构</span></span><br><span class="line"><span class="keyword">const</span> obj1Map = <span class="keyword">new</span> <span class="title class_">Map</span>()</span><br><span class="line">obj1Map.<span class="title function_">set</span>(<span class="string">&quot;name&quot;</span>, [obj1NameFn1, obj1NameFn2])</span><br><span class="line">obj1Map.<span class="title function_">set</span>(<span class="string">&quot;age&quot;</span>, [obj1AgeFn1, obj1AgeFn2])</span><br><span class="line">weakMap.<span class="title function_">set</span>(obj1, obj1Map)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.2.对obj2收集的数据结构</span></span><br><span class="line"><span class="keyword">const</span> obj2Map = <span class="keyword">new</span> <span class="title class_">Map</span>()</span><br><span class="line">obj2Map.<span class="title function_">set</span>(<span class="string">&quot;name&quot;</span>, [obj2NameFn1, obj2NameFn2])</span><br><span class="line">weakMap.<span class="title function_">set</span>(obj2, obj2Map)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.如果obj1.name发生了改变</span></span><br><span class="line"><span class="comment">// Proxy/Object.defineProperty</span></span><br><span class="line">obj1.<span class="property">name</span> = <span class="string">&quot;james&quot;</span></span><br><span class="line"><span class="keyword">const</span> targetMap = weakMap.<span class="title function_">get</span>(obj1)</span><br><span class="line"><span class="keyword">const</span> fns = targetMap.<span class="title function_">get</span>(<span class="string">&quot;name&quot;</span>)</span><br><span class="line">fns.<span class="title function_">forEach</span>(<span class="function"><span class="params">item</span> =&gt;</span> <span class="title function_">item</span>())</span><br></pre></td></tr></table></figure>

<p><img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/20241204190238.png" alt="image.png"></p>
<ol>
<li><strong>创建对象和依赖函数</strong><ul>
<li><code>obj1</code> 和 <code>obj2</code> 是两个需要响应式的对象。</li>
<li><code>obj1NameFn1</code>、<code>obj1NameFn2</code>、<code>obj1AgeFn1</code>、<code>obj1AgeFn2</code> 等是当对象属性发生变化时需要执行的函数。</li>
</ul>
</li>
<li><strong>创建 <code>WeakMap</code></strong><ul>
<li><code>weakMap</code> 用于存储对象及其依赖关系。</li>
</ul>
</li>
<li><strong>收集依赖结构</strong><ul>
<li>对于 <code>obj1</code>，创建一个 <code>Map</code> (<code>obj1Map</code>)，其中键是对象的属性名，值是依赖函数的数组。</li>
<li>将 <code>obj1Map</code> 存储到 <code>weakMap</code> 中，键是 <code>obj1</code>。</li>
<li>同样地，对 <code>obj2</code> 进行类似的操作。</li>
</ul>
</li>
<li><strong>属性变化时触发依赖函数</strong><ul>
<li>当 <code>obj1.name</code> 发生变化时，从 <code>weakMap</code> 中获取 <code>obj1</code> 对应的 <code>Map</code> (<code>targetMap</code>)。</li>
<li>从 <code>targetMap</code> 中获取 <code>name</code> 属性对应的依赖函数数组 (<code>fns</code>)。</li>
<li>遍历 <code>fns</code> 数组，执行每个依赖函数。</li>
</ul>
</li>
</ol>
<p><span style="color: #badc58; font-weight: 550;">为什么使用 WeakMap？</span></p>
<ol>
<li><strong>内存管理</strong><ul>
<li><code>WeakMap</code> 的键是弱引用，这意味着如果某个对象没有其他强引用，垃圾回收器可以回收该对象，同时也会从 <code>WeakMap</code> 中移除对应的键值对。这有助于避免内存泄漏。</li>
</ul>
</li>
<li><strong>私有数据</strong><ul>
<li><code>WeakMap</code> 不能被遍历，也不能获取其大小，这使得它可以用来存储私有数据，避免外部直接访问和修改。</li>
</ul>
</li>
<li><strong>对象关联</strong><ul>
<li><code>WeakMap</code> 适用于需要将数据与特定对象关联的场景，特别是当这些对象可能会被垃圾回收时。</li>
</ul>
</li>
</ol>
<h4 id="12-3-2-其他应用场景"><a href="#12-3-2-其他应用场景" class="headerlink" title="12.3.2 其他应用场景"></a>12.3.2 其他应用场景</h4><ol>
<li><strong>缓存</strong><ul>
<li>使用 <code>WeakMap</code> 实现缓存，当缓存的对象被垃圾回收时，缓存条目也会自动清除。</li>
</ul>
</li>
<li><strong>元数据存储</strong><ul>
<li>为对象存储元数据，这些元数据在对象被垃圾回收时自动清除。</li>
</ul>
</li>
<li><strong>事件监听</strong><ul>
<li>为对象添加事件监听器，当对象被垃圾回收时，监听器也会自动清除。</li>
</ul>
</li>
</ol>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://VernalScenery.github.io">Scenery</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://vernalscenery.github.io/2024/12/02/JS/07_JSLearn_ES6%E4%B8%AD%E7%9A%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/">https://vernalscenery.github.io/2024/12/02/JS/07_JSLearn_ES6%E4%B8%AD%E7%9A%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://VernalScenery.github.io" target="_blank">春和景明的记事本</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/JS/">JS</a></div><div class="post_share"><div class="social-share" data-image="/./img/1.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2024/12/04/JS/08_JSLearn_ES7~ES12/" title="08_JSLearn_ES7~ES12"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">08_JSLearn_ES7~ES12</div></div></a></div><div class="next-post pull-right"><a href="/2024/11/29/JS/06_JSLearn_ES6%E4%B8%AD%E7%B1%BB%E7%9A%84%E4%BD%BF%E7%94%A8/" title="06_JSLearn_ES6中类的使用"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">06_JSLearn_ES6中类的使用</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2024/11/15/JS/00_JSLearn_%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E5%92%8Cv8%E5%BC%95%E6%93%8E/" title="00_JSLearn_浏览器工作原理和v8引擎"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-11-15</div><div class="title">00_JSLearn_浏览器工作原理和v8引擎</div></div></a></div><div><a href="/2024/11/15/JS/04_JSLearn_%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/" title="04_JSLearn_函数式编程"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-11-15</div><div class="title">04_JSLearn_函数式编程</div></div></a></div><div><a href="/2024/11/13/JS/03_JSLearn_%E5%87%BD%E6%95%B0%E7%9A%84this%E3%80%81arguments/" title="03_JSLearn_函数的this、arguments"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-11-13</div><div class="title">03_JSLearn_函数的this、arguments</div></div></a></div><div><a href="/2024/11/07/JS/02_JSLearn_JS%E7%9A%84%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E5%92%8C%E9%97%AD%E5%8C%85/" title="02_JSLearn_JS的内存管理和闭包"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-11-07</div><div class="title">02_JSLearn_JS的内存管理和闭包</div></div></a></div><div><a href="/2024/11/15/JS/01_JSLearn_JavaScript%E7%9A%84%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B/" title="01_JSLearn_JavaScript的执行过程"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-11-15</div><div class="title">01_JSLearn_JavaScript的执行过程</div></div></a></div><div><a href="/2024/11/29/JS/06_JSLearn_ES6%E4%B8%AD%E7%B1%BB%E7%9A%84%E4%BD%BF%E7%94%A8/" title="06_JSLearn_ES6中类的使用"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-11-29</div><div class="title">06_JSLearn_ES6中类的使用</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/./img/1.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Scenery</div><div class="author-info__description">今天不想跑，所以才去跑</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">82</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">15</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/chjm0121" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="/1595718686@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E5%AF%B9%E8%B1%A1%E5%AD%97%E9%9D%A2%E9%87%8F%E5%A2%9E%E5%BC%BA-Enhanced-object-literals"><span class="toc-text">1 对象字面量增强(Enhanced object literals)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E8%A7%A3%E6%9E%84Destructuring"><span class="toc-text">2 解构Destructuring</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E6%95%B0%E7%BB%84%E7%9A%84%E8%A7%A3%E6%9E%84"><span class="toc-text">2.1 数组的解构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%A7%A3%E6%9E%84"><span class="toc-text">2.2 对象的解构</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-var-let-const"><span class="toc-text">3 var&#x2F;let&#x2F;const</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-var%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-text">3.1 var关键字</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-let%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-text">3.2 let关键字</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-const%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-text">3.3 const关键字</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-%E4%BD%9C%E7%94%A8%E5%9F%9F%E6%8F%90%E5%8D%87-%EF%BC%88hoisting%EF%BC%89"><span class="toc-text">3.4 作用域提升 （hoisting）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-4-1-%E6%9A%82%E6%97%B6%E6%80%A7%E6%AD%BB%E5%8C%BA-%EF%BC%88Temporal-Dead-Zone-TDZ%EF%BC%89"><span class="toc-text">3.4.1 暂时性死区 （Temporal Dead Zone, TDZ）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-5-let-const%E5%92%8Cwindow%E5%85%B3%E7%B3%BB"><span class="toc-text">3.5 let-const和window关系</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-5-1-%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%EF%BC%88Execution-Context%EF%BC%89"><span class="toc-text">3.5.1 执行上下文（Execution Context）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-5-2-%E5%8F%98%E9%87%8F%E7%8E%AF%E5%A2%83%EF%BC%88VariableEnvironment%EF%BC%89"><span class="toc-text">3.5.2 变量环境（VariableEnvironment）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-5-3-%E7%8E%AF%E5%A2%83%E8%AE%B0%E5%BD%95%EF%BC%88Environment-Record%EF%BC%89"><span class="toc-text">3.5.3 环境记录（Environment Record）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-5-4-var%E3%80%81let-%E5%92%8C-const-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">3.5.4 var、let 和 const 的区别</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-6-let-const%E7%9A%84%E5%9D%97%E7%BA%A7%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-text">3.6 let&#x2F;const的块级作用域</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-6-1-%E5%9D%97%E7%BA%A7%E4%BD%9C%E7%94%A8%E5%9F%9F%E8%AF%AD%E5%8F%A5"><span class="toc-text">3.6.1 块级作用域语句</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-6-2-%E5%9D%97%E7%BA%A7%E4%BD%9C%E7%94%A8%E5%9F%9F%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-text">3.6.2 块级作用域的应用</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF%E4%B8%AD%E7%9A%84%E9%97%AD%E5%8C%85%E9%97%AE%E9%A2%98"><span class="toc-text">循环中的闭包问题</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%A1%A5%E5%85%85"><span class="toc-text">补充</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-7-var%E3%80%81let%E3%80%81const%E7%9A%84%E9%80%89%E6%8B%A9"><span class="toc-text">3.7 var、let、const的选择</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E6%A8%A1%E6%9D%BF%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-text">4 模板字符串</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E5%87%BD%E6%95%B0%E7%9B%B8%E5%85%B3"><span class="toc-text">5 函数相关</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-%E5%87%BD%E6%95%B0%E7%9A%84%E9%BB%98%E8%AE%A4%E5%8F%82%E6%95%B0"><span class="toc-text">5.1 函数的默认参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-%E5%87%BD%E6%95%B0%E7%9A%84%E5%89%A9%E4%BD%99%E5%8F%82%E6%95%B0"><span class="toc-text">5.2 函数的剩余参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0"><span class="toc-text">5.3 箭头函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E5%B1%95%E5%BC%80%E8%AF%AD%E6%B3%95-Spread-syntax"><span class="toc-text">6 展开语法(Spread syntax)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-%E6%95%B0%E5%80%BC%E7%9A%84%E8%A1%A8%E7%A4%BA"><span class="toc-text">7 数值的表示</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-Symbol"><span class="toc-text">8 Symbol</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#8-1-%E5%88%9B%E5%BB%BA-Symbol"><span class="toc-text">8.1 创建 Symbol</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-2-%E6%B7%BB%E5%8A%A0%E6%8F%8F%E8%BF%B0"><span class="toc-text">8.2 添加描述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-3-%E4%BD%9C%E4%B8%BA%E5%AF%B9%E8%B1%A1%E5%B1%9E%E6%80%A7"><span class="toc-text">8.3 作为对象属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-4-%E8%8E%B7%E5%8F%96%E6%89%80%E6%9C%89Symbol%E7%9A%84key"><span class="toc-text">8.4 获取所有Symbol的key</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-5-%E5%85%A8%E5%B1%80-Symbol-%E6%B3%A8%E5%86%8C%E8%A1%A8"><span class="toc-text">8.5 全局 Symbol 注册表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-6-%E5%86%85%E7%BD%AE-Symbol"><span class="toc-text">8.6 内置 Symbol</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#8-6-1-Symbol-toStringTag"><span class="toc-text">8.6.1 Symbol.toStringTag</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-6-2-Symbol-iterator"><span class="toc-text">8.6.2 Symbol.iterator</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-Set"><span class="toc-text">9 Set</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#9-1-set-%E7%9A%84%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8"><span class="toc-text">9.1 set 的基础使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-2-set-%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-text">9.2 set 的方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-WeakSet"><span class="toc-text">10 WeakSet</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#10-1-WeakSet-%E5%92%8C-Set-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">10.1 WeakSet 和 Set 的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-2-WeakSet%E5%B8%B8%E8%A7%81%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-text">10.2 WeakSet常见的方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-3-WeakSet%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-text">10.3 WeakSet的应用场景</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-Map"><span class="toc-text">11 Map</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#11-1-Map-%E5%92%8C%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">11.1 Map 和对象的区别</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#11-1-1-%E9%94%AE%E7%9A%84%E7%B1%BB%E5%9E%8B"><span class="toc-text">11.1.1 键的类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#11-1-2-%E9%94%AE%E7%9A%84%E5%94%AF%E4%B8%80%E6%80%A7"><span class="toc-text">11.1.2 键的唯一性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#11-1-3-%E5%8A%A8%E6%80%81%E5%A4%A7%E5%B0%8F"><span class="toc-text">11.1.3 动态大小</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#11-1-4-%E5%86%85%E7%BD%AE%E6%96%B9%E6%B3%95"><span class="toc-text">11.1.4 内置方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#11-1-5-%E9%81%8D%E5%8E%86"><span class="toc-text">11.1.5 遍历</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#11-1-6-%E6%80%A7%E8%83%BD"><span class="toc-text">11.1.6 性能</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-2-Map-%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-text">11.2 Map 的常用方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-WeakMap"><span class="toc-text">12 WeakMap</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#12-1-WeakMap-%E5%92%8C-Map-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">12.1 WeakMap 和 Map 的区别</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#12-1-1-%E9%94%AE%E7%9A%84%E7%B1%BB%E5%9E%8B"><span class="toc-text">12.1.1 键的类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#12-1-2-%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B"><span class="toc-text">12.1.2 引用类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#12-1-3-%E5%A4%A7%E5%B0%8F%E5%92%8C%E8%BF%AD%E4%BB%A3"><span class="toc-text">12.1.3 大小和迭代</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-2-WeakMap%E5%B8%B8%E8%A7%81%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-text">12.2 WeakMap常见的方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-3-WeakMap%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-text">12.3 WeakMap的应用场景</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#12-3-1-%E5%93%8D%E5%BA%94%E5%BC%8F%E7%B3%BB%E7%BB%9F%EF%BC%88%E5%A6%82-Vue-3%EF%BC%89"><span class="toc-text">12.3.1 响应式系统（如 Vue 3）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#12-3-2-%E5%85%B6%E4%BB%96%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-text">12.3.2 其他应用场景</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/07/26/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/10_%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0_%E9%9B%86%E6%88%90%E5%AD%A6%E4%B9%A0/" title="10_机器学习_集成学习">10_机器学习_集成学习</a><time datetime="2025-07-26T01:58:53.000Z" title="发表于 2025-07-26 09:58:53">2025-07-26</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/07/25/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/09_%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0_%E6%9C%B4%E7%B4%A0%E8%B4%9D%E5%8F%B6%E6%96%AF/" title="09_机器学习_朴素贝叶斯">09_机器学习_朴素贝叶斯</a><time datetime="2025-07-25T03:08:47.000Z" title="发表于 2025-07-25 11:08:47">2025-07-25</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/07/24/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/08_%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0_%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA/" title="08_机器学习_支持向量机">08_机器学习_支持向量机</a><time datetime="2025-07-23T18:31:48.000Z" title="发表于 2025-07-24 02:31:48">2025-07-24</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/07/23/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/07_%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0_%E5%A4%9A%E5%B1%82%E6%84%9F%E7%9F%A5%E6%9C%BA(MLP)/" title="07_机器学习_多层感知机(MLP)">07_机器学习_多层感知机(MLP)</a><time datetime="2025-07-22T22:46:33.000Z" title="发表于 2025-07-23 06:46:33">2025-07-23</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/07/22/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/04_%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0_%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/" title="04_机器学习_基础概念">04_机器学习_基础概念</a><time datetime="2025-07-22T03:20:30.000Z" title="发表于 2025-07-22 11:20:30">2025-07-22</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('/./img/1.jpg')"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2025 By Scenery</div><div class="footer_custom_text"><div>波澜不惊</div><div class="footer-div"><img class="footer-icon" src="./img/备案图标.png"><a class="footer-a" target="_blank" rel="noopener" href="http://beian.miit.gov.cn/">皖ICP备2021016944号-1</a></div></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.13.0"></script><script src="/js/main.js?v=4.13.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@5.2.0/instantpage.min.js" type="module"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=4.13.0"></script></div></div></body></html>