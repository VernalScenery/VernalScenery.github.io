<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>SprintBoot框架课 | 春和景明的记事本</title><meta name="author" content="Scenery"><meta name="copyright" content="Scenery"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="SprintBoot框架课配置Mysql与注册登录模块1. Mysql1.1 mysql服务的关闭与启动 默认开机自动启动，如果想手动操作，可以参考如下命令 启动mysql5.7版本不需要加80，直接net start mysql   关闭：net stop mysql80 启动：net start"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://vernalscenery.github.io/2024/07/20/Java/SprintBoot%E6%A1%86%E6%9E%B6%E8%AF%BE/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=4.13.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'SprintBoot框架课',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-07-20 14:15:46'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><link rel="stylesheet" href="/css/style.css"><meta name="generator" content="Hexo 5.4.2"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/./img/1.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">59</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">12</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/./img/1.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="春和景明的记事本"><span class="site-name">春和景明的记事本</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">SprintBoot框架课</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-07-19T18:15:12.000Z" title="发表于 2024-07-20 02:15:12">2024-07-20</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-07-20T06:15:46.528Z" title="更新于 2024-07-20 14:15:46">2024-07-20</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">7.2k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>32分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="SprintBoot框架课"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="SprintBoot框架课"><a href="#SprintBoot框架课" class="headerlink" title="SprintBoot框架课"></a>SprintBoot框架课</h1><h2 id="配置Mysql与注册登录模块"><a href="#配置Mysql与注册登录模块" class="headerlink" title="配置Mysql与注册登录模块"></a>配置Mysql与注册登录模块</h2><h3 id="1-Mysql"><a href="#1-Mysql" class="headerlink" title="1. Mysql"></a>1. Mysql</h3><h4 id="1-1-mysql服务的关闭与启动"><a href="#1-1-mysql服务的关闭与启动" class="headerlink" title="1.1 mysql服务的关闭与启动"></a>1.1 mysql服务的关闭与启动</h4><blockquote>
<p>默认开机自动启动，如果想手动操作，可以参考如下命令</p>
<p>启动mysql5.7版本不需要加80，直接<code>net start mysql</code></p>
</blockquote>
<ul>
<li>关闭：<code>net stop mysql80</code></li>
<li>启动：<code>net start mysql80</code></li>
</ul>
<h4 id="1-2-常用操作"><a href="#1-2-常用操作" class="headerlink" title="1.2 常用操作"></a>1.2 常用操作</h4><ul>
<li>连接用户名为<code>root</code>，密码为<code>123456</code>的数据库服务：<code>mysql -uroot -p123456</code></li>
<li><code>show databases</code>：列出所有数据库</li>
<li><code>create database kob</code>：创建数据库</li>
<li><code>drop database kob</code>：删除数据库</li>
<li><code>use kob</code>：使用数据库kob</li>
<li><code>show tables</code>：列出当前数据库的所有表</li>
<li><code>create table user(id int, username varchar(100))</code>：创建名称为user的表，表中包含id和username两个属性。</li>
<li><code>drop table user</code>：删除表</li>
<li><code>insert into user values(1, &#39;yxc&#39;)</code>：在表中插入数据</li>
<li><code>select * from user</code>：查询表中所有数据</li>
<li><code>delete from user where id = 2</code>：删除某行数据</li>
</ul>
<p><strong>SpringBoot中可以可视化mysql数据库</strong></p>
<p><img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/image-20230226093901090.png" alt="image-20230226093901090"></p>
<h3 id="2-SpringBoot配置mysql"><a href="#2-SpringBoot配置mysql" class="headerlink" title="2. SpringBoot配置mysql"></a>2. SpringBoot配置mysql</h3><ol>
<li>在<a target="_blank" rel="noopener" href="https://mvnrepository.com/">Maven仓库地址</a>中查找如下依赖，并添加到<code>pom.xml</code>文件中：<ul>
<li><strong>Spring Boot Starter JDBC</strong><blockquote>
<p>JDBCTemplate为我们提供了增删改查数据库的方法</p>
</blockquote>
</li>
<li><strong>Project Lombok</strong><blockquote>
<p>Lombok 是一种 Java 实用工具，可用来帮助开发人员消除 Java 的冗长，尤其是对于简单的 Java 对象（POJO）。它通过注释实现这一目的。通过在开发环境中实现 Lombok，开发人员可以节省构建诸如 hashCode() 和 equals() 这样的方法以及以往用来分类各种 accessor 和 mutator 的大量时间。</p>
</blockquote>
  使用Lombok：  <img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/image-20230226101449302.png" alt="image-20230226101449302">  源文件：  <img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/image-20230226101742593.png" alt="image-20230226101742593">  生成的target后的文件：  <img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/image-20230226101336841.png" alt="image-20230226101336841"></li>
<li><strong>MySQL Connector/J</strong><blockquote>
<p>mysql连接</p>
</blockquote>
</li>
<li><strong>mybatis-plus-boot-starter</strong><blockquote>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/chaizepeng/article/details/119384531">关于mybatis</a>，使用mybatis-plus就不用写sql语句了</p>
</blockquote>
</li>
<li><strong>mybatis-plus-generator</strong><blockquote>
<p>生成 Mapper接口和配置文件</p>
</blockquote>
  <strong>MyBatis-Plus 最核心的功能要数通用 Mapper 了，只要我们的 Mapper 接口继承了BaseMapper，就可以进行单表CRUD操作，具体接口见</strong><a target="_blank" rel="noopener" href="https://baomidou.com/">Mybatis-Plus官网</a>  <img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/image-20230226102611248.png" alt="image-20230226102611248"></li>
</ul>
</li>
<li>然后让Maven更新依赖： <img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/image-20230226092348496.png" alt="image-20230226092348496"></li>
<li>在<code>application.properties</code>中添加数据库配置： spring.datasource.username=root<br> spring.datasource.password=123456<br> spring.datasource.url=jdbc:mysql://localhost:3307/kob?serverTimezone=Asia/Shanghai&amp;useUnicode=true&amp;characterEncoding=utf-8<br> spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver</li>
</ol>
<p><strong>注意：在安装上述依赖后，建议关闭如下选项：</strong></p>
<p><img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/image-20230226093421511.png" alt="image-20230226093421511"></p>
<h3 id="3-接口编写整体流程"><a href="#3-接口编写整体流程" class="headerlink" title="3.接口编写整体流程"></a>3.接口编写整体流程</h3><h4 id="3-1-SpringBoot中的各个层"><a href="#3-1-SpringBoot中的各个层" class="headerlink" title="3.1 SpringBoot中的各个层"></a>3.1 SpringBoot中的各个层</h4><ul>
<li><code>pojo</code>层：将数据库中的表对应成<code>Java</code>中的<code>Class</code></li>
<li><code>mapper</code>层（也叫<code>Dao</code>层）：将<code>pojo</code>层的<code>class</code>中的操作，映射成<code>sql</code>语句</li>
<li><code>service</code>层：写具体的业务逻辑，组合使用<code>mapper</code>中的操作</li>
<li><code>controller</code>层：负责请求转发，接受页面过来的参数，传给<code>Service</code>处理，接到返回值，再传给页面</li>
</ul>
<h4 id="3-2-具体实现"><a href="#3-2-具体实现" class="headerlink" title="3.2 具体实现"></a>3.2 具体实现</h4><p>文件目录如下：</p>
<p><img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/image-20230226111207030.png" alt="image-20230226111207030"></p>
<ol>
<li>首先在<code>pojo</code>层新建<code>User</code>类，数据库中的<code>User</code>表对应成<code>Java</code>中的<code>User</code>类。 <img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/image-20230226111347059.png" alt="image-20230226111347059"></li>
<li>然后在<code>mapper</code>层中新建<code>UserMapper</code>接口，让其继承MyBatis-Plus库实现的BaseMapper，这样就可以对<code>user</code>表CRUD操作，具体CRUD操作API见<a target="_blank" rel="noopener" href="https://baomidou.com/">Mybatis-Plus官网</a> <img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/image-20230226111507605.png" alt="image-20230226111507605"></li>
<li>然后在<code>controller</code>层中实现接口 <img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/image-20230226112059568.png" alt="image-20230226112059568"><ul>
<li><code>@RestController</code>：个人理解是指定接口返回数据的规范，相关理解可参考<a target="_blank" rel="noopener" href="https://www.cnblogs.com/justn0w/p/11628287.html">这个网站</a></li>
<li><code>@Autowired</code>：可以对类成员变量、方法及构造函数进行标注，让 <code>spring</code> 完成<code>bean自动装配</code>的工作。默认是按照类去匹配，配合@<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=Qualifier&spm=1001.2101.3001.7020">Qualifier</a> 指定按照名称去装配 bean。<blockquote>
<p>在使用Spring进行项目开发的时候，会大量使用到自动装配，那自动装配是什么呢？简单来说：Spring 利用依赖注入（DI）功能，完成SpringIOC容器中各个组件之间的依赖关系赋值管理。</p>
</blockquote>
</li>
<li><code>@GetMapping</code>：GET接口</li>
<li><code>selectList</code>方法是<code>userMapper</code>继承的父类<code>BaseMapper</code>（<code>MyBatis-Plus</code>库实现)中的<code>API</code>，详情见<a target="_blank" rel="noopener" href="https://baomidou.com/">Mybatis-Plus官网</a></li>
</ul>
</li>
</ol>
<h3 id="4-修改Spring-Security"><a href="#4-修改Spring-Security" class="headerlink" title="4. 修改Spring Security"></a>4. 修改Spring Security</h3><h4 id="4-1-安装相关依赖"><a href="#4-1-安装相关依赖" class="headerlink" title="4.1 安装相关依赖"></a>4.1 安装相关依赖</h4><ol>
<li>在<a target="_blank" rel="noopener" href="https://mvnrepository.com/">Maven仓库地址</a>中查找如下依赖，并添加到<code>pom.xml</code>文件中，并更新Maven依赖<ul>
<li>spring-boot-starter-security</li>
</ul>
</li>
<li>然后重启项目后，访问相关端口需要先登录。<img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/image-20230227082643042.png" alt="image-20230227082643042"></li>
<li>username默认为user,密码为随机生成，见命令行。 <img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/image-20230227082620583.png" alt="image-20230227082620583"></li>
</ol>
<h4 id="4-2-修改security"><a href="#4-2-修改security" class="headerlink" title="4.2 修改security"></a>4.2 修改security</h4><ol>
<li>实现实现由数据库中的用户登录<ul>
<li>首先在如下目录中，新建UserDetailsServiceImpl类，继承自UserDetailsService接口，用来接入数据库信息</li>
</ul>
 <img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/image-20230227090455634.png" alt="image-20230227090455634"><ul>
<li>UserDetailsServiceImpl实现了根据username返回用户信息，用于登录验证，代码如下：<blockquote>
<p>这里会将数据库中该用户的password与用户输入的password进行比较，注意这里是明文比较，需要在数据库中的password字段前前加<code>&#123;noop&#125;</code>，表示密码没有加密。</p>
<p><img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/image-20230227092255287.png" alt="image-20230227092255287"></p>
</blockquote>
</li>
</ul>
 <img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/image-20230227090546982.png" alt="image-20230227090546982"><ul>
<li>其中，UserDetailsImpl为实现的工具，用于返回用户各种信息，该类继承于implements，按<code>alt+insert</code>可自动补全父类中需要重写的方法，部分代码截图如下：</li>
</ul>
 <img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/image-20230227090846640.png" alt="image-20230227090846640"> 以上实现的为密码<strong>明文比较</strong>进行登录，还未对密码进行加密。</li>
<li>实现config.SecurityConfig类，用来实现用户密码的加密存储 <img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/image-20230227093653414.png" alt="image-20230227093653414"><blockquote>
<p>可以在test中进行测试，如图：</p>
<p><img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/image-20230227095103549.png" alt="image-20230227095103549"></p>
</blockquote>
 然后在新建用户时将password换为加密后的密码即可，代码如下： @GetMapping(“/user/add/{userId}/{username}/{password}/“)  <pre><code> public String addUser(  
         @PathVariable int userId,  
         @PathVariable String username,  
         @PathVariable String password)&#123;  
     PasswordEncoder passwordEncoder = new BCryptPasswordEncoder();  
     String encodePassword = passwordEncoder.encode(password);  
     User user = new User(userId,username,encodePassword);  
     userMapper.insert(user);  
     return &quot;Add User Successfully&quot;;  
 &#125;
</code></pre>
</li>
</ol>
<h3 id="5-jwt验证"><a href="#5-jwt验证" class="headerlink" title="5. jwt验证"></a>5. jwt验证</h3><h4 id="5-1-安装相关依赖"><a href="#5-1-安装相关依赖" class="headerlink" title="5.1 安装相关依赖"></a>5.1 安装相关依赖</h4><ol>
<li>在<a target="_blank" rel="noopener" href="https://mvnrepository.com/">Maven仓库地址</a>中查找如下依赖，并添加到<code>pom.xml</code>文件中，然后更新maven依赖：<ul>
<li><code>jjwt-api</code></li>
<li><code>jjwt-impl</code></li>
<li><code>jjwt-jackson</code></li>
</ul>
</li>
<li>实现<code>utils.JwtUtil</code>类，为<code>jwt</code>工具类，用来创建、解析<code>jwt token</code> package com.kob.backend.utils;   import io.jsonwebtoken.Claims;<br> import io.jsonwebtoken.JwtBuilder;<br> import io.jsonwebtoken.Jwts;<br> import io.jsonwebtoken.SignatureAlgorithm;<br> import org.springframework.stereotype.Component;   import javax.crypto.SecretKey;<br> import javax.crypto.spec.SecretKeySpec;<br> import java.util.Base64;<br> import java.util.Date;<br> import java.util.UUID;   @Component<br> public class JwtUtil {  <pre><code> public static final long JWT_TTL = 60 * 60 * 1000L * 24 * 14;  // 有效期14天  
 public static final String JWT_KEY = &quot;SDFGjhdsfalshdfHFdsjkdsfds121232131afasdfac&quot;;  

 public static String getUUID() &#123;  
     return UUID.randomUUID().toString().replaceAll(&quot;-&quot;, &quot;&quot;);  
 &#125;  

 public static String createJWT(String subject) &#123;  
     JwtBuilder builder = getJwtBuilder(subject, null, getUUID());  
     return builder.compact();  
 &#125;  

 private static JwtBuilder getJwtBuilder(String subject, Long ttlMillis, String uuid) &#123;  
     SignatureAlgorithm signatureAlgorithm = SignatureAlgorithm.HS256;  
     SecretKey secretKey = generalKey();  
     long nowMillis = System.currentTimeMillis();  
     Date now = new Date(nowMillis);  
     if (ttlMillis == null) &#123;  
         ttlMillis = JwtUtil.JWT_TTL;  
     &#125;  

     long expMillis = nowMillis + ttlMillis;  
     Date expDate = new Date(expMillis);  
     return Jwts.builder()  
             .setId(uuid)  
             .setSubject(subject)  
             .setIssuer(&quot;sg&quot;)  
             .setIssuedAt(now)  
             .signWith(signatureAlgorithm, secretKey)  
             .setExpiration(expDate);  
 &#125;  

 public static SecretKey generalKey() &#123;  
     byte[] encodeKey = Base64.getDecoder().decode(JwtUtil.JWT_KEY);  
     return new SecretKeySpec(encodeKey, 0, encodeKey.length, &quot;HmacSHA256&quot;);  
 &#125;  

 public static Claims parseJWT(String jwt) throws Exception &#123;  
     SecretKey secretKey = generalKey();  
     return Jwts.parserBuilder()  
             .setSigningKey(secretKey)  
             .build()  
             .parseClaimsJws(jwt)  
             .getBody();  
 &#125;  
</code></pre>
 }</li>
<li>实现<code>config.filter.JwtAuthenticationTokenFilter</code>类，用来验证<code>jwt token</code>，如果验证成功，则将<code>User</code>信息注入上下文中 package com.kob.backend.config.filter;   import com.kob.backend.mapper.UserMapper;<br> import com.kob.backend.pojo.User;<br> import com.kob.backend.service.impl.utils.UserDetailsImpl;<br> import com.kob.backend.utils.JwtUtil;<br> import io.jsonwebtoken.Claims;<br> import org.jetbrains.annotations.NotNull;<br> import org.springframework.beans.factory.annotation.Autowired;<br> import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;<br> import org.springframework.security.core.context.SecurityContextHolder;<br> import org.springframework.stereotype.Component;<br> import org.springframework.util.StringUtils;<br> import org.springframework.web.filter.OncePerRequestFilter;   import javax.servlet.FilterChain;<br> import javax.servlet.ServletException;<br> import javax.servlet.http.HttpServletRequest;<br> import javax.servlet.http.HttpServletResponse;<br> import java.io.IOException;   @Component<br> public class JwtAuthenticationTokenFilter extends OncePerRequestFilter {  <pre><code> @Autowired  
 private UserMapper userMapper;  

 @Override  
 protected void doFilterInternal(HttpServletRequest request, @NotNull HttpServletResponse response, @NotNull FilterChain filterChain) throws ServletException, IOException &#123;  
     String token = request.getHeader(&quot;Authorization&quot;);  

     if (!StringUtils.hasText(token) || !token.startsWith(&quot;Bearer &quot;)) &#123;  
         filterChain.doFilter(request, response);  
         return;  
     &#125;  

     token = token.substring(7);  

     String userid;  
     try &#123;  
         Claims claims = JwtUtil.parseJWT(token);  
         userid = claims.getSubject();  
     &#125; catch (Exception e) &#123;  
         throw new RuntimeException(e);  
     &#125;  

     User user = userMapper.selectById(Integer.parseInt(userid));  

     if (user == null) &#123;  
         throw new RuntimeException(&quot;用户名未登录&quot;);  
     &#125;  

     UserDetailsImpl loginUser = new UserDetailsImpl(user);  
     UsernamePasswordAuthenticationToken authenticationToken =  
             new UsernamePasswordAuthenticationToken(loginUser, null, null);  

     SecurityContextHolder.getContext().setAuthentication(authenticationToken);  

     filterChain.doFilter(request, response);  
 &#125;  
</code></pre>
 }  </li>
<li>配置<code>config.SecurityConfig</code>类，放行登录、注册等接口 package com.kob.backend.config;   import com.kob.backend.config.filter.JwtAuthenticationTokenFilter;<br> import org.springframework.beans.factory.annotation.Autowired;<br> import org.springframework.context.annotation.Bean;<br> import org.springframework.context.annotation.Configuration;<br> import org.springframework.http.HttpMethod;<br> import org.springframework.security.authentication.AuthenticationManager;<br> import org.springframework.security.config.annotation.web.builders.HttpSecurity;<br> import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;<br> import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;<br> import org.springframework.security.config.http.SessionCreationPolicy;<br> import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;<br> import org.springframework.security.crypto.password.PasswordEncoder;<br> import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;   @Configuration<br> @EnableWebSecurity<br> public class SecurityConfig extends WebSecurityConfigurerAdapter {  <pre><code> @Autowired  
 private JwtAuthenticationTokenFilter jwtAuthenticationTokenFilter;  

 @Bean  
 public PasswordEncoder passwordEncoder() &#123;  
     return new BCryptPasswordEncoder();  
 &#125;  

 @Bean  
 @Override  
 public AuthenticationManager authenticationManagerBean() throws Exception &#123;  
     return super.authenticationManagerBean();  
 &#125;  

 @Override  
 protected void configure(HttpSecurity http) throws Exception &#123;  
     http.csrf().disable()  
             .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS)  
             .and()  
             .authorizeRequests()  
             .antMatchers(&quot;/user/account/token/&quot;, &quot;/user/account/register/&quot;).permitAll()  
             .antMatchers(HttpMethod.OPTIONS).permitAll()  
             .anyRequest().authenticated();  

     http.addFilterBefore(jwtAuthenticationTokenFilter, UsernamePasswordAuthenticationFilter.class);  
 &#125;  
</code></pre>
 }</li>
</ol>
<h4 id="5-2-编写API"><a href="#5-2-编写API" class="headerlink" title="5.2 编写API"></a>5.2 编写API</h4><ol>
<li>将数据库中的<code>id</code>域变为自增<ul>
<li>在数据库中将<code>id</code>列变为自增</li>
<li>在<code>pojo.User</code>类中添加注解：<code>@TableId(type = IdType.AUTO)</code></li>
</ul>
</li>
<li>实现<code>/user/account/token/</code>：验证用户名密码，验证成功后返回<code>jwt token</code>（令牌） <strong>注意：在POST方法中</strong><ul>
<li><code>@RequestBody</code>获取的是<code>axios</code>中<code>data</code>字段携带的数据  <img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/image-20230227163918163.png" alt="image-20230227163918163">  <img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/image-20230227164055094.png" alt="image-20230227164055094"></li>
<li><code>@RequestParam</code>获取的是<code>axios</code>中<code>params</code>字段携带的数据  <img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/image-20230227164252146.png" alt="image-20230227164252146">  <img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/image-20230227164321030.png" alt="image-20230227164321030"></li>
</ul>
</li>
<li>实现<code>/user/account/info/</code>：根据令牌返回用户信息</li>
<li>实现<code>/user/account/register/</code>：注册账号</li>
</ol>
<h2 id="编写API的总结"><a href="#编写API的总结" class="headerlink" title="编写API的总结"></a>编写API的总结</h2><ol>
<li>首先在pojo封装与数据库对应的类<blockquote>
<p>注意：数据库里字段命名用create_time，pojo里用驼峰命名createTime</p>
</blockquote>
 <img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/image-20230227172944636.png" alt="image-20230227172944636"></li>
<li>在mapper层，实现<code>UserMapper</code>接口 让其继承<code>mybatis</code>封装的<code>BaseMapper</code>接口，该接口内定义了许多封装好的接口，用于查询数据库，这样就可以避免写sql语句了,相关api见<a target="_blank" rel="noopener" href="https://baomidou.com/">Mybatis-Plus官网</a> <img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/image-20230227174734447.png" alt="image-20230227174734447"> @Mapper<br> public interface UserMapper extends BaseMapper<User> {  // 让UserMapper接口继承mybatis封装的BaseMapper接口<br> }</li>
<li>然后在service层定义接口，并实现该接口。<ul>
<li>service层整体目录：  <img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/image-20230227173402697.png" alt="image-20230227173402697"></li>
<li><code>service/user/account/RegisterService</code>中定义接口：  public interface RegisterService {  <pre><code>  public Map&lt;String, String&gt; register(String username, String password, String confirmedPassword);  
</code></pre>
  }</li>
<li>在<code>service/impl/user/account/RegisterService</code>中实现接口  public class RegisterServiceImpl implements RegisterService { @Autowired private UserMapper userMapper; // 继承了mybatis中的BaseMapper类 不用写sql语句了 直接调api  @Autowired<br>  private PasswordEncoder passwordEncoder;  // 密码加密的接口    @Override<br>  public Map&lt;String, String&gt; register(String username, String password, String confirmedPassword) {  <pre><code>  Map&lt;String, String&gt; map = new HashMap&lt;&gt;();  
  if (username == null) &#123;  // null判断是否有这个参数 和 参数长度为0不一样  
      map.put(&quot;error_message&quot;, &quot;用户名不能为空&quot;);  
      return map;  
  &#125;  
  if (password == null || confirmedPassword == null) &#123;  
      map.put(&quot;error_message&quot;, &quot;密码不能为空&quot;);  
      return map;  
  &#125;  
  // .... 此处省略各种特判......  

  // 查询数据库 验证用户名是否存在  
  QueryWrapper&lt;User&gt; queryWrapper = new QueryWrapper&lt;&gt;();  
  queryWrapper.eq(&quot;username&quot;, username);  
  List&lt;User&gt; users = userMapper.selectList(queryWrapper);  
  if (!users.isEmpty()) &#123;  
      map.put(&quot;error_message&quot;, &quot;用户名已存在&quot;);  
      return map;  
  &#125;  

  // 新建用户  
  String encodedPassword = passwordEncoder.encode(password);  
  String photo = &quot;https://cdn.acwing.com/media/user/profile/photo/1_lg_844c66b332.jpg&quot;;  
  User user = new User(null, username, encodedPassword, photo); // id是自增的 所以不用传  
  userMapper.insert(user);  

  map.put(&quot;error_message&quot;, &quot;success&quot;);  
  return map;  
</code></pre>
  }</li>
</ul>
</li>
<li>最后在<code>controller</code>层映射指定路径到接口 <code>controller/user/account/</code>中 @RestController<br> public class RegisterController {  <pre><code> @Autowired  
 private RegisterService registerService; // 生成之前实现的接口实例，这样可以调用接口里实现的方法  

 @PostMapping(&quot;/user/account/register/&quot;)  
 public Map&lt;String, String&gt; register(@RequestParam Map&lt;String, String&gt; map) &#123;  
     String username = map.get(&quot;username&quot;);  
     String password = map.get(&quot;password&quot;);  
     String confirmedPassword = map.get(&quot;confirmedPassword&quot;);  
     return registerService.register(username, password, confirmedPassword);  
 &#125;  
</code></pre>
 }</li>
</ol>
<h2 id="匹配系统"><a href="#匹配系统" class="headerlink" title="匹配系统"></a>匹配系统</h2><h3 id="1-前后端WebSocekt连接"><a href="#1-前后端WebSocekt连接" class="headerlink" title="1. 前后端WebSocekt连接"></a>1. 前后端WebSocekt连接</h3><h4 id="后端集成WebSocket"><a href="#后端集成WebSocket" class="headerlink" title="后端集成WebSocket"></a>后端集成WebSocket</h4><ol>
<li>在pom.xml文件中添加依赖：<ul>
<li><code>spring-boot-starter-websocket</code></li>
<li><code>fastjson</code></li>
</ul>
</li>
<li>添加<code>config.WebSocketConfig</code>配置类： @Configuration<br> public class WebSocketConfig {  <pre><code> @Bean  
 public ServerEndpointExporter serverEndpointExporter() &#123;  
     return new ServerEndpointExporter();  
 &#125;  
</code></pre>
 }  </li>
<li>添加<code>consumer.WebSocketServer</code>类 @Component<br> @ServerEndpoint(“/websocket/{token}”)  // 注意不要以’/‘结尾<br> public class WebSocketServer {  <pre><code> // 保存所有的用户 静态变量 ConcurrentHashMap是进程安全的HashMap  
 private static ConcurrentHashMap&lt;Integer,WebSocketServer&gt; users =  new ConcurrentHashMap&lt;&gt;();  

 // 一个session对应一个user  
 private User user;  
 private Session session = null;  
   
  // 匹配池  
 private static CopyOnWriteArraySet&lt;User&gt; matchPool = new CopyOnWriteArraySet&lt;&gt;();  

 // 单例模式注入UserMapper  
 private static UserMapper userMapper;  
 @Autowired  
 public void setUserMapper(UserMapper userMapper)&#123;  
     WebSocketServer.userMapper = userMapper;  
 &#125;  


 @OnOpen  
 public void onOpen(Session session, @PathParam(&quot;token&quot;) String token) throws IOException &#123;  
     // 建立连接  
     System.out.println(&quot;onOpen&quot;);  
     this.session = session;  
       
 &#125;  

 @OnClose  
 public void onClose() &#123;  
     // 关闭链接  
     System.out.println(&quot;onclose&quot;);  
     if(this.user != null)&#123;  
         users.remove(this.user.getId());  
     &#125;  
 &#125;  

 @OnMessage  
 public void onMessage(String message, Session session) &#123;  
     // 从Client接收消息  
     System.out.println(&quot;onMessage&quot;);  
 &#125;  

 @OnError  
 public void onError(Session session, Throwable error) &#123;  
     error.printStackTrace();  
     System.out.println(&quot;onError&quot;);  
 &#125;  

 public void sendMessage(String message)&#123;  
     // 发送消息给从Client  
     synchronized (this.session)&#123;  // 锁  
         try &#123;  
             this.session.getBasicRemote().sendText(message);  
         &#125;catch (IOException e)&#123;  
             e.printStackTrace();  
         &#125;  
     &#125;  
 &#125;  
</code></pre>
 }  </li>
<li>在<code>config.SecurityConfig</code>中添加如下代码，跳过jwt验证  @Override<br>  public void configure(WebSecurity web) throws Exception {  <pre><code>   web.ignoring().antMatchers(&quot;/websocket/**&quot;);  // 开发接口 跳过jwt验证  
</code></pre>
  }</li>
</ol>
<h4 id="前端集成WebSocket"><a href="#前端集成WebSocket" class="headerlink" title="前端集成WebSocket"></a>前端集成WebSocket</h4><blockquote>
<p>前端有封装好的WebSocket类，直接调用相关api即可，这里没有跨域问题，直接使用后端端口就行</p>
</blockquote>
<p>const socketUrl = <code>ws://localhost:3030/websocket/$&#123;store.state.user.token&#125;</code>;<br>let socket: WebSocket | null = null;<br>onMounted(() =&gt; {<br>  // 建立连接<br>  socket = new WebSocket(socketUrl);  </p>
<p>  // 开始连接的钩子函数<br>  socket.onopen = () =&gt; {<br>    console.log(“onopen”);<br>  };  </p>
<p>  // 向服务端发送消息<br>  socket.send(JSON.stringify({ event: “start-matching” }));  </p>
<p>  // 从服务端接收消息<br>  socket.onmessage = (msg) =&gt; {<br>    const data = JSON.parse(msg.data);<br>    console.log(data);<br>  };  </p>
<p>  // 结束连接的钩子函数<br>  socket.onclose = () =&gt; {<br>    console.log(“onclose”);<br>  };<br>});  </p>
<p>onUnmounted(() =&gt; {<br>  // 断开连接<br>  socket?.close();<br>});</p>
<h3 id="2-创建微服务"><a href="#2-创建微服务" class="headerlink" title="2.创建微服务"></a>2.创建微服务</h3><ol>
<li>新建一个<code>backendcloud</code>项目，勾选<code>spring web</code>依赖 <img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/image-20230307210913920.png" alt="image-20230307210913920"> <img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/image-20230307210957305.png" alt="image-20230307210957305"></li>
<li>删除其src文件，并在<code>pom.xml</code>文件中添加<code>&lt;packaging&gt;pom&lt;/packaging&gt;</code><blockquote>
<p>配置<code>&lt;packaging&gt;pom&lt;/packaging&gt;</code>的意思是使用maven分模块管理，都会有一个父级项目，pom文件一个重要的属性就是packaging（打包类型），一般来说所有的父级项目的packaging都为pom，packaging默认类型jar类型，如果不做配置，maven会将该项目打成jar包。</p>
</blockquote>
 <img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/image-20230307211455062.png"></li>
<li>然后在<code>SpringCloud</code>项目中添加依赖：<a target="_blank" rel="noopener" href="https://mvnrepository.com/">Maven仓库地址</a><ul>
<li>spring-cloud-dependencies</li>
</ul>
 <dependency>  
     <groupId>org.springframework.cloud</groupId>  
     <artifactId>spring-cloud-dependencies</artifactId>  
     <version>2021.0.3</version>  
     <type>pom</type>  
     <scope>import</scope>  
 </dependency>
 </li>
<li>然后在<code>backendcloud</code>中新建一个<strong>模块</strong>，命名为<code>matchingsystem</code>  <img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/image-20230307211947105.png" alt="image-20230307211947105" style="zoom:67%;" />  
     
 <img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/image-20230307212543356.png" alt="image-20230307212543356" style="zoom:67%;" />
 </li>
<li>将<code>backencloud</code>项目<code>pom.xml</code>中<code>spring Web</code>的依赖<strong>剪切</strong>到<code>matchingsystem</code>项目的<code>pom.xml</code>中，然后同步父项目<code>backencloud</code>和子项目<code>matchingsystem</code>的<code>maven</code>依赖。 <img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/image-20230307212811987.png" alt="image-20230307212811987"><img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/image-20230307212930685.png" alt="image-20230307212930685"></li>
<li>在子项目<code>matchingsystem</code>下的<code>resources</code>文件夹下新建<code>application.properties</code>文件，并配置端口号<blockquote>
<p>注意：别和backend的端口重了</p>
</blockquote>
 <img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/image-20230307213327245.png" alt="image-20230307213327245"></li>
<li>在子项目<code>matchingsystem</code>下创建<code>service</code>和<code>controller</code>层，编写相关端口 <img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/image-20230307213932988.png" alt="image-20230307213932988"> 其中<code>MatchingController</code>的代码如下： @RestController<br> public class MatchingController {  <pre><code> @Autowired  
 private MatchingService matchingService;  

 @PostMapping(&quot;/player/add&quot;)  
 public String addPlayer(@RequestParam MultiValueMap&lt;String, String&gt; data) &#123; // 这里必须是MultiValueMap  
     Integer userId = Integer.parseInt(Objects.requireNonNull(data.getFirst(&quot;user_id&quot;)));  
     Integer rating = Integer.parseInt(Objects.requireNonNull(data.getFirst(&quot;rating&quot;)));  
     return matchingService.addPlayer(userId, rating);  
 &#125;  

 @PostMapping(&quot;/player/remove&quot;)  
 public String removePlayer(@RequestParam MultiValueMap&lt;String, String&gt; data) &#123;  
     Integer userId = Integer.parseInt(Objects.requireNonNull(data.getFirst(&quot;user_id&quot;)));  
     return matchingService.removePlayer(userId);  
 &#125;  
</code></pre>
 }</li>
<li>修改<code>security</code>，设置权限管理，只需要<code>backend</code>项目访问<code>matchingsystem</code>里的<code>addPlayer</code>和<code>removePlayer</code>接口。<ul>
<li>安装security依赖，并更新maven  <dependency>  
      <groupId>org.springframework.boot</groupId>  
      <artifactId>spring-boot-starter-security</artifactId>  
      <version>2.7.1</version>  
  </dependency>
  </li>
<li>创建<code>config/SecurityConfig</code>，并配置<code>security</code><strong>只允许本地iP访问</strong>  <img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/image-20230307214820943.png">  package com.kob.matchingsystem.config;    import org.springframework.context.annotation.Configuration;<br>  import org.springframework.http.HttpMethod;<br>  import org.springframework.security.config.annotation.web.builders.HttpSecurity;<br>  import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;<br>  import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;<br>  import org.springframework.security.config.http.SessionCreationPolicy;    @Configuration<br>  @EnableWebSecurity<br>  public class SecurityConfig extends WebSecurityConfigurerAdapter {  <pre><code>  @Override  
  protected void configure(HttpSecurity http) throws Exception &#123;  
      http.csrf().disable()  
              .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS)  
              .and()  
              .authorizeRequests()  
              .antMatchers(&quot;/player/add&quot;, &quot;/player/remove&quot;).hasIpAddress(&quot;127.0.0.1&quot;)//只允许本地访问  
              .antMatchers(HttpMethod.OPTIONS).permitAll()  
              .anyRequest().authenticated();  
  &#125;  
</code></pre>
  }  </li>
</ul>
</li>
<li>将<code>matchingsystem</code>下的<code>Main</code>文件重命名为<code>MatchingSystemApplication</code>，并修改为<code>SpringWeb</code>的入口文件<img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/image-20230307215346426.png" alt="image-20230307215346426"></li>
<li>启动<code>MatchingSystemApplication</code>项目，访问本地<code>3040</code>端口，结果如下，即为成功<img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/image-20230307215529013.png"></li>
<li>重新创建一个子模块<code>backend</code> <img src="C:\Users\chjm\AppData\Roaming\Typora\typora-user-images\image-20230310163002032.png" alt="image-20230310163002032" style="zoom:67%;" />

<ol start="12">
<li>删除其<code>src</code>文件夹，再将之前<code>backend</code>里的<code>src</code>文件复制过来，并将其<code>pom</code>里依赖复制过来。</li>
<li>创建<code>RestTemplateConfig</code>Bean，它的作用是<strong>几个子项目之间通信</strong>package com.kob.backend.config;  import org.springframework.context.annotation.Bean;<br>import org.springframework.context.annotation.Configuration;<br>import org.springframework.web.client.RestTemplate;  @Configuration<br>public class RestTemplateConfig {  <pre><code>@Bean  
public RestTemplate getRestTemplate()&#123;  
    return new RestTemplate();  
&#125;  
</code></pre>
}并注入到<code>WebSocketServer</code>中：@Component<br>@ServerEndpoint(“/websocket/{token}”)  // 注意不要以’/‘结尾<br>public class WebSocketServer {  <pre><code>// 子模块通信的url  
private final static String addPlayerUrl =  &quot;http://127.0.0.1:3040/player/add&quot;;  
private final static String removePlayerUrl =  &quot;http://127.0.0.1:3040/player/remove&quot;;  
  
// 注入RestTemplateConfig  
private static RestTemplate restTemplate;  
@Autowired  
public void setRestTemplate(RestTemplate restTemplate) &#123;  
    WebSocketServer.restTemplate = restTemplate;  
&#125;     
  
// 开始匹配时  
private void  startMatching()&#123;  
    MultiValueMap&lt;String,String&gt; data = new LinkedMultiValueMap&lt;&gt;();  
    data.add(&quot;user_id&quot;,this.user.getId().toString());  
    data.add(&quot;rating&quot;,this.user.getRating().toString());  
    restTemplate.postForObject(addPlayerUrl,data,String.class); // 发送给匹配系统服务  
&#125;  

// 结束匹配时  
private void  stopMatching()&#123;  
    MultiValueMap&lt;String,String&gt; data = new LinkedMultiValueMap&lt;&gt;();  
    data.add(&quot;user_id&quot;,this.user.getId().toString());  
    restTemplate.postForObject(removePlayerUrl,data,String.class); // 发送给匹配系统服务  
&#125;  
</code></pre>
}这里<code>restTemplate.postForObject(addPlayerUrl,data,String.class)</code>通过<code>post</code>给<code>matching Server</code>发送信息，而<code>Match Server</code>通过如下代码接受消息：@RestController<br>public class MatchingController {  <pre><code>@Autowired  
private MatchingService matchingService;  

@PostMapping(&quot;/player/add&quot;)  
public String addPlayer(@RequestParam MultiValueMap&lt;String, String&gt; data) &#123; // 这里必须是MultiValueMap  
    Integer userId = Integer.parseInt(Objects.requireNonNull(data.getFirst(&quot;user_id&quot;)));  
    Integer rating = Integer.parseInt(Objects.requireNonNull(data.getFirst(&quot;rating&quot;)));  
    return matchingService.addPlayer(userId, rating);  
&#125;  
</code></pre>
}</li>
</ol>
</li>
</ol>
<h2 id="Bot代码执行"><a href="#Bot代码执行" class="headerlink" title="Bot代码执行"></a>Bot代码执行</h2><ol>
<li>创建<code>SpringCloud</code>的子项目<code>BotRunningSystem</code></li>
<li>在<code>BotRunningSystem</code>项目中添加依赖：<a target="_blank" rel="noopener" href="https://mvnrepository.com/">Maven仓库地址</a><ul>
<li><code>joor-java-8</code>：java代码编译</li>
<li><code>spring-cloud-dependencies</code></li>
<li><code>spring-boot-starter-security</code> ：网关</li>
<li><code>lombok</code> : 自动实现类的构建、getter、eques方法</li>
</ul>
</li>
<li>创建<code>controller</code>,<code>service</code>,<code>config</code>等层，并创建启动文件<code>BotRunningSystemApplication</code> @SpringBootApplication<br> public class BotRunningSystemApplication {  <pre><code> public static void main(String[] args) &#123;  
     // 启动匹配池线程  
     // 运行spring服务  
     SpringApplication.run(BotRunningSystemApplication.class, args);  
 &#125;  
</code></pre>
 } 然后在<code>resources/application.properties</code>中配置端口号，并在<code>config</code>中创建如下文件： <code>RestTemplateConfig</code>，用于子服务之间通信 @Configuration<br> @EnableWebSecurity<br> public class SecurityConfig extends WebSecurityConfigurerAdapter {  <pre><code> @Override  
 protected void configure(HttpSecurity http) throws Exception &#123;  
     http.csrf().disable()  
             .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS)  
             .and()  
             .authorizeRequests()  
             .antMatchers(&quot;/bot/add&quot;).hasIpAddress(&quot;127.0.0.1&quot;) // 只允许本地访问  
             .antMatchers(HttpMethod.OPTIONS).permitAll()  
             .anyRequest().authenticated();  
 &#125;  
</code></pre>
 }   <code>SecurityConfig</code>，起到网关的作用 @Configuration<br> public class RestTemplateConfig {  <pre><code> @Bean  
 public RestTemplate getRestTemplate()&#123;  
     return new RestTemplate();  
 &#125;  
</code></pre>
 }</li>
</ol>
<h2 id="分页功能"><a href="#分页功能" class="headerlink" title="分页功能"></a>分页功能</h2><p>在<code>config.MybatisConfig</code>中添加分页配置：</p>
<p>package com.kob.backend.config;  </p>
<p>import com.baomidou.mybatisplus.annotation.DbType;<br>import com.baomidou.mybatisplus.extension.plugins.MybatisPlusInterceptor;<br>import com.baomidou.mybatisplus.extension.plugins.inner.PaginationInnerInterceptor;<br>import org.springframework.context.annotation.*;  </p>
<p>/**  </p>
<ul>
<li>MyBatisPlus配置类  </li>
<li>/<br>@Configuration<br>public class MyBatisPlusConfig {    /**  <ul>
<li>MyBatisPlus拦截器（用于分页）  </li>
<li>/<br>@Bean<br>public MybatisPlusInterceptor paginationInterceptor() {<br>  MybatisPlusInterceptor interceptor = new MybatisPlusInterceptor();<br>  //添加MySQL的分页拦截器<br>  interceptor.addInnerInterceptor(new PaginationInnerInterceptor(DbType.MYSQL));<br>  return interceptor;<br>}<br>}  </li>
</ul>
</li>
</ul>
<h2 id="spring-整合Minio"><a href="#spring-整合Minio" class="headerlink" title="spring 整合Minio"></a>spring 整合Minio</h2><h3 id="1-腾讯云-ubuntu-系统改为-root-登陆"><a href="#1-腾讯云-ubuntu-系统改为-root-登陆" class="headerlink" title="1. 腾讯云 ubuntu 系统改为 root 登陆"></a>1. 腾讯云 ubuntu 系统改为 root 登陆</h3><p>因为腾讯云默认不是root用户，无法通过xftp传输文件，所以这里需要先修改下</p>
<h1 id="修改-root-密码"><a href="#修改-root-密码" class="headerlink" title="修改 root 密码"></a>修改 root 密码</h1><p>sudo passwd root  </p>
<h1 id="修改-ssh-配置"><a href="#修改-ssh-配置" class="headerlink" title="修改 ssh 配置"></a>修改 ssh 配置</h1><p>sudo vi /etc/ssh/sshd_config  </p>
<h1 id="修改PermitRootLogin-将它后面改为yes"><a href="#修改PermitRootLogin-将它后面改为yes" class="headerlink" title="修改PermitRootLogin 将它后面改为yes"></a>修改PermitRootLogin 将它后面改为yes</h1><p>:/PermitRootLogin  # 向光标之下寻找第一个值为word的字符串  按n为接着找下一个</p>
<p><img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/image-20230316100300151.png" alt="image-20230316100300151"></p>
<p>最后重启ssh服务即可,这样本地就可以通过ssh登录root用户了</p>
<p>sudo service ssh restart</p>
<h3 id="2-通过-docker-安装-Minio"><a href="#2-通过-docker-安装-Minio" class="headerlink" title="2. 通过 docker 安装 Minio"></a>2. 通过 docker 安装 Minio</h3><h1 id="搜索是否有-minio-镜像"><a href="#搜索是否有-minio-镜像" class="headerlink" title="搜索是否有 minio 镜像"></a>搜索是否有 minio 镜像</h1><p>docker search minio  </p>
<h1 id="有则拉取镜像"><a href="#有则拉取镜像" class="headerlink" title="有则拉取镜像"></a>有则拉取镜像</h1><p>docker pull minio/minio  </p>
<h1 id="先创建minio-文件和配置-存放的位置"><a href="#先创建minio-文件和配置-存放的位置" class="headerlink" title="先创建minio 文件和配置 存放的位置"></a>先创建minio 文件和配置 存放的位置</h1><p>sudo mkdir -p /home/chjm/docker/minio/data<br>sudo mkdir -p /home/chjm/docker/minio/config</p>
<h3 id="3-启动-及配置-Minio"><a href="#3-启动-及配置-Minio" class="headerlink" title="3. 启动 及配置 Minio"></a>3. 启动 及配置 Minio</h3><h4 id="配置https访问"><a href="#配置https访问" class="headerlink" title="配置https访问"></a>配置<code>https</code>访问</h4><p>需要将<code>ssl</code>证书中的<code>.key</code>，<code>.crt</code>，移动到<code>minio</code>的<code>/home/chjm/docker/minio/config</code>下面，并重命名为<code>private.key</code>和<code>public.crt</code>两个文件</p>
<p><img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/image-20230316103239444.png" alt="image-20230316103239444"></p>
<h4 id="启动minio"><a href="#启动minio" class="headerlink" title="启动minio"></a>启动minio</h4><p>这里需要在腾讯云开放9000和9090端口</p>
<h1 id="启动并指定端口"><a href="#启动并指定端口" class="headerlink" title="启动并指定端口"></a>启动并指定端口</h1><p>docker run -p 9000:9000 -p 9090:9090 \<br>     –net=host \<br>     –name minio \<br>     -d –restart=always \<br>     -e “MINIO_ACCESS_KEY=chjm” \<br>     -e “MINIO_SECRET_KEY=ldx186729..” \<br>     -e “MINIO_SERVER_URL=<a href="https://chjm.online:9000&quot;">https://chjm.online:9000&quot;</a> \<br>     -v /home/chjm/docker/minio/data:/data  \<br>     -v /home/chjm/docker/minio/config:/root/.minio  \<br>     minio/minio server \<br>     /data –console-address “:9090” -address “:9000”</p>
<blockquote>
<p>这里解释一下 docker 里面的几个参数</p>
<p>-p: 指定<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E7%AB%AF%E5%8F%A3%E6%98%A0%E5%B0%84&spm=1001.2101.3001.7020">端口映射</a>，格式为：主机（宿主）端口:容器端口</p>
<p>-e “MINIO_ROOT_USER=Jonny”: 设置环境变量；</p>
<p>-d: 后台运行容器，并返回容器ID；</p>
<p>-v: 绑定一个卷</p>
<p>9090端口指的是minio的客户端端口</p>
<p>MINIO_ACCESS_KEY ：账号</p>
<p>MINIO_SECRET_KEY ：密码（账号长度必须大于等于5，密码长度必须大于等于8位）</p>
<p>MINIO_SERVER_URL ：ssl证书绑定的域名 ，后面要加端口号 ，不然默认是443</p>
<p>-v /home/chjm/docker/minio/config:/root/.minio : 修改config文件夹的地址</p>
</blockquote>
<h3 id="4-登录Minio服务端"><a href="#4-登录Minio服务端" class="headerlink" title="4.登录Minio服务端"></a>4.登录Minio服务端</h3><p>访问<a target="_blank" rel="noopener" href="https://chjm.online:9090/login">https://chjm.online:9090/login</a>进行相关设置</p>
<p>首先下载key</p>
<p><img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/image-20230315091049492.png" alt="image-20230315091049492"></p>
<p>文件内容如下，保存文件，SDK操作文件的API需要用到</p>
<p>{“url”:”<a href="http://127.0.0.1:9000&quot;,&quot;accessKey&quot;:&quot;PM9mZ2mFvU5jFHkz&quot;,&quot;secretKey&quot;:&quot;Sds7XdVDQX7sFgUm1MqIbEwPAc02H7yl&quot;,&quot;api&quot;:&quot;s3v4&quot;,&quot;path&quot;:&quot;auto&quot;}">http://127.0.0.1:9000&quot;,&quot;accessKey&quot;:&quot;PM9mZ2mFvU5jFHkz&quot;,&quot;secretKey&quot;:&quot;Sds7XdVDQX7sFgUm1MqIbEwPAc02H7yl&quot;,&quot;api&quot;:&quot;s3v4&quot;,&quot;path&quot;:&quot;auto&quot;}</a></p>
<p>然后创建一个bucket</p>
<p><img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/image-20230315095349830.png" alt="image-20230315095349830"></p>
<p>记得开放桶的权限</p>
<p><img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/image-20230315183403197.png" alt="image-20230315183403197"></p>
<h3 id="4-SpringBoot-整合-MinIO"><a href="#4-SpringBoot-整合-MinIO" class="headerlink" title="4. SpringBoot 整合 MinIO"></a>4. SpringBoot 整合 MinIO</h3><h4 id="1-导入依赖"><a href="#1-导入依赖" class="headerlink" title="1.导入依赖"></a>1.导入依赖</h4><!-- https://mvnrepository.com/artifact/io.minio/minio -->  
<dependency>  
    <groupId>io.minio</groupId>  
    <artifactId>minio</artifactId>  
    <version>8.5.2</version>  
</dependency>

<h4 id="2-application-yml-配置信息"><a href="#2-application-yml-配置信息" class="headerlink" title="2. application.yml 配置信息"></a>2. application.yml 配置信息</h4><p>minio:<br>  endpoint: <a target="_blank" rel="noopener" href="https://chjm.online:9000/">https://chjm.online:9000</a> # Minio服务所在地址<br>  bucketName: kob #存储桶名称<br>  accessKey: PM9mZ2mFvU5jFHkz #访问的key<br>  secretKey: Sds7XdVDQX7sFgUm1MqIbEwPAc02H7yl #访问的秘钥</p>
<h4 id="3-MinioConfig-配置类"><a href="#3-MinioConfig-配置类" class="headerlink" title="3.MinioConfig 配置类"></a>3.MinioConfig 配置类</h4><p>@Data<br>@Configuration<br>@ConfigurationProperties(prefix = “minio”)<br>public class MinioConfig {  </p>
<pre><code>private String endpoint;  
private String accessKey;  
private String secretKey;  
private String bucketName;  

@Bean  
public MinioClient minioClient() &#123;  
    return MinioClient.builder()  
            .endpoint(endpoint)  
            .credentials(accessKey, secretKey)  
            .build();  
&#125;  
</code></pre>
<p>}</p>
<h4 id="4-MinioUtil工具类"><a href="#4-MinioUtil工具类" class="headerlink" title="4.MinioUtil工具类"></a>4.MinioUtil工具类</h4><p>package com.kob.backend.utils;  </p>
<p>@Component<br>@Slf4j<br>public class MinioUtil {<br>    @Autowired<br>    private MinioConfig prop;  </p>
<pre><code>@Resource  
private MinioClient minioClient;  

/**  
 * 查看存储bucket是否存在  
 * @return boolean  
 */  
public Boolean bucketExists(String bucketName) &#123;  
    Boolean found;  
    try &#123;  
        found = minioClient.bucketExists(BucketExistsArgs.builder().bucket(bucketName).build());  
    &#125; catch (Exception e) &#123;  
        e.printStackTrace();  
        return false;  
    &#125;  
    return found;  
&#125;  

/**  
 * 创建存储bucket  
 * @return Boolean  
 */  
public Boolean makeBucket(String bucketName) &#123;  
    try &#123;  
        minioClient.makeBucket(MakeBucketArgs.builder()  
                .bucket(bucketName)  
                .build());  
    &#125; catch (Exception e) &#123;  
        e.printStackTrace();  
        return false;  
    &#125;  
    return true;  
&#125;  
/**  
 * 删除存储bucket  
 * @return Boolean  
 */  
public Boolean removeBucket(String bucketName) &#123;  
    try &#123;  
        minioClient.removeBucket(RemoveBucketArgs.builder()  
                .bucket(bucketName)  
                .build());  
    &#125; catch (Exception e) &#123;  
        e.printStackTrace();  
        return false;  
    &#125;  
    return true;  
&#125;  
/**  
 * 获取全部bucket  
 */  
public List&lt;Bucket&gt; getAllBuckets() &#123;  
    try &#123;  
        List&lt;Bucket&gt; buckets = minioClient.listBuckets();  
        return buckets;  
    &#125; catch (Exception e) &#123;  
        e.printStackTrace();  
    &#125;  
    return null;  
&#125;  

// 获取当前时间  
public String getNowDate(String dateFormat) &#123;  
    Date currentTime = new Date();  
    SimpleDateFormat formatter = new SimpleDateFormat(dateFormat);  
    String dateString = formatter.format(currentTime);  
    return dateString;  
&#125;  

/**  
 * 文件上传  
 *  
 * @param file 文件  
 * @return Boolean  
 */  
public String upload(MultipartFile file) &#123;  
    System.out.println(file);  
    String originalFilename = file.getOriginalFilename();  
    if (StringUtils.isBlank(originalFilename))&#123;  
        throw new RuntimeException();  
    &#125;  
    UUID uuid = UUID.randomUUID();  
    String uid = uuid.toString().substring(0, 10);  
    String fileName = uid + originalFilename.substring(originalFilename.lastIndexOf(&quot;.&quot;));  
    String objectName = getNowDate(&quot;dd-MM-yyyy&quot;) + &quot;/&quot; + fileName;  // 中间加个/ 意味着是在一个文件夹下  
    InputStream in = null;  
    try &#123;  
        in = file.getInputStream();  
        PutObjectArgs objectArgs = PutObjectArgs.builder()  
                .bucket(prop.getBucketName())  
                .object(objectName)  
                .stream(in, in.available(), -1)  
                .contentType(file.getContentType()).build();  
        //文件名称相同会覆盖  
        minioClient.putObject(objectArgs);  
    &#125; catch (Exception e) &#123;  
        e.printStackTrace();  
        return null;  
    &#125;finally &#123;  
        if (in != null) &#123;  
            try &#123;  
                in.close();  
            &#125; catch (IOException e) &#123;  
                e.printStackTrace();  
            &#125;  
        &#125;  
    &#125;  
    return objectName;  
&#125;  

/**  
 * 预览图片  
 * @param fileName  
 * @return  
 */  
public String preview(String fileName)&#123;  
    // 查看文件地址  
    GetPresignedObjectUrlArgs build = new GetPresignedObjectUrlArgs().builder().bucket(prop.getBucketName()).object(fileName).method(Method.GET).build();  
    try &#123;  
        String url = minioClient.getPresignedObjectUrl(build);  
        return url;  
    &#125; catch (Exception e) &#123;  
        e.printStackTrace();  
    &#125;  
    return null;  
&#125;  

/**  
 * 文件下载  
 * @param fileName 文件名称  
 * @param res response  
 * @return Boolean  
 */  
public void download(String fileName, HttpServletResponse res) &#123;  
    GetObjectArgs objectArgs = GetObjectArgs.builder().bucket(prop.getBucketName())  
            .object(fileName).build();  
    try (GetObjectResponse response = minioClient.getObject(objectArgs))&#123;  
        byte[] buf = new byte[1024];  
        int len;  
        try (FastByteArrayOutputStream os = new FastByteArrayOutputStream())&#123;  
            while ((len=response.read(buf))!=-1)&#123;  
                os.write(buf,0,len);  
            &#125;  
            os.flush();  
            byte[] bytes = os.toByteArray();  
            res.setCharacterEncoding(&quot;utf-8&quot;);  
            // 设置强制下载不打开  
            // res.setContentType(&quot;application/force-download&quot;);  
            res.addHeader(&quot;Content-Disposition&quot;, &quot;attachment;fileName=&quot; + fileName);  
            try (ServletOutputStream stream = res.getOutputStream())&#123;  
                stream.write(bytes);  
                stream.flush();  
            &#125;  
        &#125;  
    &#125; catch (Exception e) &#123;  
        e.printStackTrace();  
    &#125;  
&#125;  

/**  
 * 查看文件对象  
 * @return 存储bucket内文件对象信息  
 */  
public List&lt;Item&gt; listObjects() &#123;  
    Iterable&lt;Result&lt;Item&gt;&gt; results = minioClient.listObjects(  
            ListObjectsArgs.builder().bucket(prop.getBucketName()).build());  
    List&lt;Item&gt; items = new ArrayList&lt;&gt;();  
    try &#123;  
        for (Result&lt;Item&gt; result : results) &#123;  
            items.add(result.get());  
        &#125;  
    &#125; catch (Exception e) &#123;  
        e.printStackTrace();  
        return null;  
    &#125;  
    return items;  
&#125;  

/**  
 * 删除  
 * @param fileName  
 * @return  
 * @throws Exception  
 */  
public boolean remove(String fileName)&#123;  
    try &#123;  
        minioClient.removeObject( RemoveObjectArgs.builder().bucket(prop.getBucketName()).object(fileName).build());  
    &#125;catch (Exception e)&#123;  
        return false;  
    &#125;  
    return true;  
&#125;  
</code></pre>
<p>}  </p>
<h4 id="5-文件处理接口"><a href="#5-文件处理接口" class="headerlink" title="5.文件处理接口"></a>5.文件处理接口</h4><h5 id="后端"><a href="#后端" class="headerlink" title="后端"></a>后端</h5><p><code>UploadImageService</code>层</p>
<p>package com.kob.backend.service.user.account;  </p>
<p>@Component<br>public interface UploadImageService {<br>    public JsonResult<JSONObject> uploadImage (MultipartFile file);<br>}</p>
<p><code>UploadImageServiceImpl</code>层</p>
<p>package com.kob.backend.service.impl.user.account;  </p>
<p>@Service<br>public class UploadImageServiceImpl implements UploadImageService {<br>    @Autowired<br>    private MinioUtil minioUtil;<br>    @Autowired<br>    private MinioConfig prop;<br>    @Override<br>    public JsonResult<JSONObject> uploadImage(MultipartFile file) {<br>        System.out.println(file);<br>        String objectName = minioUtil.upload(file);<br>        JSONObject resp = new JSONObject();<br>        if (null != objectName) {<br>            resp.put(“url”,(prop.getEndpoint() + “/“ + prop.getBucketName() + “/“ + objectName));<br>            return  new JsonResult&lt;&gt;(resp);<br>        }<br>        return new JsonResult&lt;&gt;(1,”上传失败”);<br>    }<br>}</p>
<p><code>UploadImageController</code>层</p>
<p>package com.kob.backend.controller.user.account;  </p>
<p>@RestController<br>@RequestMapping(“api/user/account/“)<br>public class UploadImageController {  </p>
<pre><code>@Autowired  
private UploadImageService uploadImageService;  

@PostMapping(&quot;uploadImage&quot;)  
public JsonResult&lt;JSONObject&gt; uploadImage(@RequestBody MultipartFile file)&#123;  
    return  uploadImageService.uploadImage(file);  
&#125;  
</code></pre>
<p>}  </p>
<h5 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h5><p>axio接口</p>
<p>export function uploadImage(formData: FormData) {<br>  return hyRequest.post&lt;IDataType&lt;{ url: string }&gt;&gt;({<br>    url: userAPI.uploadImage,<br>    data: formData,<br>    showLoading: false,<br>   // psot发送FormData类型的数据需将请求头设置为 multipart/form-data<br>    headers: { “Content-Type”: “multipart/form-data” },<br>  });<br>}</p>
<p>vue组件</p>
<template>  
      <el-upload  
        action="none"  
        :auto-upload="false"  
        :on-change="handleUploadChange"  
      >  
        <el-button type="primary">Click to upload</el-button>  
      </el-upload>  
</template>  
  
<script lang="ts" setup>  
const handleUploadChange: UploadProps["onChange"] = async (  
  uploadFile,  
  uploadFiles  
) => {  
  let formData = new FormData();  
  formData.append("file", uploadFile.raw as any);  
  const res = await uploadImage(formData);  
  console.log(res);  
};  
  
</script>  
<h2 id="上线服务"><a href="#上线服务" class="headerlink" title="上线服务"></a>上线服务</h2><h3 id="配置docker容器"><a href="#配置docker容器" class="headerlink" title="配置docker容器"></a>配置docker容器</h3><p>将<code>AC Terminal</code>里的<code>django_lesson:1.0</code>镜像传到服务器上</p>
<p><code>cd /var/lib/acwing/docker/images/</code></p>
<p><img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/image-20230314174452964.png" alt="image-20230314174452964"></p>
<p>然后在服务器上</p>
<h1 id="将镜像加载到本地"><a href="#将镜像加载到本地" class="headerlink" title="将镜像加载到本地"></a>将镜像加载到本地</h1><p>docker load -i django_lesson_1_0.tar   </p>
<h1 id="利用该镜像，创建并启动一个容器，开放相关kob项目所需的端口，并设置name为kob-docker-server"><a href="#利用该镜像，创建并启动一个容器，开放相关kob项目所需的端口，并设置name为kob-docker-server" class="headerlink" title="利用该镜像，创建并启动一个容器，开放相关kob项目所需的端口，并设置name为kob_docker_server"></a>利用该镜像，创建并启动一个容器，开放相关kob项目所需的端口，并设置name为kob_docker_server</h1><p>docker run -p 20000:22 -p 443:443 -p 80:80 -p 3030:3030 -p 3040:3040 -p 3050:3050 –name kob_docker_server -itd django_lesson:1.0  </p>
<h1 id="进入创建的docker容器"><a href="#进入创建的docker容器" class="headerlink" title="进入创建的docker容器"></a>进入创建的docker容器</h1><p>docker attach kob_docker_server    </p>
<h1 id="更新root用户密码"><a href="#更新root用户密码" class="headerlink" title="更新root用户密码"></a>更新root用户密码</h1><p>passwd </p>
<blockquote>
<p>这里腾讯云里也要开启20000端口</p>
</blockquote>
<p>为防止root用户权限过大，导致误操作，先在root账户下添加一个新用户</p>
<p>adduser chjm  # 创建用户chjm<br>usermod -aG chjm  # 给用户chjm分配sudo权限<br>adduser chjm sudo # 将用户名chjm添加到sudoers文件<br>su chjm  # 切换到chjm用户</p>
<p>然后<code>ctrl+p</code>,<code>ctrl+q</code>挂起，通过<code>ssh</code>进行连接，注意这里连接的端口号是<code>20000</code>，</p>
<p>然后将祖传配置传到<code>root</code>文件夹和<code>chjm</code>文件夹下</p>
<blockquote>
<p>这里登录root用户使用<code>xftp</code>传才有权限进入root目录</p>
</blockquote>
<p><img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/image-20230314181424294.png" alt="image-20230314181424294"></p>
<p>sudo cp .bashrc .vimrc .tmux.conf /root<br>sudo cp .bashrc .vimrc .tmux.conf /home/chjm</p>
<p>然后创建<code>/home/chjm/kob</code>文件夹，并在其中创建<code>backcloud</code>，<code>web</code>文件夹</p>
<p><img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/image-20230316105437026.png" alt="image-20230316105437026"></p>
<h3 id="安装、配置mysql"><a href="#安装、配置mysql" class="headerlink" title="安装、配置mysql"></a>安装、配置mysql</h3><p><strong>安装</strong></p>
<h1 id="先更新"><a href="#先更新" class="headerlink" title="先更新"></a>先更新</h1><p>sudo apt-get update   </p>
<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>sudo apt-get install mysql-server  </p>
<h1 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h1><p>sudo service mysql start # 可以输入top 查看启动的进程  </p>
<h1 id="登录"><a href="#登录" class="headerlink" title="登录"></a>登录</h1><p>sudo mysql -u root  </p>
<h1 id="在mysql下设置root用户的密码"><a href="#在mysql下设置root用户的密码" class="headerlink" title="在mysql下设置root用户的密码"></a>在mysql下设置root用户的密码</h1><p>ALTER USER ‘root‘@’localhost’ IDENTIFIED WITH caching_sha2_password BY ‘yourpasswd’;  # yourpasswd为要输入密码    </p>
<h1 id="退出"><a href="#退出" class="headerlink" title="退出"></a>退出</h1><p>exit</p>
<p><strong>登录<code>mysql</code>，创建<code>kob</code>数据库，并进入<code>kob</code></strong></p>
<h1 id="密码登录"><a href="#密码登录" class="headerlink" title="密码登录"></a>密码登录</h1><p>sudo mysql -u root -p  </p>
<h1 id="创建kob数据库"><a href="#创建kob数据库" class="headerlink" title="创建kob数据库"></a>创建kob数据库</h1><p>create database kob; # show databases; 查看当前所有数据库  </p>
<h1 id="进入kob数据库"><a href="#进入kob数据库" class="headerlink" title="进入kob数据库"></a>进入kob数据库</h1><p>use kob;  </p>
<p>show tables;  # 可以查看当前所有表</p>
<blockquote>
<p>注意 ：mysql里面输入命令行 最后都需要加<code>；</code></p>
</blockquote>
<p><strong>在<code>kob</code>数据库下创建表：</strong></p>
<p>复制<code>idea</code>生产的DDL</p>
<p><img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/image-20230313211347346.png" alt="image-20230313211347346"></p>
<p>在云端创建sql文件，并将复制的DDL粘贴过去</p>
<p> sudo vim create_table.sql<br> :set paste<br> i<br> shift+insert</p>
<p><img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/image-20230313211806888.png" alt="image-20230313211806888"></p>
<h1 id="密码登录mysql"><a href="#密码登录mysql" class="headerlink" title="密码登录mysql"></a>密码登录mysql</h1><p>sudo mysql -u root -p  </p>
<h1 id="进入kob数据库-1"><a href="#进入kob数据库-1" class="headerlink" title="进入kob数据库"></a>进入kob数据库</h1><p>use kob;  </p>
<h1 id="执行脚本"><a href="#执行脚本" class="headerlink" title="执行脚本"></a>执行脚本</h1><p>source /home/chjm/kob/create_table.sql;</p>
<p><img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/image-20230314183609263.png" alt="image-20230314183609263"></p>
<h3 id="安装java"><a href="#安装java" class="headerlink" title="安装java"></a>安装java</h3><h1 id="先更新-1"><a href="#先更新-1" class="headerlink" title="先更新"></a>先更新</h1><p>sudo apt-get update      </p>
<h1 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h1><p>sudo apt-get install openjdk-8-jdk  </p>
<h1 id="验证是否安装成功"><a href="#验证是否安装成功" class="headerlink" title="验证是否安装成功"></a>验证是否安装成功</h1><p>java -version</p>
<h3 id="打包后端"><a href="#打包后端" class="headerlink" title="打包后端"></a>打包后端</h3><p><code>pom.xml</code>中添加配置：</p>
<p>三个服务都需要进行如下配置：</p>
<p>添加一行</p>
<p>// 打包的类型<br><packaging>jar</packaging></p>
<p>以及打包的相关配置</p>
<build>  
    <plugins>  
        <plugin>  
            <groupId>org.springframework.boot</groupId>  
            <artifactId>spring-boot-maven-plugin</artifactId>  
            <!--这里写上main方法所在类的路径-->  
            <configuration>  
                <mainClass>com.kob.backend.BackendApplication</mainClass>  
            </configuration>  
            <executions>  
                <execution>  
                    <goals>  
                        <goal>repackage</goal>  
                    </goals>  
                </execution>  
            </executions>  
        </plugin>  
    </plugins>  
</build>  

<blockquote>
<p><mainClass>com.kob.backend.BackendApplication</mainClass> 要改为三个包主文件相符的路径</p>
</blockquote>
<p><strong>注意打包前修改下mysql数据库的账户和密码与服务器里数据库设置的要相匹配</strong></p>
<p>然后使用<code>maven</code>进行打包,会在三个文件夹里生产<code>target</code>目录</p>
<p><img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/image-20230314084612859.png" alt="image-20230314084612859"></p>
<p>将各自<code>target</code>中的<code>jar</code>文件传到服务器即可</p>
<p><img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/image-20230314091644554.png" alt="image-20230314091644554"></p>
<p>将三个<code>jar</code>文件移动到<code>chjm/kob/backendcloud</code></p>
<h1 id="将三个jar文件移动到当前目录"><a href="#将三个jar文件移动到当前目录" class="headerlink" title="将三个jar文件移动到当前目录"></a>将三个jar文件移动到当前目录</h1><p>cp ~/*.jar .</p>
<p>然后使用<code>tmux</code>开启三个窗口，分别运行三个包</p>
<p>运行java后端<br>java -jar 包名<br>sudo java -jar botrunningsystem-0.0.1-SNAPSHOT.jar  # 注意因为这个服务需要读取文件 所以需要夹sudo权限</p>
<h3 id="打包前端"><a href="#打包前端" class="headerlink" title="打包前端"></a>打包前端</h3><p>请求接口配置</p>
<p><img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/image-20230314203919574.png" alt="image-20230314203919574"></p>
<p>websocket配置，这里需要改为wss</p>
<blockquote>
<p>http协议下使用ws，在https协议下使用wss</p>
<p>WS一般默认是80端口，而WSS默认是443端口，大多数网站用的就是80和433端口</p>
</blockquote>
<p>在打包后的<code>index.html</code>中添加如下代码，意思是自动将http的不安全请求升级为https</p>
<meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests">

<p>然后将打包的dist文件夹内的内容复制到服务器端</p>
<p><img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/image-20230314204408094.png" alt="image-20230314204408094"></p>
<h3 id="设置nginx"><a href="#设置nginx" class="headerlink" title="设置nginx"></a>设置nginx</h3><p>部署<code>ssl</code>证书</p>
<p>在腾讯云申请后，点击下载，并选择<code>Nginx</code>的配置文件</p>
<p><img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/image-20230316091726912.png" alt="image-20230316091726912"></p>
<p><img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/image-20230314095742527.png" alt="image-20230314095742527"></p>
<p>下载后如图：</p>
<p><img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/image-20230316091703426.png" alt="image-20230316091703426"></p>
<p>将<code>.key</code>和<code>.pem</code>文件传到到云端<code>etc/nginx/cert/</code>文件夹下</p>
<h1 id="默认是没有cert文件夹的"><a href="#默认是没有cert文件夹的" class="headerlink" title="默认是没有cert文件夹的"></a>默认是没有cert文件夹的</h1><p>sudo mkdir cert</p>
<p>使用<code>xftp</code>传文件，<code>kob_docker_server</code>需要使用<code>root</code>账户登录<strong>才有权限</strong>进入<code>/etc</code>文件下</p>
<p><img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/image-20230316091807404.png" alt="image-20230316091807404"></p>
<p>将下列内容写入<code>/etc/nginx/.conf</code>配置文件中</p>
<p>user www-data;<br>worker_processes auto;<br>pid /run/nginx.pid;<br>include /etc/nginx/modules-enabled/*.conf;  </p>
<p>events {<br>    worker_connections 768;<br>    # multi_accept on;<br>}  </p>
<p>http {  </p>
<pre><code>##  
# Basic Settings  
##  

sendfile on;  
tcp_nopush on;  
tcp_nodelay on;  
keepalive_timeout 65;  
types_hash_max_size 2048;  
# server_tokens off;  

# server_names_hash_bucket_size 64;  
# server_name_in_redirect off;  

include /etc/nginx/mime.types;  
default_type application/octet-stream;  

##  
# SSL Settings  
##  

ssl_protocols TLSv1 TLSv1.1 TLSv1.2 TLSv1.3; # Dropping SSLv3, ref: POODLE  
ssl_prefer_server_ciphers on;  

##  
# Logging Settings  
##  

access_log /var/log/nginx/access.log;  
error_log /var/log/nginx/error.log;  

##  
# Gzip Settings  
##  

gzip on;  

# gzip_vary on;  
# gzip_proxied any;  
# gzip_comp_level 6;  
# gzip_buffers 16 8k;  
# gzip_http_version 1.1;  
# gzip_types text/plain text/css application/json application/javascript text/xml application/xml application/xml+rss text/javascript;  

##  
# Virtual Host Configs  
##  

include /etc/nginx/conf.d/*.conf;  
include /etc/nginx/sites-enabled/*;  

server &#123;  
     listen 80;  
     server_name chjm.online;  
     rewrite ^(.*)$ https://$&#123;server_name&#125;$1 permanent;  
     &#125;  

server &#123;  
     #SSL 默认访问端口号为 443  
     listen 443 ssl;  
     #请填写绑定证书的域名  
     server_name chjm.online;   
     #请填写证书文件的相对路径或绝对路径  
     ssl_certificate  cert/chjm.online_bundle.pem;   
     #请填写私钥文件的相对路径或绝对路径  
     ssl_certificate_key cert/chjm.online.key;   
     ssl_session_timeout 5m;  
     #请按照以下套件配置，配置加密套件，写法遵循 openssl 标准。  
     ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4;  
     #请按照以下协议配置  
     ssl_protocols TLSv1.2 TLSv1.3;  
     ssl_prefer_server_ciphers on;  
     location / &#123;  
           #网站主页路径。此路径仅供参考，具体请您按照实际目录操作。   
           #例如，您的网站主页在 Nginx 服务器的 /etc/www 目录下，则请修改 root 后面的 html 为 /etc/www。  
           root /home/chjm/kob/web;   
            index index.html;  
            try_files $uri $uri/ /index.html;  
     &#125;  
      
    location /api &#123;  
            proxy_pass http://127.0.0.1:3030;  
        &#125;  
      
    location /websocket &#123;  
            proxy_pass http://127.0.0.1:3030;  
            proxy_set_header X-Real-IP $remote_addr;  
            proxy_set_header Host $http_host;  
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;  

            proxy_http_version 1.1;  
            proxy_set_header Upgrade $http_upgrade;  
            proxy_set_header Connection &quot;upgrade&quot;;  
            proxy_read_timeout  36000s;  
        &#125;  
&#125;  
</code></pre>
<p>}</p>
<p>然后启动<code>nginx</code></p>
<p>sudo /etc/init.d/nginx start  # 启动  </p>
<p>sudo /etc/init.d/nginx reload # 重启动</p>
<p>若为<code>fail</code></p>
<p><img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/image-20230314103040049.png" alt="image-20230314103040049"></p>
<p>可在<code>/var/log/nginxerror.log</code>查看报错信息。</p>
<p>cd /var/log/nginx<br>sudo vim error.log  </p>
<p>启动成功即可通过<a target="_blank" rel="noopener" href="https://chjm.online/">https://chjm.online</a>访问部署的网站</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://VernalScenery.github.io">Scenery</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://vernalscenery.github.io/2024/07/20/Java/SprintBoot%E6%A1%86%E6%9E%B6%E8%AF%BE/">https://vernalscenery.github.io/2024/07/20/Java/SprintBoot%E6%A1%86%E6%9E%B6%E8%AF%BE/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://VernalScenery.github.io" target="_blank">春和景明的记事本</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Spring/">Spring</a></div><div class="post_share"><div class="social-share" data-image="/./img/1.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2024/07/20/Java/Linux%20%E5%9F%BA%E7%A1%80%E8%AF%BE/" title="Linux 基础课"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Linux 基础课</div></div></a></div><div class="next-post pull-right"><a href="/2024/07/19/Other/OGC%E6%A0%87%E5%87%86/" title="OGC标准"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">OGC标准</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/./img/1.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Scenery</div><div class="author-info__description">今天不想跑，所以才去跑</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">59</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">12</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/chjm0121" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="/1595718686@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#SprintBoot%E6%A1%86%E6%9E%B6%E8%AF%BE"><span class="toc-text">SprintBoot框架课</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%85%8D%E7%BD%AEMysql%E4%B8%8E%E6%B3%A8%E5%86%8C%E7%99%BB%E5%BD%95%E6%A8%A1%E5%9D%97"><span class="toc-text">配置Mysql与注册登录模块</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-Mysql"><span class="toc-text">1. Mysql</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-mysql%E6%9C%8D%E5%8A%A1%E7%9A%84%E5%85%B3%E9%97%AD%E4%B8%8E%E5%90%AF%E5%8A%A8"><span class="toc-text">1.1 mysql服务的关闭与启动</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C"><span class="toc-text">1.2 常用操作</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-SpringBoot%E9%85%8D%E7%BD%AEmysql"><span class="toc-text">2. SpringBoot配置mysql</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E6%8E%A5%E5%8F%A3%E7%BC%96%E5%86%99%E6%95%B4%E4%BD%93%E6%B5%81%E7%A8%8B"><span class="toc-text">3.接口编写整体流程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-SpringBoot%E4%B8%AD%E7%9A%84%E5%90%84%E4%B8%AA%E5%B1%82"><span class="toc-text">3.1 SpringBoot中的各个层</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0"><span class="toc-text">3.2 具体实现</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E4%BF%AE%E6%94%B9Spring-Security"><span class="toc-text">4. 修改Spring Security</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-%E5%AE%89%E8%A3%85%E7%9B%B8%E5%85%B3%E4%BE%9D%E8%B5%96"><span class="toc-text">4.1 安装相关依赖</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-%E4%BF%AE%E6%94%B9security"><span class="toc-text">4.2 修改security</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-jwt%E9%AA%8C%E8%AF%81"><span class="toc-text">5. jwt验证</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5-1-%E5%AE%89%E8%A3%85%E7%9B%B8%E5%85%B3%E4%BE%9D%E8%B5%96"><span class="toc-text">5.1 安装相关依赖</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-2-%E7%BC%96%E5%86%99API"><span class="toc-text">5.2 编写API</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%96%E5%86%99API%E7%9A%84%E6%80%BB%E7%BB%93"><span class="toc-text">编写API的总结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8C%B9%E9%85%8D%E7%B3%BB%E7%BB%9F"><span class="toc-text">匹配系统</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%89%8D%E5%90%8E%E7%AB%AFWebSocekt%E8%BF%9E%E6%8E%A5"><span class="toc-text">1. 前后端WebSocekt连接</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%8E%E7%AB%AF%E9%9B%86%E6%88%90WebSocket"><span class="toc-text">后端集成WebSocket</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%89%8D%E7%AB%AF%E9%9B%86%E6%88%90WebSocket"><span class="toc-text">前端集成WebSocket</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%88%9B%E5%BB%BA%E5%BE%AE%E6%9C%8D%E5%8A%A1"><span class="toc-text">2.创建微服务</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Bot%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C"><span class="toc-text">Bot代码执行</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E9%A1%B5%E5%8A%9F%E8%83%BD"><span class="toc-text">分页功能</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#spring-%E6%95%B4%E5%90%88Minio"><span class="toc-text">spring 整合Minio</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E8%85%BE%E8%AE%AF%E4%BA%91-ubuntu-%E7%B3%BB%E7%BB%9F%E6%94%B9%E4%B8%BA-root-%E7%99%BB%E9%99%86"><span class="toc-text">1. 腾讯云 ubuntu 系统改为 root 登陆</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BF%AE%E6%94%B9-root-%E5%AF%86%E7%A0%81"><span class="toc-text">修改 root 密码</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BF%AE%E6%94%B9-ssh-%E9%85%8D%E7%BD%AE"><span class="toc-text">修改 ssh 配置</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BF%AE%E6%94%B9PermitRootLogin-%E5%B0%86%E5%AE%83%E5%90%8E%E9%9D%A2%E6%94%B9%E4%B8%BAyes"><span class="toc-text">修改PermitRootLogin 将它后面改为yes</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E9%80%9A%E8%BF%87-docker-%E5%AE%89%E8%A3%85-Minio"><span class="toc-text">2. 通过 docker 安装 Minio</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%90%9C%E7%B4%A2%E6%98%AF%E5%90%A6%E6%9C%89-minio-%E9%95%9C%E5%83%8F"><span class="toc-text">搜索是否有 minio 镜像</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9C%89%E5%88%99%E6%8B%89%E5%8F%96%E9%95%9C%E5%83%8F"><span class="toc-text">有则拉取镜像</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%88%E5%88%9B%E5%BB%BAminio-%E6%96%87%E4%BB%B6%E5%92%8C%E9%85%8D%E7%BD%AE-%E5%AD%98%E6%94%BE%E7%9A%84%E4%BD%8D%E7%BD%AE"><span class="toc-text">先创建minio 文件和配置 存放的位置</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%90%AF%E5%8A%A8-%E5%8F%8A%E9%85%8D%E7%BD%AE-Minio"><span class="toc-text">3. 启动 及配置 Minio</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%85%8D%E7%BD%AEhttps%E8%AE%BF%E9%97%AE"><span class="toc-text">配置https访问</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%AF%E5%8A%A8minio"><span class="toc-text">启动minio</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%90%AF%E5%8A%A8%E5%B9%B6%E6%8C%87%E5%AE%9A%E7%AB%AF%E5%8F%A3"><span class="toc-text">启动并指定端口</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E7%99%BB%E5%BD%95Minio%E6%9C%8D%E5%8A%A1%E7%AB%AF"><span class="toc-text">4.登录Minio服务端</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-SpringBoot-%E6%95%B4%E5%90%88-MinIO"><span class="toc-text">4. SpringBoot 整合 MinIO</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%AF%BC%E5%85%A5%E4%BE%9D%E8%B5%96"><span class="toc-text">1.导入依赖</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-application-yml-%E9%85%8D%E7%BD%AE%E4%BF%A1%E6%81%AF"><span class="toc-text">2. application.yml 配置信息</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-MinioConfig-%E9%85%8D%E7%BD%AE%E7%B1%BB"><span class="toc-text">3.MinioConfig 配置类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-MinioUtil%E5%B7%A5%E5%85%B7%E7%B1%BB"><span class="toc-text">4.MinioUtil工具类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E6%96%87%E4%BB%B6%E5%A4%84%E7%90%86%E6%8E%A5%E5%8F%A3"><span class="toc-text">5.文件处理接口</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%90%8E%E7%AB%AF"><span class="toc-text">后端</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%89%8D%E7%AB%AF"><span class="toc-text">前端</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%8A%E7%BA%BF%E6%9C%8D%E5%8A%A1"><span class="toc-text">上线服务</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%85%8D%E7%BD%AEdocker%E5%AE%B9%E5%99%A8"><span class="toc-text">配置docker容器</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%B0%86%E9%95%9C%E5%83%8F%E5%8A%A0%E8%BD%BD%E5%88%B0%E6%9C%AC%E5%9C%B0"><span class="toc-text">将镜像加载到本地</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%88%A9%E7%94%A8%E8%AF%A5%E9%95%9C%E5%83%8F%EF%BC%8C%E5%88%9B%E5%BB%BA%E5%B9%B6%E5%90%AF%E5%8A%A8%E4%B8%80%E4%B8%AA%E5%AE%B9%E5%99%A8%EF%BC%8C%E5%BC%80%E6%94%BE%E7%9B%B8%E5%85%B3kob%E9%A1%B9%E7%9B%AE%E6%89%80%E9%9C%80%E7%9A%84%E7%AB%AF%E5%8F%A3%EF%BC%8C%E5%B9%B6%E8%AE%BE%E7%BD%AEname%E4%B8%BAkob-docker-server"><span class="toc-text">利用该镜像，创建并启动一个容器，开放相关kob项目所需的端口，并设置name为kob_docker_server</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%BF%9B%E5%85%A5%E5%88%9B%E5%BB%BA%E7%9A%84docker%E5%AE%B9%E5%99%A8"><span class="toc-text">进入创建的docker容器</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9B%B4%E6%96%B0root%E7%94%A8%E6%88%B7%E5%AF%86%E7%A0%81"><span class="toc-text">更新root用户密码</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%89%E8%A3%85%E3%80%81%E9%85%8D%E7%BD%AEmysql"><span class="toc-text">安装、配置mysql</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%88%E6%9B%B4%E6%96%B0"><span class="toc-text">先更新</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AE%89%E8%A3%85"><span class="toc-text">安装</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%90%AF%E5%8A%A8"><span class="toc-text">启动</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%99%BB%E5%BD%95"><span class="toc-text">登录</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9C%A8mysql%E4%B8%8B%E8%AE%BE%E7%BD%AEroot%E7%94%A8%E6%88%B7%E7%9A%84%E5%AF%86%E7%A0%81"><span class="toc-text">在mysql下设置root用户的密码</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%80%80%E5%87%BA"><span class="toc-text">退出</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AF%86%E7%A0%81%E7%99%BB%E5%BD%95"><span class="toc-text">密码登录</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%88%9B%E5%BB%BAkob%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="toc-text">创建kob数据库</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%BF%9B%E5%85%A5kob%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="toc-text">进入kob数据库</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AF%86%E7%A0%81%E7%99%BB%E5%BD%95mysql"><span class="toc-text">密码登录mysql</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%BF%9B%E5%85%A5kob%E6%95%B0%E6%8D%AE%E5%BA%93-1"><span class="toc-text">进入kob数据库</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%89%A7%E8%A1%8C%E8%84%9A%E6%9C%AC"><span class="toc-text">执行脚本</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%89%E8%A3%85java"><span class="toc-text">安装java</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%88%E6%9B%B4%E6%96%B0-1"><span class="toc-text">先更新</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AE%89%E8%A3%85-1"><span class="toc-text">安装</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%AA%8C%E8%AF%81%E6%98%AF%E5%90%A6%E5%AE%89%E8%A3%85%E6%88%90%E5%8A%9F"><span class="toc-text">验证是否安装成功</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%93%E5%8C%85%E5%90%8E%E7%AB%AF"><span class="toc-text">打包后端</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%B0%86%E4%B8%89%E4%B8%AAjar%E6%96%87%E4%BB%B6%E7%A7%BB%E5%8A%A8%E5%88%B0%E5%BD%93%E5%89%8D%E7%9B%AE%E5%BD%95"><span class="toc-text">将三个jar文件移动到当前目录</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%93%E5%8C%85%E5%89%8D%E7%AB%AF"><span class="toc-text">打包前端</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E7%BD%AEnginx"><span class="toc-text">设置nginx</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%BB%98%E8%AE%A4%E6%98%AF%E6%B2%A1%E6%9C%89cert%E6%96%87%E4%BB%B6%E5%A4%B9%E7%9A%84"><span class="toc-text">默认是没有cert文件夹的</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/12/13/JS/14_JSLearn_%E6%A8%A1%E5%9D%97%E5%8C%96/" title="14_JSLearn_模块化">14_JSLearn_模块化</a><time datetime="2024-12-13T01:19:26.000Z" title="发表于 2024-12-13 09:19:26">2024-12-13</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/12/13/JS/13_JSLearn_%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/" title="13_JSLearn_异常处理">13_JSLearn_异常处理</a><time datetime="2024-12-13T00:28:47.000Z" title="发表于 2024-12-13 08:28:47">2024-12-13</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/12/12/JS/12_JSLearn_%E5%BC%82%E6%AD%A5%E5%87%BD%E6%95%B0%E3%80%81%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF-%E9%98%9F%E5%88%97/" title="12_JSLearn_异步函数、事件循环-队列">12_JSLearn_异步函数、事件循环-队列</a><time datetime="2024-12-12T00:47:24.000Z" title="发表于 2024-12-12 08:47:24">2024-12-12</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/12/11/JS/11_JSLearn_Iterator%E3%80%81Generator/" title="11_JSLearn_Iterator、Generator">11_JSLearn_Iterator、Generator</a><time datetime="2024-12-10T23:12:36.000Z" title="发表于 2024-12-11 07:12:36">2024-12-11</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/12/05/JS/10_JSLearn_Promise/" title="10_JSLearn_Promise">10_JSLearn_Promise</a><time datetime="2024-12-05T02:03:58.000Z" title="发表于 2024-12-05 10:03:58">2024-12-05</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('/./img/1.jpg')"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By Scenery</div><div class="footer_custom_text"><div>波澜不惊</div><div class="footer-div"><img class="footer-icon" src="./img/备案图标.png"><a class="footer-a" target="_blank" rel="noopener" href="http://beian.miit.gov.cn/">皖ICP备2021016944号-1</a></div></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.13.0"></script><script src="/js/main.js?v=4.13.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@5.2.0/instantpage.min.js" type="module"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=4.13.0"></script></div></div></body></html>