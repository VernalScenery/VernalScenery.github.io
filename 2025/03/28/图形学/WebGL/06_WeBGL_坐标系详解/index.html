<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>07_WeBGL_坐标系详解 | 春和景明的记事本</title><meta name="author" content="Scenery"><meta name="copyright" content="Scenery"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="坐标系1 坐标系分类WebGL 坐标系分为如下几类： 模型坐标系 -&amp;gt; 世界坐标系 -&amp;gt; 观察坐标系（又称相机坐标系、视图坐标系）-&amp;gt; 裁剪坐标系（gl_Position 接收的值）-&amp;gt; NDC 坐标系 -&amp;gt; 屏幕坐标系 123456graph LRA[模型坐标系] -"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://vernalscenery.github.io/2025/03/28/%E5%9B%BE%E5%BD%A2%E5%AD%A6/WebGL/06_WeBGL_%E5%9D%90%E6%A0%87%E7%B3%BB%E8%AF%A6%E8%A7%A3/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=4.13.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '07_WeBGL_坐标系详解',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2025-08-05 14:17:15'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><link rel="stylesheet" href="/css/style.css"><meta name="generator" content="Hexo 5.4.2"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/./img/1.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">73</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">13</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/./img/1.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="春和景明的记事本"><span class="site-name">春和景明的记事本</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">07_WeBGL_坐标系详解</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-03-28T01:05:30.000Z" title="发表于 2025-03-28 09:05:30">2025-03-28</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-08-05T06:17:15.000Z" title="更新于 2025-08-05 14:17:15">2025-08-05</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">13.1k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>47分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="07_WeBGL_坐标系详解"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="坐标系"><a href="#坐标系" class="headerlink" title="坐标系"></a>坐标系</h1><h2 id="1-坐标系分类"><a href="#1-坐标系分类" class="headerlink" title="1 坐标系分类"></a>1 坐标系分类</h2><p>WebGL 坐标系分为如下几类：</p>
<p>模型坐标系 -&gt; 世界坐标系 -&gt; 观察坐标系（又称相机坐标系、视图坐标系）-&gt; 裁剪坐标系（<code>gl_Position</code> 接收的值）-&gt; NDC 坐标系 -&gt; 屏幕坐标系</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">A[模型坐标系] --&gt; B[世界坐标系]</span><br><span class="line">B --&gt; C[视图坐标系]</span><br><span class="line">C --&gt; D[裁剪坐标系]</span><br><span class="line">D --&gt; E[NDC坐标系]</span><br><span class="line">E --&gt; F[屏幕坐标系]</span><br></pre></td></tr></table></figure>

<h3 id="1-1-模型坐标系（Model-Space）"><a href="#1-1-模型坐标系（Model-Space）" class="headerlink" title="1.1 模型坐标系（Model Space）"></a>1.1 模型坐标系（Model Space）</h3><ul>
<li><strong>作用</strong>：用于定义物体自身的局部几何结构。</li>
<li><strong>意义</strong>：建模时使用直观易懂的坐标（例如一个箱子的尺寸为 10x10x10），便于设计和理解。</li>
</ul>
<p>一个物体通常由很多点构成，每个点在模型的什么位置？我们需要用一个坐标系来参照，这个坐标系就叫模型坐标系，<strong>模型坐标系原点通常在模型的中心</strong>，各个坐标轴<strong>遵循右手坐标系</strong>，即 X 轴向右，Y 轴向上，Z 轴朝向屏幕外。</p>
<p>一般在建模软件中创建模型的时候，各个顶点的坐标都是以模型的某一个点为参照点建立的。</p>
<h3 id="1-2-世界坐标系（World-Space）"><a href="#1-2-世界坐标系（World-Space）" class="headerlink" title="1.2 世界坐标系（World Space）"></a>1.2 世界坐标系（World Space）</h3><ul>
<li><strong>作用</strong>：将多个物体统一放置到同一个场景中。</li>
<li><strong>意义</strong>：各个物体可能在模型坐标系中定义各自位置，但要在场景中正确组合，它们需要转换到同一坐标系中。</li>
</ul>
<p>我们创建好的模型需要放置在世界中的各个位置，默认情况模型坐标系和世界坐标系重合。如果模型不在世界坐标系中心，那么就需要对模型坐标系进行转换，将模型的各个相对于模型中心的顶点坐标转换成世界坐标系下的坐标。</p>
<p>世界坐标系也是<strong>遵循右手坐标系</strong>，X 轴水平向右，Y 轴垂直向上，Z 轴指向屏幕外面。</p>
<p>假如模型中有一点 P ，相对于模型中心的坐标（1，1）。</p>
<p>该模型在世界坐标系的（3，0）位置，那么，顶点 P 在世界坐标系中的坐标就变成了（<strong>4，1</strong>）。</p>
<h3 id="1-3-观察坐标系-视图坐标系（View-Camera-Space）"><a href="#1-3-观察坐标系-视图坐标系（View-Camera-Space）" class="headerlink" title="1.3 观察坐标系/视图坐标系（View/Camera Space）"></a>1.3 观察坐标系/视图坐标系（View/Camera Space）</h3><ul>
<li><strong>作用</strong>：根据摄像机（观察者）的视角对世界进行观察转换。</li>
<li><strong>意义</strong>：将场景中所有物体从摄像机视角重新排列，使得摄像机位于原点，便于后续的投影运算。</li>
</ul>
<p>观察坐标系是将世界空间坐标转化为用户视野前方的坐标而产生的结果。人眼或者摄像机看到的世界中的物体相对于他自身的位置所参照的坐标系就叫观察坐标系。</p>
<p>在我们日常生活中，精准描述一个街道，我们一般用经纬度来表示，但是如果有人问你：某某街道在什么位置？如果我们告诉他世界坐标：某某街道在东经 M 度，北纬 N 度，我想他会打你。。</p>
<p>一般我们都会用这样易于理解的描述：在 <code>前面多远，往左或右走多远</code>。</p>
<p>这种坐标就称为观察坐标，也叫相机坐标，他是<strong>以人眼/摄像机为原点而建立的坐标系</strong>。</p>
<p>之所以有相机坐标系，是为了模仿人眼看待世界的效果。世界很大，有很多物体，但是不能把整个世界都显示到屏幕上，只显示人眼所能看到的一部分，这样我们就能通过改变 <code>人眼所处的方位</code>，<code>人眼所在的位置</code>，看到整个 3D 空间的不同部分。</p>
<h3 id="1-4-裁剪坐标系（Clip-Space）"><a href="#1-4-裁剪坐标系（Clip-Space）" class="headerlink" title="1.4 裁剪坐标系（Clip Space）"></a>1.4 裁剪坐标系（Clip Space）</h3><ul>
<li><strong>作用</strong>：通过投影变换（正交或透视）将观察坐标转换到一个统一的四维坐标表示中。</li>
<li><strong>意义</strong>：这一步结合了深度信息（通过齐次坐标的 w 分量），为后续的裁剪操作做准备。所有顶点在这里都表示为 4 维向量，并存储在 <code>gl_Position</code> 中。</li>
</ul>
<p>裁剪坐标是将相机坐标进行投影变换后得到的坐标，也就是 <code>gl_Position</code> 接收的坐标，顾名思义，以裁剪坐标系为参照。</p>
<p>裁剪坐标系遵循 <code>左手坐标系</code>。</p>
<p>相机坐标系观察的空间是整个 3D 世界，而裁剪坐标系是希望所有的坐标都落在一个特定的范围内，超出这个范围的顶点坐标都将被裁剪掉，被裁剪掉的坐标就不会显示，这就是裁剪坐标系的由来。</p>
<p>我们将坐标全部表示成 <code>[-1.0 , 1.0]</code> 之间的方式不是很直观，所以我们希望先将观察空间中的某一部分裁剪出来，这一部分作为要显示的区域。</p>
<p>比如，我们希望将各个坐标轴在 <code>[-1000-1000]</code> 范围内的空间区域作为可视空间区域，这一区域的所有物体都将显示到屏幕上。那么如果一个顶点 P 的坐标是 <code>(1300，500，10)</code>，那么它就会被裁剪掉，因为它没有坐落在可视空间区域。</p>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/10/23/1669ee4661f2b664~tplv-t2oaga2asx-image.image" alt="|590"></p>
<p>投影矩阵会创建一个观察箱 <code>Viewing Box</code>，称为平截头体 <code>Frustum</code>，出现在平截头体范围内的坐标最终都会显示在屏幕上。裁剪坐标系中的坐标转化到标准化设备坐标系的过程就很容易，这个过程被称之为投影 <code>Projection</code>，使用投影矩阵能将 3D 坐标投影很容易地映射到 2D 的标准设备坐标系中。</p>
<p>将观察坐标变换为裁剪坐标的投影矩阵可以为两种不同的形式，每种形式都定义了不同的平截头体。</p>
<ul>
<li>正射投影矩阵</li>
<li>透视投影矩阵</li>
</ul>
<h3 id="1-5-归一化设备坐标系（NDC-Normalized-Device-Coordinates）"><a href="#1-5-归一化设备坐标系（NDC-Normalized-Device-Coordinates）" class="headerlink" title="1.5 归一化设备坐标系（NDC, Normalized Device Coordinates）"></a>1.5 归一化设备坐标系（NDC, Normalized Device Coordinates）</h3><ul>
<li><strong>作用</strong>：通过 GPU 内部自动执行的透视除法（将裁剪坐标的 x, y, z 分量除以 w）得到。</li>
<li><strong>意义</strong>：确保所有顶点都落在 <code>[−1,1][-1, 1][−1,1]</code> 范围内，这个归一化范围方便 GPU 做裁剪操作，将视野外的顶点舍弃。</li>
<li><strong>W 分量反映深度信息，透视除法后 Z 值用于深度测试（如遮挡关系判断）</strong></li>
</ul>
<p>一旦所有顶点被变换到裁剪空间，GPU 会对裁剪坐标执行透视除法，在这个过程中 GPU 会将顶点坐标的 X，Y，Z 分量分别除以齐次 W 分量。这一步会在每一个顶点着色器运行的最后被自动执行。最终所有坐标分量的范围都会在【-1，1】之间，超出这个范围的坐标都将被 GPU 丢弃。</p>
<p>NDC 坐标系遵循<strong>左手坐标系</strong>，Z 轴朝向屏幕里面，Z 轴值越小，越靠近我们的眼睛</p>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/9/29/16624dfadfcfef91~tplv-t2oaga2asx-image.image" alt="|630"></p>
<p>我们可以通过开启 WebGL 的深度检测机制验证一下：</p>
<p>绘制两个三角形，第一个三角形各个顶点 Z 轴坐标为 -0.5，颜色为红色， 第二个三角形各个顶点 Z 轴坐标为 0，颜色为绿色。</p>
<p>开启深度检测前：</p>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/10/23/166a016e9c2fde05~tplv-t2oaga2asx-image.image"></p>
<p>可以看到，第二个三角形绘制在了前面。不是说左手坐标系吗？按理说 Z 轴越小的越靠近视野，就会显示在前面。其实，在深度检测不开启的情况下，哪个顶点越靠后绘制，哪个顶点就绘制在前面，这时 Z 轴坐标不再决定顶点是否绘制在前面。</p>
<p>开启深度检测后：</p>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/10/23/166a01846b1cbed0~tplv-t2oaga2asx-image.image"></p>
<p>深度检测开启之后，可以看到 Z 轴小的红色三角形显示在了前面，从而验证了 NDC 坐标系是左手坐标系。</p>
<h3 id="1-6-屏幕坐标系（Screen-Space）"><a href="#1-6-屏幕坐标系（Screen-Space）" class="headerlink" title="1.6 屏幕坐标系（Screen Space）"></a>1.6 屏幕坐标系（Screen Space）</h3><ul>
<li><strong>作用</strong>：通过视口变换（Viewport Transformation）将 NDC 坐标映射到实际的屏幕像素位置。</li>
<li><strong>意义</strong>：实现最终将渲染结果显示在用户屏幕上的效果。</li>
<li>​<strong>坐标系差异</strong>：<ul>
<li>​<strong>NDC 坐标系</strong>：中心原点，Y 轴向上，范围 <code>[-1,1]</code></li>
<li>​<strong>屏幕坐标系</strong>：左上原点，Y 轴向下，单位为像素</li>
</ul>
</li>
<li>​<strong>转换公式</strong>​（以 Canvas 尺寸为例）：<br><img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/20250328092008.png" alt="image.png"></li>
</ul>
<p>有了 NDC 坐标之后，GPU 会执行最后一步变换操作，<strong>视口变换</strong>，这个过程会将所有在【-1, 1】之间的坐标映射到屏幕空间中，并被变换成片段。</p>
<h2 id="2-坐标转换流水线"><a href="#2-坐标转换流水线" class="headerlink" title="2 坐标转换流水线"></a>2 坐标转换流水线</h2><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/10/22/1669b4e4af96327b~tplv-t2oaga2asx-image.image"></p>
<table>
<thead>
<tr>
<th>操作</th>
<th>公式</th>
<th>典型应用场景</th>
</tr>
</thead>
<tbody><tr>
<td>模型变换</td>
<td>Vworld​=Mmodel​⋅Vlocal​</td>
<td>物体放置、旋转、缩放</td>
</tr>
<tr>
<td>视图变换</td>
<td>Vview​=Mview​⋅Vworld​</td>
<td>相机移动和视角控制</td>
</tr>
<tr>
<td>投影变换</td>
<td>Vclip​=Mproj​⋅Vview​</td>
<td>3D 到 2D 投影方式选择</td>
</tr>
<tr>
<td>透视除法</td>
<td>Vndc​=(x/w,y/w,z/w)</td>
<td>处理透视变形效果</td>
</tr>
</tbody></table>
<h3 id="2-1-CPU-端的转换"><a href="#2-1-CPU-端的转换" class="headerlink" title="2.1 CPU 端的转换"></a>2.1 CPU 端的转换</h3><ul>
<li><strong>模型变换</strong>：将模型坐标转换到世界坐标系。这一步可以包含平移、旋转和缩放等变换，使得物体在场景中摆放到合适的位置。</li>
<li><strong>视图变换</strong>：将世界坐标转换到观察坐标系。通过摄像机参数（位置、朝向、上方向等）构造视图矩阵，让场景相对于摄像机重新定位。</li>
<li><strong>投影变换</strong>：将观察坐标转换到裁剪坐标系。根据选择的正交或透视投影，生成投影矩阵。透视投影会引入与深度相关的 <code>w</code> 分量，从而为后续的透视除法做准备。</li>
</ul>
<p>在这三个步骤中，开发者在 JavaScript 中计算和组合各个矩阵（例如使用模型矩阵、视图矩阵和投影矩阵的乘积），最终得到每个顶点在裁剪坐标系中的位置。然后这些裁剪坐标被传递给 GPU。</p>
<h3 id="2-2-GPU-端的转换"><a href="#2-2-GPU-端的转换" class="headerlink" title="2.2 GPU 端的转换"></a>2.2 GPU 端的转换</h3><ul>
<li><strong>透视除法</strong>：GPU 接收到裁剪坐标后，会自动对每个顶点进行透视除法，即将 <code>x</code>、<code>y</code> 和 <code>z</code> 分量除以 <code>w</code>。这样可以将顶点映射到 NDC 坐标系中，从而实现远处物体看起来更小的透视效果。</li>
<li><strong>视口变换</strong>：最后，GPU 将 NDC 坐标通过视口变换映射到屏幕坐标系，使得顶点显示在实际屏幕上指定的位置。</li>
</ul>
<h2 id="3-坐标变换举例"><a href="#3-坐标变换举例" class="headerlink" title="3 坐标变换举例"></a>3 坐标变换举例</h2><p>上面的描述大家可能不太理解，接下来我们就以一个简单的例子演示坐标系变换的步骤。</p>
<h3 id="3-1-模型坐标"><a href="#3-1-模型坐标" class="headerlink" title="3.1 模型坐标"></a>3.1 模型坐标</h3><p>我们以一个顶点 P 为例，该顶点在边长为 3 的正方体上，初始时顶点所在坐标系是模型坐标系，也就是相对于正方体中心位置，该顶点在模型坐标系中的坐标：</p>
<p>$P_m=（3，3，0）$</p>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/10/23/1669f6f2b6020078~tplv-t2oaga2asx-image.image"></p>
<h3 id="3-2-世界坐标系"><a href="#3-2-世界坐标系" class="headerlink" title="3.2 世界坐标系"></a>3.2 世界坐标系</h3><p>默认情况下，模型坐标和世界坐标系重合，那该顶点在世界坐标系下的坐标：</p>
<p>$P_w = (3, 3, 0)$</p>
<p>假设我们将立方体向右移动 5 个单位，向上移动 5 个单位，那么立方体的原点 O 在世界坐标系中的坐标就变成了：</p>
<p>$O_w = (5, 5, 0)$</p>
<p>那顶点 P 在世界坐标系的坐标也就变成了：</p>
<p>$P_w = P_m + O_w = (5+3, 5+3, 0+0) = (8, 8, 0)$</p>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/10/23/1669f79276462624~tplv-t2oaga2asx-image.image"></p>
<p>到这里也很容易理解。</p>
<h3 id="3-3-观察坐标系"><a href="#3-3-观察坐标系" class="headerlink" title="3.3 观察坐标系"></a>3.3 观察坐标系</h3><p>世界坐标系中有个人 <code>E</code> 在位置 (3, 3, 0) 处：</p>
<p>$E_w = (3, 3, 0)$</p>
<p>E 所看到的世界处于观察坐标系中，X 轴、Y 轴和世界坐标系一致，Z 轴和世界坐标系相反，指向屏幕里面。我们很容易就能想到世界坐标系在观察坐标系中的坐标为：</p>
<p>$O_e = -E_w = (-3, -3, 0)$</p>
<blockquote>
<p>$O_e$ 代表世界坐标系的原点在观察坐标系中的坐标。</p>
<p>如果摄像机在世界中位于 (3,3,0)，那么从摄像机的视角看，原本的世界原点会出现在 (-3,-3,0) 处</p>
</blockquote>
<p>因此顶点 P 在观察坐标系的坐标就变成了：</p>
<p>$P_e = P_w + O_e = (8, 8, 0) + (-3, -3, 0) = (5, 5, 0)$</p>
<blockquote>
<p>在观察坐标系中，顶点 P 相对于摄像机的位置为 (5,5,0)</p>
</blockquote>
<h3 id="3-4-裁剪坐标系"><a href="#3-4-裁剪坐标系" class="headerlink" title="3.4 裁剪坐标系"></a>3.4 裁剪坐标系</h3><p>这里我们为裁剪坐标系指定一个正射投影观察箱，观察箱左侧坐标 -5，右侧坐标 5，上方坐标 5，下方坐标 -5，近平面坐标 0， 远平面坐标 5，那么处于这个观察箱之间的顶点都将被转换到裁剪坐标系中。</p>
<blockquote>
<p>在正射投影中，我们将观察坐标系中的一个指定区域（称为观察箱）线性地映射到裁剪坐标系中，这个映射通常保证：</p>
<ul>
<li>X 轴：观察箱左侧的 -5 映射到 -1，右侧的 5 映射到 1</li>
<li>Y 轴：观察箱下侧的 -5 映射到 -1，上侧的 5 映射到 1</li>
<li>Z 轴：观察箱中，近平面（0）和远平面（5）的映射则依据具体的投影矩阵而定（这里用的是线性映射，中间值除以半范围 2.5，使得 z 值也归一化）</li>
</ul>
</blockquote>
<p>由于顶点 P 在观察坐标系的坐标为 (5, 5, 0)，所以它转变到裁剪坐标系下的坐标为：</p>
<p>$P_c = (5 / 5, 5 / 5, 0 / 2.5) = (1, 1, 0)$</p>
<blockquote>
<p>对于顶点 P 在观察坐标系中的坐标 (5, 5, 0) 来说：</p>
<ol>
<li><strong>X 轴转换</strong><br> 观察箱 x 范围为 -5 到 5，整个宽度为 10。<br> 映射公式中通常将 5 映射为 1（也可以理解为先平移再缩放），这里直接用除以 5（也就是 5/5=1）。</li>
<li><strong>Y 轴转换</strong><br> 同 X 轴，5/5=1，所以 y 分量也映射为 1。</li>
<li><strong>Z 轴转换</strong><br> 观察箱 z 范围为 0 到 5，中心位置是 2.5。这里用 2.5 作为缩放因子，使得 z 坐标归一化。对于 z=0，即 0/2.5=0。</li>
<li><strong>W 分量</strong><br> 正射投影下不会对顶点做非线性缩放，w 分量保持为 1，不会引入透视效应。</li>
</ol>
</blockquote>
<p>正射投影下， W 分量为 1，到了这一步就有了 W 分量：</p>
<p>$P_c =  (1, 1, 0, 1)$</p>
<h3 id="3-5-NDC-坐标系"><a href="#3-5-NDC-坐标系" class="headerlink" title="3.5 NDC 坐标系"></a>3.5 NDC 坐标系</h3><p><code>NDC</code> 坐标是在 <code>GPU</code> 中 将裁剪坐标执行透视除法，所以：</p>
<p>$P_n = (1/1, 1/1, 0/1, 1/1) = (1, 1, 0, 1)$</p>
<p>坐标没有改变。</p>
<h3 id="3-6-视口变换"><a href="#3-6-视口变换" class="headerlink" title="3.6 视口变换"></a>3.6 视口变换</h3><p>接下来该执行视口变换了，视口变换将 <code>NDC</code> 坐标映射到屏幕坐标系。这一步是将 3D 坐标转变成 2D 坐标，在 <code>GPU</code> 中执行，我们无法通过编程干预，</p>
<p>视口我们是通过 WebGL API 中的 <code>gl.viewport</code> 来 设置，我们可以设置任意尺寸的视口，这里我们设置宽 500 ，高 300 的尺寸。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gl.<span class="title function_">viewport</span>(<span class="number">0</span>, <span class="number">0</span>,  <span class="number">500</span>, <span class="number">300</span>);</span><br></pre></td></tr></table></figure>

<p>接下来 <code>GPU</code> 就会将 <code>NDC</code> 坐标映射到视口范围内，即将 【-1，1】 的立方体范围内的坐标映射到宽 500，高 300 的屏幕坐标范围。</p>
<p>我们仍然需要先找到 <code>NDC</code> 坐标系原点在 屏幕坐标系中的坐标。</p>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/3/27/169bcf47c921c68f~tplv-t2oaga2asx-image.image"></p>
<p>由于 <code>NDC</code> 坐标系 <code>X</code> 轴上的一个单位长度就等于视口宽度的一半，Y 轴上的一个单位长度等于视口高度的一半，所以 <code>NDC</code> 坐标系原点在屏幕坐标系下的坐标为</p>
<p>$O_s = (250, 150)$</p>
<p>又由于 NDC 坐标系 Y 轴方向和 屏幕坐标系 Y 轴方向相反，所以 NDC 坐标系下的 Y 轴坐标转化到屏幕坐标系时要取 Y 轴坐标的相反数。</p>
<p>那么，顶点 P 转换到屏幕坐标系下的坐标为：</p>
<p>$P_s = P_n + O_s = (1 \times 250, -1 \times 150) + (250, 150) = (500, 0)$</p>
<blockquote>
<ul>
<li>在 X 方向，NDC 中 1 的单位长度对应屏幕宽度的一半，也就是 250 像素；</li>
<li>在 Y 方向，1 对应 150 像素。<br>  注意，由于 NDC 的 Y 轴向上，而屏幕坐标系的 Y 轴方向通常是向下，所以转换时 Y 坐标需要取相反数。</li>
</ul>
</blockquote>
<p>很明显，顶点显示在 <code>canvas</code> 视口的右上角，这和顶点在裁剪坐标系中设置的观察箱中的位置相吻合。</p>
<h1 id="仿射变换"><a href="#仿射变换" class="headerlink" title="仿射变换"></a>仿射变换</h1><h2 id="1-矩阵相关概念"><a href="#1-矩阵相关概念" class="headerlink" title="1 矩阵相关概念"></a>1 矩阵相关概念</h2><h3 id="1-1-注意事项"><a href="#1-1-注意事项" class="headerlink" title="1.1 注意事项"></a>1.1 注意事项</h3><p>在学习矩阵变换时，一定要搞清楚以下三点：</p>
<ul>
<li>所使用的向量是 <code>行向量</code> 还是 <code>列向量</code>。<ul>
<li>如果是 <code>行向量</code>，按照 <code>数学领域</code> 中矩阵相乘的规则，向量要放在 <code>左侧</code> 相乘。</li>
<li>如果是 <code>列向量</code>，向量要放在 <code>右侧</code> 相乘。</li>
</ul>
</li>
<li>矩阵是 <code>行主序</code> 还是 <code>列主序</code>。<ul>
<li>如果是行主序，内存存储矩阵的数组的前四个元素表示的是对应数学矩阵的 <code>第一行</code></li>
<li>如果是列主序，内存存储矩阵的数组的前四个元素表示的是对应数学矩阵的 <code>第一列</code></li>
</ul>
</li>
<li>多个矩阵变换时的相乘顺序。<ul>
<li>在多个矩阵变换时，不同的相乘顺序会导致不同的结果，所以我们要保证矩阵相乘的顺序是我们期望的。假设有三个变换矩阵：旋转矩阵 R，平移矩阵 T，缩放矩阵 S，以及顶点向量 P，那么 P 变换到 P1 的顺序一般是这样的：<br>  $P1 = T \times R \times S \times P$<br>  即先 <code>缩放</code>，再 <code>旋转</code>，最后 <code>平移</code>。</li>
</ul>
</li>
</ul>
<h4 id="行主序和列主序"><a href="#行主序和列主序" class="headerlink" title="行主序和列主序"></a>行主序和列主序</h4><p>存储顺序说明了线性代数中的矩阵如何在线性的内存数组中存储，按照存储方式分为行主序和列主序。</p>
<p>行主序是按照行向量的方式组织矩阵。列主序是按照列向量的方式组织矩阵，为了便于理解，我们看下图示。</p>
<p>假设有一个 3 阶方阵 M：</p>
<p>$$<br>\begin{aligned}<br>M = \begin{pmatrix}<br>1 &amp; 2 &amp; 3 \<br>4 &amp; 5 &amp; 6 \<br>7 &amp; 8 &amp; 9<br>\end{pmatrix}<br>\end{aligned}<br>$$</p>
<p>那么它在内存中的排布方式如下：</p>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/10/20/1669106cb868043c~tplv-t2oaga2asx-image.image" alt="|1224"></p>
<p>观察上面的图，就能够一目了然地看出行主序和列主序的区别了。</p>
<p>请务必谨记，GLSL 中采用的是<strong>列主序</strong>。</p>
<p>下面这个是 <code>threejs</code> 封装的矩阵类，构造函数中<strong>传递的是行主序</strong>，<strong>生成的是列主序</strong>的类型数组</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Matrix4</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44</span>) &#123;</span><br><span class="line">    <span class="title class_">Matrix4</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">isMatrix4</span> = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">elements</span> = [<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (n11 !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">set</span>(n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">set</span>(<span class="params">n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> te = <span class="variable language_">this</span>.<span class="property">elements</span></span><br><span class="line"></span><br><span class="line">    te[<span class="number">0</span>] = n11</span><br><span class="line">    te[<span class="number">4</span>] = n12</span><br><span class="line">    te[<span class="number">8</span>] = n13</span><br><span class="line">    te[<span class="number">12</span>] = n14</span><br><span class="line">    te[<span class="number">1</span>] = n21</span><br><span class="line">    te[<span class="number">5</span>] = n22</span><br><span class="line">    te[<span class="number">9</span>] = n23</span><br><span class="line">    te[<span class="number">13</span>] = n24</span><br><span class="line">    te[<span class="number">2</span>] = n31</span><br><span class="line">    te[<span class="number">6</span>] = n32</span><br><span class="line">    te[<span class="number">10</span>] = n33</span><br><span class="line">    te[<span class="number">14</span>] = n34</span><br><span class="line">    te[<span class="number">3</span>] = n41</span><br><span class="line">    te[<span class="number">7</span>] = n42</span><br><span class="line">    te[<span class="number">11</span>] = n43</span><br><span class="line">    te[<span class="number">15</span>] = n44</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<h3 id="1-2-齐次坐标"><a href="#1-2-齐次坐标" class="headerlink" title="1.2 齐次坐标"></a>1.2 齐次坐标</h3><p>前面章节我们讲了 <code>齐次坐标</code>，它用来区分 <code>点</code> 和 <code>向量</code>，齐次坐标使用 <code>N+1</code> 维向量表示 N 维空间</p>
<ul>
<li>第 <code>N+1</code> 维数字如果是 <code>0</code> 的话，则代表 N 维空间中的<strong>向量</strong><br>如下用 4 维向量表示 3 维空间中的一个向量：<br>$\vec{P} = (3, 2, 1, 0)$</li>
<li>第 <code>N+1</code> 维数字如果是 <code>非0数字</code> 的话，则代表 N 维空间下的 <strong>点</strong>：<br>如下用 4 维向量表示 3 维空间中的一个点：<br>$\vec{P} = (3, 2, 1, 1)$</li>
</ul>
<p>使用 N+1 维数字表示 N 维空间中的点或向量的方式就是齐次坐标。</p>
<p><strong>齐次坐标</strong>除了能够区分 <code>点</code> 和 <code>向量</code>，还有两大用处：</p>
<ol>
<li><strong>模拟透视投影效果</strong>：在裁剪坐标系中，w 值越大，经过透视除法后的坐标越小，于是也就有了近大远小的投影效果</li>
<li><strong>用矩阵来表示平移变换</strong></li>
</ol>
<h3 id="1-3-用矩阵来表示平移变换"><a href="#1-3-用矩阵来表示平移变换" class="headerlink" title="1.3 用矩阵来表示平移变换"></a>1.3 用矩阵来表示平移变换</h3><p>前面章节已经讲过，n 阶矩阵只能和 n 维列向量相乘，得到一个新的 n 维列向量。</p>
<p>$M_{ij} \times P_{j1}$</p>
<p>乘得的结果只能表示缩放和旋转变换，没有办法表示平移变换，<strong>因为平移是在原向量的基础上加上一个常量位移，属于加法操作</strong>，但是 n 阶矩阵和 n 维列向量相乘的话，每一步都是相乘操作，没有加法运算，所以无法用 n 阶矩阵和 n 维列向量表示 n 维列向量的平移。</p>
<blockquote>
<p>要注意：上面所说的列向量指的是坐标，不是数学意义上的向量。</p>
</blockquote>
<p>$$<br>\begin{pmatrix}<br>a &amp; b &amp; c \<br>d &amp; e &amp; f  \<br>g &amp; h &amp; i<br>\end{pmatrix} \times \begin{pmatrix}x \<br>y \<br>z<br>\end{pmatrix} = \begin{pmatrix}<br>ax + by + cz \<br>dx + ey + fz  \<br>gx + hy + iz<br>\end{pmatrix}<br>$$</p>
<p>可以看到 n 维矩阵和 n 维向量相乘，不能实现 n 维向量和一个常量进行加减的操作。</p>
<p>我们期待的是得到这样一个向量：</p>
<p>$(ax + by +cz + p)$</p>
<p>其中 p 是常数，代表平移的大小。</p>
<p>我们看一下齐次坐标是如何帮助我们解决这个问题的。</p>
<p>顶点 P 用齐次坐标表示如下：</p>
<p>$P = (x, y, z, 1)$</p>
<p>因为 3 维坐标用齐次坐标的话需要增加到 4 维，所以表示平移变换的矩阵也要相应地变成 4 阶矩阵，我们看下这个 4 阶矩阵如何构成：</p>
<p>$$<br>\begin{pmatrix}<br>a &amp; b &amp; c &amp; tx \<br>c &amp; d &amp; e &amp; ty \<br>f &amp; g &amp; h &amp; tz \<br>0 &amp; 0 &amp; 0 &amp; 1<br>\end{pmatrix}<br>$$</p>
<p>在原来基础上增加一行和一列，其中第四行前三个分量为 0，第四个分量为 1，这样矩阵和向量的乘积得到的新的向量的第四个分量也是 1，所以也是代表点。</p>
<p>第四列 tx、ty、tz 分别代表沿 x 轴、y 轴、 z 轴方向上的平移量。</p>
<p>我们推算验证一下：</p>
<p>$$<br>\begin{pmatrix}<br>a &amp; b &amp; c &amp; tx \<br>d &amp; e &amp; f &amp; ty \<br>g &amp; h &amp; i &amp; tz \<br>0 &amp; 0 &amp; 0 &amp; 1<br>\end{pmatrix} \times \begin{pmatrix}x \<br>y \<br>z \ 1<br>\end{pmatrix} = \begin{pmatrix}<br>ax + by + cz +tx \<br>dx + ey + fz + ty \<br>gx + hy + iz + tz \<br>0 + 0 + 0 + 1<br>\end{pmatrix}<br>$$</p>
<p>转换后的向量的每一个分量都实现了 <code>ax + by + cz + 常数</code> 的格式，也就是说，向量可以通过乘以一个矩阵实现平移操作。</p>
<h2 id="2-变换矩阵的推导"><a href="#2-变换矩阵的推导" class="headerlink" title="2 变换矩阵的推导"></a>2 变换矩阵的推导</h2><h3 id="2-1-变换矩阵的求解思路"><a href="#2-1-变换矩阵的求解思路" class="headerlink" title="2.1 变换矩阵的求解思路"></a>2.1 变换矩阵的求解思路</h3><p>首先我们要知道，对物体（顶点）做平移、旋转、缩放的变换操作相当于对原来的坐标系做平移、旋转、缩放变换，得到一个新坐标系。了解了这一点，我们就可以学习一种求解变换矩阵的简单方式：</p>
<ul>
<li>首先求出新坐标系的基向量 U 在原坐标系下的表示 U’，其中 U =(Ux, Uy, Uz)， U’ = (Ux’, Uy’, Uz’)。<ul>
<li>Ux：X 轴基向量，由三个分量构成，<ul>
<li>Uxx, X 轴分量。</li>
<li>Uxy, Y 轴分量。</li>
<li>Uxz，Z 轴分量。</li>
</ul>
</li>
<li>Uy：Y 轴基向量，由三个坐标轴分量组成<ul>
<li>Uyx：X 轴分量。</li>
<li>Uyy：Y 轴分量。</li>
<li>Uyz：Z 轴分量。</li>
</ul>
</li>
<li>Uz：Z 轴基向量，由三个坐标轴分量组成<ul>
<li>Uzx：X 轴分量。</li>
<li>Uzy：Y 轴分量。</li>
<li>Uzz：Z 轴分量。</li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>基向量是指坐标系中各个坐标轴正方向的单位向量，假设 Ux 代表 X 轴的单位向量，那么 Ux = (1, 0, 0)，同理， Uy = (0, 1, 0)，Uz = (0, 0, 1)。 </p>
</blockquote>
<ul>
<li>其次求出新坐标系的坐标原点 <code>O(Ox, Oy, Oz)</code> 在原坐标系下的坐标 <code>O1（Ox1, Oy1, Oz1）</code></li>
</ul>
<blockquote>
<p>基向量是坐标系变换的基础，我们求解坐标变换矩阵关键就是要找到原坐标系的基向量在新坐标系中的表示。</p>
</blockquote>
<ul>
<li>最后，将上面求出的各个值代入下面的矩阵框架：</li>
</ul>
<p>$$<br>\begin{pmatrix}<br>U_{xx} &amp; U_{yx} &amp; U_{zx} &amp; O_{x1}\<br>U_{xy} &amp; U_{yy} &amp; U_{zy} &amp; O_{y1}\<br>U_{xz} &amp; U_{yz} &amp; U_{zz} &amp; O_{z1}\<br>0 &amp; 0 &amp; 0 &amp; 1<br>\end{pmatrix}<br>$$</p>
<p>这是一个简单易于理解的求解思路，掌握了这个思路，不管进行什么样的变换，我们都能很快地求出来变换矩阵，只需要找到这些值，然后将其代入 <code>矩阵框架</code> 就行啦。</p>
<p>下面是一个坐标系变换的例子，坐标系 oxyz 绕 Z 轴旋转 β 角度后形成了新坐标系 ox’y’z’：</p>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/10/24/166a6a27af075ce0~tplv-t2oaga2asx-image.image"></p>
<p>大家一定要分清，新坐标系是 <code>ox&#39;y&#39;z&#39;</code>，原坐标系是 <code>oxyz</code>，新坐标系的 <code>基向量</code> 在原坐标系下的表示我们利用三角函数运算即可求出，如上图所示，所以按照求解思路的第一步，新坐标系的基向量在原坐标系表示为：</p>
<p>$U’ =  (Ux’, Uy’, Uz’)$</p>
<p>$Ux’ = (cos\beta, sin\beta, 0)$</p>
<p>$Uy’ = (-sin\beta, cos\beta, 0)$</p>
<p>$Uz’ = (0, 0, 1)$</p>
<p>原坐标系的坐标原点和新坐标系重合，所以新坐标系原点在原坐标系下的表示：</p>
<p>$O1 = (Ox1 ,Oy1, Oz1) = (0, 0, 0)$</p>
<p>代入通用矩阵框架后得出变换矩阵为：</p>
<p>$$<br>\begin{pmatrix}<br>cos\beta &amp; -sin\beta &amp; 0 &amp; 0\<br>sin\beta &amp; cos\beta &amp; 0 &amp; 0\<br>0 &amp; 0 &amp; 1 &amp; 0\<br>0 &amp; 0 &amp; 0 &amp; 1<br>\end{pmatrix}<br>$$</p>
<h3 id="2-2-平移矩阵"><a href="#2-2-平移矩阵" class="headerlink" title="2.2 平移矩阵"></a>2.2 平移矩阵</h3><p>按照上面的矩阵变换求解思路来寻找平移矩阵：</p>
<ul>
<li>tx 代表沿着 X 轴方向的位移量。</li>
<li>ty 代表沿着 Y 轴方向的位移量。</li>
<li>tz 代表沿着 Z 轴方向的位移量。</li>
</ul>
<p><strong>1、求出原坐标系的基向量在新坐标系的表示。</strong></p>
<p>由于没有进行旋转和缩放操作，所以新坐标系的基向量和原坐标系一样：</p>
<p>$Ux = (1, 0, 0)$</p>
<p>$Uy = (0, 1, 0)$</p>
<p>$Uz = (0, 0, 1)$</p>
<p><strong>2、新坐标系坐标原点的坐标：</strong></p>
<p>$Ox1 = Ox + t_x = t_x$</p>
<p>$Oy1 = Oy + t_y= t_y$</p>
<p>$Oz1 = Oz + t_z = t_z$</p>
<p>将这些值代入变换矩阵框架</p>
<p>$$<br>\begin{pmatrix}<br>1 &amp; 0 &amp; 0 &amp; tx \<br>0 &amp; 1 &amp; 0 &amp; ty \<br>0 &amp; 0 &amp; 1 &amp; tz \<br>0 &amp; 0 &amp; 0 &amp; 1<br>\end {pmatrix}<br>$$</p>
<p>算法实现：</p>
<blockquote>
<p>WebGL 矩阵是列主序的，每隔 4 个数代表一列。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">translation</span>(<span class="params">tx, ty, tz, target</span>)&#123;</span><br><span class="line">    target = target || <span class="keyword">new</span> <span class="title class_">Float32Array</span>(<span class="number">16</span>);</span><br><span class="line">    <span class="comment">// 第一列</span></span><br><span class="line">    target[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    target[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    target[<span class="number">2</span>] = <span class="number">0</span>;</span><br><span class="line">    target[<span class="number">3</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 第二列</span></span><br><span class="line">    target[<span class="number">4</span>] = <span class="number">0</span>;</span><br><span class="line">    target[<span class="number">5</span>] = <span class="number">1</span>;</span><br><span class="line">    target[<span class="number">6</span>] = <span class="number">0</span>;</span><br><span class="line">    target[<span class="number">7</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 第三列</span></span><br><span class="line">    target[<span class="number">8</span>] = <span class="number">0</span>;</span><br><span class="line">    target[<span class="number">9</span>] = <span class="number">0</span>;</span><br><span class="line">    target[<span class="number">10</span>] = <span class="number">1</span>;</span><br><span class="line">    target[<span class="number">11</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 第四列</span></span><br><span class="line">    target[<span class="number">12</span>] = tx;</span><br><span class="line">    target[<span class="number">13</span>] = ty;</span><br><span class="line">    target[<span class="number">14</span>] = tz;</span><br><span class="line">    target[<span class="number">15</span>] = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-3-缩放矩阵"><a href="#2-3-缩放矩阵" class="headerlink" title="2.3 缩放矩阵"></a>2.3 缩放矩阵</h3><p>我们要构建一个缩放矩阵，缩放矩阵也比较简单，按照上面的求解思路：</p>
<p><strong>1、新坐标系基向量在原坐标系下的表示：</strong></p>
<p>沿着 X 轴缩放 sx 倍，相当于将原来的基向量放大了 sx 倍，所以新坐标系下一个单位的长度相当于原来坐标系下的 sx 个长度，以此类推，我们很容易地推导出 Y 轴和 Z 轴的基向量</p>
<p>$Ux = (sx, 0, 0)$</p>
<p>$Uy = (0, sy, 0)$</p>
<p>$Uz = (0, 0, sz)$</p>
<p><strong>2、原坐标系原点在新坐标系下的坐标：</strong></p>
<p>由于缩放操作没有改变原点位置，所以，原点坐标在新坐标系下仍然是（0，0，0）。</p>
<p>$O1 = (0, 0, 0)$</p>
<p>将这些值代入变换矩阵框架，可以得出：</p>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/10/24/166a3da75f85ba1b~tplv-t2oaga2asx-image.image"></p>
<p>上面这个图就是一个典型的缩放矩阵：</p>
<ul>
<li>sx：沿着 X 轴方向的缩放比例</li>
<li>sy：沿着 Y 轴方向的缩放比例</li>
<li>sz：沿着 Z 轴方向的缩放比例</li>
</ul>
<p>代码实现：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">scale</span>(<span class="params">sx, sy, sz, target</span>)&#123;</span><br><span class="line">    target = target || <span class="keyword">new</span> <span class="title class_">Float32Array</span>(<span class="number">16</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 第一列</span></span><br><span class="line">    target[<span class="number">0</span>] = sx;</span><br><span class="line">    target[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    target[<span class="number">2</span>] = <span class="number">0</span>;</span><br><span class="line">    target[<span class="number">3</span>] = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 第二列</span></span><br><span class="line">    target[<span class="number">4</span>] = <span class="number">0</span>;</span><br><span class="line">    target[<span class="number">5</span>] = sy;</span><br><span class="line">    target[<span class="number">6</span>] = <span class="number">0</span>;</span><br><span class="line">    target[<span class="number">7</span>] = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 第三列</span></span><br><span class="line">    target[<span class="number">8</span>] = <span class="number">0</span>;</span><br><span class="line">    target[<span class="number">9</span>] = <span class="number">0</span>;</span><br><span class="line">    target[<span class="number">10</span>] = sz;</span><br><span class="line">    target[<span class="number">11</span>] = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 第四列</span></span><br><span class="line">    target[<span class="number">12</span>] = <span class="number">0</span>;</span><br><span class="line">    target[<span class="number">13</span>] = <span class="number">0</span>;</span><br><span class="line">    target[<span class="number">14</span>] = <span class="number">0</span>;</span><br><span class="line">    target[<span class="number">15</span>] = <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用该方法需要指定三个方向的缩放比例，但是有时我们可能只缩放某个方向，所以需要再衍生三个缩放函数</p>
<ul>
<li>沿 X 轴缩放矩阵</li>
<li>沿 Y 轴缩放矩阵</li>
<li>沿 Z 轴缩放矩阵</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">scaleX</span>(<span class="params">sx</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">scale</span>(sx, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">scaleY</span>(<span class="params">sy</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">scale</span>(<span class="number">1</span>, sy, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">scaleZ</span>(<span class="params">sz</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">scale</span>(<span class="number">1</span>, <span class="number">1</span>, sz);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-4-旋转矩阵"><a href="#2-4-旋转矩阵" class="headerlink" title="2.4 旋转矩阵"></a>2.4 旋转矩阵</h3><p>相比平移和缩放，旋转矩阵相对复杂一些，我们从 2D 平面上一个顶点的旋转说起。</p>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/10/24/166a3f4f493efad8~tplv-t2oaga2asx-image.image"></p>
<p>点 <code>P(x, y)</code> 旋转 <code>β</code> 角度后，得到一个新的顶点 <code>P1(x1, y1)</code> ， <code>P1</code> 和 <code>P</code> 之间的坐标关系：</p>
<p><strong>P 点坐标：</strong></p>
<p>$x = r \times cos\alpha$</p>
<p>$y = r \times sin\alpha$</p>
<p><strong>旋转后的 P1 点坐标：</strong></p>
<p>$x1 = r \times cos(\alpha + \beta) = r \times cos\alpha cos\beta - r \times sin\alpha sin\beta$</p>
<p>$y1 = r \times sin(\alpha + \beta) = r \times cos\alpha sin\beta + r \times sin\alpha cos\beta$</p>
<p><strong>将 P 点坐标带入 P1 点可以得到：</strong></p>
<p>$x1 = xcos\beta - ysin\beta$</p>
<p>$y1 = xsin\beta + ycos\beta$</p>
<p>我们使用齐次坐标和矩阵表示：</p>
<p>$$<br>P1 =<br>\begin{pmatrix}<br>cos\beta &amp; -sin\beta &amp; 0 \<br>sin\beta &amp; cos\beta &amp; 0 \<br>0 &amp; 0 &amp; 1<br>\end{pmatrix}<br> \times \begin{pmatrix}<br>x \ y \ 1<br>\end{pmatrix}<br>=\begin{pmatrix}<br>xcos\beta - ysin\beta \ xsin\beta + ycos\beta \ 1<br>\end{pmatrix}<br>$$</p>
<p>扩展到 3D 空间，我们同样能推导出下面三种旋转矩阵。</p>
<h4 id="2-4-1-绕-X-轴旋转"><a href="#2-4-1-绕-X-轴旋转" class="headerlink" title="2.4.1 绕 X 轴旋转"></a>2.4.1 绕 X 轴旋转</h4><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/10/24/166a6abab10b4063~tplv-t2oaga2asx-image.image"></p>
<p>JavaScript 的实现，相信大家已经熟记于心了，我们只需要在矩阵的各个位置指定对应数字即可。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">rotationX</span>(<span class="params">angle, target</span>)&#123;</span><br><span class="line">    target = target || <span class="keyword">new</span> <span class="title class_">Float32Array</span>(<span class="number">16</span>);</span><br><span class="line">    <span class="keyword">let</span> sin = <span class="title class_">Math</span>.<span class="title function_">sin</span>(angle);</span><br><span class="line">    <span class="keyword">let</span> cos = <span class="title class_">Math</span>.<span class="title function_">cos</span>(angle);</span><br><span class="line">    target[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    target[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    target[<span class="number">2</span>] = <span class="number">0</span>;</span><br><span class="line">    target[<span class="number">3</span>] = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    target[<span class="number">4</span>] = <span class="number">0</span>;</span><br><span class="line">    target[<span class="number">5</span>] = cos;</span><br><span class="line">    target[<span class="number">6</span>] = sin;</span><br><span class="line">    target[<span class="number">7</span>] = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    target[<span class="number">8</span>] = <span class="number">0</span>;</span><br><span class="line">    target[<span class="number">9</span>] = -sin;</span><br><span class="line">    target[<span class="number">10</span>] = cos;</span><br><span class="line">    target[<span class="number">11</span>] = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    target[<span class="number">12</span>] = <span class="number">0</span>;</span><br><span class="line">    target[<span class="number">13</span>] = <span class="number">0</span>;</span><br><span class="line">    target[<span class="number">14</span>] = <span class="number">0</span>;</span><br><span class="line">    target[<span class="number">15</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>只要你理解了矩阵的运算规则，并推导出变换矩阵，之后只需将各个位置的元素赋值到一个类型化数组中即可。</p>
</blockquote>
<h4 id="2-4-2-绕-Y-轴旋转"><a href="#2-4-2-绕-Y-轴旋转" class="headerlink" title="2.4.2 绕 Y 轴旋转"></a>2.4.2 绕 Y 轴旋转</h4><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/1/14/1684bb58b07334c9~tplv-t2oaga2asx-image.image"></p>
<h4 id="2-4-3-绕-Z-轴旋转"><a href="#2-4-3-绕-Z-轴旋转" class="headerlink" title="2.4.3 绕 Z 轴旋转"></a>2.4.3 绕 Z 轴旋转</h4><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/10/24/166a6ac18384889f~tplv-t2oaga2asx-image.image"></p>
<h4 id="2-4-4-绕任意轴旋转"><a href="#2-4-4-绕任意轴旋转" class="headerlink" title="2.4.4 绕任意轴旋转"></a>2.4.4 绕任意轴旋转</h4><p>上面三种是绕坐标轴进行旋转，但实际上我们往往需要绕空间中某一根轴旋转，绕任意轴旋转的矩阵求解比较复杂。</p>
<blockquote>
<p>这里我们采用过原点的任意轴旋转，不考虑平移情况，如果是绕一个不过原点的任意轴旋转的话，我们可以利用一个旋转矩阵和一个平移矩阵来完成。</p>
</blockquote>
<p>我们看下如何推导，如下图所示：</p>
<ul>
<li>C<code>：</code> 空间中一点。</li>
<li><code>A</code>：坐标原点。</li>
<li>向量 $\vec{AF}$：旋转轴单位向量 。</li>
</ul>
<p>点 <code>C</code> 旋转 <code>β</code> 角之后，来到 C’ 点。</p>
<p>假设这个变换矩阵为 <code>M</code>，那么 <code>M</code> 和 角度 <code>β</code> 以及旋转轴 $\vec{AF}$ 有关，</p>
<p>$\vec{M} = (β, \vec{AF})$</p>
<p>如下图所示：</p>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/10/25/166a969395da019a~tplv-t2oaga2asx-image.image"></p>
<p>我们现在需要求得如何用点 C、 旋转角β以及旋转轴 $\vec{AF}$ 表示 C’。</p>
<h5 id="求解步骤"><a href="#求解步骤" class="headerlink" title="求解步骤"></a>求解步骤</h5><ul>
<li>首先，求出 $\vec{AC}$ 在旋转轴 $\vec{AF}$ 上的分量 $\vec{AB}$，同时向量 $\vec{BC}$ 垂直于 $\vec{AB}$，</li>
<li>接着根据 $\vec{BZ’}$ 和旋转角度 β，求出 $\vec{B}C’$，然后根据向量加法公式，求出 $\vec{AC’}$，即 C’ 转换后的坐标。</li>
</ul>
<p>用数学公式表示：</p>
<p>1、向量 $\vec{AC}$ 点乘 $\vec{AF}$,求出向量 $\vec{AB}$ 。</p>
<p>$\vec{AB} = (\vec{AC} \cdot \vec{AF}) \times \vec{AF}$</p>
<p>2、求出 $\vec{BC}$</p>
<p>$\vec{BC} = \vec{AC} - \vec{AB}$</p>
<p>3、通过向量 $\vec{AF}$ 叉乘 $\vec{BC}$ 求得 $\vec{BZ’}$</p>
<p>$$<br>\begin{aligned}</p>
<p>\vec{BZ’} &amp;= \vec{AF} \times \vec{BC} \\</p>
<p>&amp;=\vec{AF} \times \vec{AC} - \vec{AF} \times \vec{AB} \\</p>
<p>&amp; = \vec{AF} \times \vec{AC} - 0 \\</p>
<p>&amp; = \vec{AF} \times \vec{AC}</p>
<p>\end{aligned}<br>$$</p>
<p>4、利用三角函数求出 $\vec{BC’}$</p>
<p>$\vec{BC’} = \vec{BZ’} sin\beta + \vec{BC} cos\beta$</p>
<p>5、利用向量加法求出 $\vec{AC’}$</p>
<p>$\vec{AC’} = \vec{AB} + \vec{BC’}$</p>
<p>6、将 1-4 步代入第 5 步，得出：</p>
<p>$\vec{AC’} = (\vec{AC} \cdot \vec{AF}) \times \vec{AF} + (\vec{AF} \times \vec{AC}) sin\beta + (\vec{AC} - (\vec{AC} \cdot \vec{AF}) \times \vec{AF}) cos\beta$</p>
<p>假设旋转轴向量表示为：</p>
<p>$\vec{AF} = (t_x, t_y, t_z)$</p>
<p>新坐标系基向量 U(Ux,Uy,Uz) 在原坐标系中的坐标位置求解如下：</p>
<p>$$<br>\begin{aligned}</p>
<p>Ux = (\begin{pmatrix}</p>
<p>1 \ 0 \ 0 </p>
<p>\end{pmatrix} -</p>
<p>（\begin{pmatrix}</p>
<p>1 \ 0 \ 0 </p>
<p>\end{pmatrix} \cdot \begin{pmatrix}</p>
<p>t_x \t_y \t_z</p>
<p>\end{pmatrix}) \times \begin{pmatrix}t_x \t_y \t_z\end{pmatrix})cos\beta + （</p>
<p>\begin{pmatrix} t_x \ t_y \ t_z \end{pmatrix}\times \begin{pmatrix}</p>
<p>1 \ 0 \0</p>
<p>\end{pmatrix} ）\times sin\beta + </p>
<p>(\begin{pmatrix}</p>
<p>1 \ 0 \ 0</p>
<p>\end{pmatrix}</p>
<p>\cdot </p>
<p>\begin{pmatrix}</p>
<p>t_x \ t_y \t_z</p>
<p>\end{pmatrix}) \times </p>
<p>\begin{pmatrix}</p>
<p>t_x \ t_y \ t_z</p>
<p>\end{pmatrix}</p>
<p>\end{aligned}<br>$$</p>
<p>利用向量点乘、叉乘规则最终推导出：</p>
<p>$$<br>Ux = \begin{pmatrix}</p>
<p>t_x^2 (1-cos\beta) + cos\beta \\</p>
<p>t_xt_y(1-cos\beta) + t_zsin\beta \\</p>
<p>t_xt_z(1-cos\beta) - t_ysin\beta</p>
<p>\end{pmatrix}<br>$$</p>
<p>同理，将 Y 轴基向量 (0, 1, 0) 代入上面公式，推导可得：</p>
<p>$$<br>Uy = \begin{pmatrix}</p>
<p>t_xt_y (1-cos\beta) - t_zsin\beta \\</p>
<p>t_y^2(1-cos\beta) + cos\beta \\</p>
<p>t_yt_z(1-cos\beta) + t_xsin\beta</p>
<p>\end{pmatrix}<br>$$</p>
<p>$$<br>Uz = \begin{pmatrix}</p>
<p>t_xt_z (1-cos\beta) + t_ysin\beta \\</p>
<p>t_yt_z(1-cos\beta) - t_xsin\beta \\</p>
<p>t_z^2(1-cos\beta) + cos\beta</p>
<p>\end{pmatrix}<br>$$</p>
<p>这样我们就求出了新坐标系的基向量在原坐标系的表示。</p>
<p>接下来，我们找出新坐标系的原点在原坐标系下的坐标，因为是绕原点旋转，所以坐标不变，仍然是（0，0，0）。将这些值代入矩阵框架，得出绕任意旋转轴的变换矩阵：</p>
<p>$$<br>\begin{pmatrix}</p>
<p>t_x^2 (1-cos\beta) + cos\beta &amp;</p>
<p>t_xt_y(1-cos\beta) - t_zsin\beta &amp;</p>
<p>t_xt_z(1-cos\beta) + t_ysin\beta &amp; 0 \\</p>
<p>t_xt_y (1-cos\beta) + t_zsin\beta &amp;</p>
<p>t_y^2(1-cos\beta) + cos\beta &amp;</p>
<p>t_yt_z(1-cos\beta) - t_xsin\beta &amp; 0 \\</p>
<p>t_xt_z (1-cos\beta) - t_ysin\beta &amp;</p>
<p>t_yt_z(1-cos\beta) + t_xsin\beta &amp;</p>
<p>t_z^2(1-cos\beta) + cos\beta &amp; 0 \\</p>
<p>0 &amp; 0 &amp; 0 &amp; 1</p>
<p>\end{pmatrix}<br>$$</p>
<p>有了变换矩阵，那么我们就可以实现 JavaScript 的任意轴旋转矩阵了：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">axisRotation</span>(<span class="params">axis, angle, target</span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> x = axis.<span class="property">x</span>;</span><br><span class="line">    <span class="keyword">var</span> y = axis.<span class="property">y</span>;</span><br><span class="line">    <span class="keyword">var</span> z = axis.<span class="property">z</span>;</span><br><span class="line">    <span class="keyword">var</span> l = <span class="title class_">Math</span>.<span class="title function_">sqrt</span>(x * x + y * y + z * z);</span><br><span class="line">    x = x / l;</span><br><span class="line">    y = y/ l;</span><br><span class="line">    z = z /l;</span><br><span class="line">    <span class="keyword">var</span> xx = x * x;</span><br><span class="line">    <span class="keyword">var</span> yy = y * y;</span><br><span class="line">    <span class="keyword">var</span> zz = z * z;</span><br><span class="line">    <span class="keyword">var</span> cos = <span class="title class_">Math</span>.<span class="title function_">cos</span>(angle);</span><br><span class="line">    <span class="keyword">var</span> sin = <span class="title class_">Math</span>.<span class="title function_">sin</span>(angle);</span><br><span class="line">    <span class="keyword">var</span> oneMCos = <span class="number">1</span> - cos;</span><br><span class="line">    </span><br><span class="line">    target = target || <span class="keyword">new</span> <span class="title class_">Float32Array</span>(<span class="number">16</span>);</span><br><span class="line">    </span><br><span class="line">    target[<span class="number">0</span>] = xx + (<span class="number">1</span> - xx) * cos;</span><br><span class="line">    target[<span class="number">1</span>] = x * y * oneMCos + z * sin;</span><br><span class="line">    target[<span class="number">2</span>] = x * z * oneMcos - y * sin;</span><br><span class="line">    target[<span class="number">3</span>] = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    target[<span class="number">4</span>] = x * y * oneMCos - z * sin;</span><br><span class="line">    target[<span class="number">5</span>] = yy + (<span class="number">1</span> - yy) * cos;</span><br><span class="line">    target[<span class="number">6</span>] = y * z * oneMCos + x * sin;</span><br><span class="line">    target[<span class="number">7</span>] = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    target[<span class="number">8</span>] = x * z  * oneMCos + y * sin;</span><br><span class="line">    target[<span class="number">9</span>] = y * z * oneMCos - x * sin;</span><br><span class="line">    target[<span class="number">10</span>] = zz + (<span class="number">1</span> - zz) * cos;</span><br><span class="line">    target[<span class="number">11</span>] = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    target[<span class="number">12</span>] = <span class="number">0</span>;</span><br><span class="line">    target[<span class="number">13</span>] = <span class="number">0</span>;</span><br><span class="line">    target[<span class="number">14</span>] = <span class="number">0</span>;</span><br><span class="line">    target[<span class="number">15</span>] = <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上就是绕任意轴进行旋转的矩阵。</p>
<h1 id="坐标系变换"><a href="#坐标系变换" class="headerlink" title="坐标系变换"></a>坐标系变换</h1><h2 id="1-坐标系变换的分类"><a href="#1-坐标系变换的分类" class="headerlink" title="1 坐标系变换的分类"></a>1 坐标系变换的分类</h2><p>前面我们讲过，在 3D 编程中，可控制的坐标系变换分为 3 类，分别是：</p>
<ul>
<li>模型变换<ul>
<li>模型变换负责将模型坐标转换成世界坐标。 </li>
</ul>
</li>
<li>视图变换<ul>
<li>视图变换负责将世界坐标转换成相机坐标。</li>
</ul>
</li>
<li>投影变换<ul>
<li>投影变换负责将相机坐标转换成裁剪坐标，也就是将 3D 坐标投影到 2D 平面上。</li>
</ul>
</li>
</ul>
<p>需要强调一点变换矩阵相乘的顺序，假设最终变换矩阵为 F，模型矩阵为 M， 视图矩阵为 V，投影矩阵为 P，那么有：</p>
<p>$F = P \times V \times M$</p>
<p>这个顺序不能有错，否则效果与预想的会不一致。</p>
<h2 id="2-模型变换"><a href="#2-模型变换" class="headerlink" title="2 模型变换"></a>2 模型变换</h2><h3 id="2-1-引入"><a href="#2-1-引入" class="headerlink" title="2.1 引入"></a>2.1 引入</h3><p>编程之初，我们首先能拿到的是模型数据，模型中各个点的位置是相对于模型的某个位置确定的，一般这个位置是模型的中心点，下面这个坐标系就是模型坐标系，立方体的所有顶点坐标都是相对于中心位置。</p>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/11/1/166cd2eb7d531b0b~tplv-t2oaga2asx-image.image"></p>
<p>默认情况下，模型坐标系和世界坐标系重合，所有创建好的模型首先会放置在世界坐标系中心位置，我们创建一个立方体和一个球体：</p>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/11/1/166cd5693a608e92~tplv-t2oaga2asx-image.image"></p>
<p>可以看到，我们创建的模型叠加在了一起。</p>
<p>那么，我们需要将我们的模型摆放在 3D 世界中的特定位置，3D 世界所遵循的参照就是世界坐标系。</p>
<p>这就涉及到模型变换了，模型变换的作用是将模型顶点从 <code>模型坐标系</code> 转换到 <code>世界坐标系</code>。</p>
<h3 id="2-2-变换顺序"><a href="#2-2-变换顺序" class="headerlink" title="2.2 变换顺序"></a>2.2 变换顺序</h3><h4 id="2-2-1-平移与旋转"><a href="#2-2-1-平移与旋转" class="headerlink" title="2.2.1 平移与旋转"></a>2.2.1 平移与旋转</h4><p><span style="color: #badc58; font-weight: 550;">创建两个变换矩阵</span></p>
<p>1、平移矩阵：平移 5 个单位</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> translateMatrix = matrix.<span class="title function_">translate</span>(<span class="number">5</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p>2、旋转矩阵: 逆时针旋转 45 度</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> rotateMatrix = matrix.<span class="title function_">rotateX</span>(<span class="title class_">Math</span>.<span class="property">PI</span> / <span class="number">180</span> * <span class="number">45</span>);</span><br></pre></td></tr></table></figure>

<p><span style="color: #badc58; font-weight: 550;">创建两个立方体，红色立方体先旋转再平移，黄色立方体先平移再旋转。</span></p>
<p>先旋转再平移矩阵：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> redMatrix = matrix.<span class="title function_">multiply</span>(translationMatrix, rotateMatrix);</span><br></pre></td></tr></table></figure>

<p>先平移再旋转矩阵：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> yellowMatrix = matrix.<span class="title function_">multiply</span>(rotateMatrix, translationMatrix);</span><br></pre></td></tr></table></figure>

<p>将两个矩阵应用到立方体上，我们可以看到下面的效果：</p>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/11/1/166ce31a5fe2ff25~tplv-t2oaga2asx-image.image"></p>
<p>很容易发现，当我们需要模型自身绕着模型中心旋转时，要先执行旋转再平移，党需要模型绕世界中心旋转时，需要先平移再旋转。但通常情况，我们都是先执行旋转再执行平移，也就是红色立方体的旋转效果。</p>
<h4 id="2-2-2-考虑缩放"><a href="#2-2-2-考虑缩放" class="headerlink" title="2.2.2 考虑缩放"></a>2.2.2 考虑缩放</h4><p>当然，除了平移与旋转，有时也会涉及到模型缩放，很显然，对模型进行缩放也是要放在平移之前，但是缩放和旋转哪个在先，哪个在后呢？</p>
<p><strong>先缩放再旋转，还是先旋转再缩放？</strong></p>
<ul>
<li><strong>黄色立方体</strong>先旋转，再缩放</li>
<li><strong>红色立方体</strong>先缩放，再旋转</li>
</ul>
<p>在这里缩放比例采用 X 轴放大 2 倍， Y 轴放大 1.5 倍来处理。</p>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/11/1/166ce9597ae0d78e~tplv-t2oaga2asx-image.image"></p>
<p>可以看到，<strong>先旋转再缩放</strong>的黄色立方体不是我们所期望的结果，它会改变模型的形状。而<strong>先缩放再旋转</strong>的红色立方体则是我们所期望的。</p>
<p>上例我们采用的是不一样的缩放比例，大家能很容易地看出差别，这次我们采用一样的缩放比例，看下效果：</p>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/11/1/166cea140d8adf1c~tplv-t2oaga2asx-image.image"></p>
<p>可以看到，<strong>当缩放矩阵的缩放比例一致时，旋转与缩放的顺序就不那么重要了</strong>，表现都是一样的。</p>
<h3 id="2-3-模型变换公式"><a href="#2-3-模型变换公式" class="headerlink" title="2.3 模型变换公式"></a>2.3 模型变换公式</h3><p>假设模型变换矩阵为 <code>M</code>，其中缩放矩阵为 <code>S</code>，旋转矩阵为 <code>R</code>，平移矩阵为 <code>T</code>，考虑到我们是<strong>列主序</strong>，所以有如下公式：</p>
<p>$M = T（平移矩阵） \times R（旋转矩阵） \times S（缩放矩阵）$</p>
<h3 id="2-4-模型变换的意义"><a href="#2-4-模型变换的意义" class="headerlink" title="2.4 模型变换的意义"></a>2.4 模型变换的意义</h3><p>前面我们讲了，3D 世界中会有很多模型，每个模型所处的位置和朝向都不一样，这就需要我们对它们进行安放，模型变换就是我们安放模型的手段。</p>
<h2 id="3-视图变换"><a href="#3-视图变换" class="headerlink" title="3 视图变换"></a>3 视图变换</h2><p><img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/20250329095352.png" alt="image.png"></p>
<h3 id="3-1-坐标转换与逆矩阵的关系"><a href="#3-1-坐标转换与逆矩阵的关系" class="headerlink" title="3.1 坐标转换与逆矩阵的关系"></a>3.1 坐标转换与逆矩阵的关系</h3><p>当我们有一个变换矩阵 <code>M</code> 将坐标从 <code>A</code> 坐标系变换到 <code>B</code> 坐标系时，有</p>
<p>$P_1=M×P_0​$</p>
<p>若想从 <code>B</code> 坐标系恢复到 <code>A</code> 坐标系，就需要用 <code>M</code> 的逆矩阵：</p>
<p>$M^{-1} \times P_1 = P_0$</p>
<p>这说明，逆矩阵可以“撤销”原来的变换。</p>
<h3 id="3-2-求解相机矩阵"><a href="#3-2-求解相机矩阵" class="headerlink" title="3.2 求解相机矩阵"></a>3.2 求解相机矩阵</h3><p>在此，我们定义观察坐标系变换到世界坐标系的矩阵为相机矩阵 <code>E</code>，世界坐标系变换到观察坐标系的矩阵为视图矩阵 <code>V</code>，其中 <code>E</code> 和 <code>V</code> 互逆。</p>
<p>我们希望将世界坐标系中的顶点 $P_0$​ 变换到观察坐标系中，即求得 $P_1$​：</p>
<p>$P_1​=V×P_0​$</p>
<p>这里的<strong>视图矩阵 <code>V</code></strong> 就是世界坐标系到观察坐标系的变换矩阵。</p>
<p>我们先构造一个**相机矩阵 <code>E</code>**，它将观察坐标系的坐标转换到世界坐标系中。</p>
<p>我们已经知道的几个条件：</p>
<ul>
<li>假设相机在世界坐标系中的位置 <code>Pe (ex, ey, ez)</code>。</li>
<li>看向目标位置为 <code>T (tx,ty,tz)</code>。</li>
<li>摄像机上方方向向量 <code>upDirection 为(ux, uy, uz)</code>。</li>
</ul>
<p>为了构造 **相机矩阵 <code>E</code>**，需要确定观察坐标系的三个基向量在世界坐标系中的表示：</p>
<p>   <img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/20250103145704.png" alt="|844"></p>
<ul>
<li><strong>z 轴</strong>：从观察者指向目标点的方向向量，表示观察者的前方向。向量取差，再归一化即可得到该前方向。</li>
<li><strong>x 轴</strong>：通过 <code>z</code> 轴和 <code>upDirection</code> 向量的叉积计算得到，表示观察者的右方向。因为 <code>z</code> 轴和 <code>upDirection</code> 这两个向量在同一个平面上，故通过他们叉积计算得到 <code>x</code> 轴垂直于该平面。</li>
<li><strong>y 轴</strong>：通过 <code>x</code> 轴和 <code>z</code> 轴的叉积计算得到，这样可以确保 <code>y</code> 轴既垂直于 <code>x</code> 轴又垂直于 z 轴，从而形成一个完美正交的坐标系。</li>
</ul>
<blockquote>
<p>注意：每个轴向量求出来之后，都要归一化</p>
</blockquote>
<p>将 <code>xAxis(xx, xy, xz)</code>、<code>yAxis(yx, yy, yz)</code>、<code>zAxis(zx, zy, zz)</code> 以及相机位置 <code>Pe(ex, ey, ez)</code> 代入矩阵变换框架，可以求得相机坐标系变换到世界坐标系的矩阵 E</p>
<p>$$<br>\begin{aligned}</p>
<p>\begin{pmatrix}</p>
<p>xx &amp; yx &amp; zx &amp; ex \\</p>
<p>xy &amp; yy &amp;  zy &amp; ey \\</p>
<p>xz &amp; yz &amp; zz &amp; ez \\</p>
<p>0 &amp; 0 &amp; 0 &amp; 1</p>
<p>\end{pmatrix}</p>
<p>\end{aligned}<br>$$</p>
<p>这就是 **相机矩阵 <code>E</code>**，有了它 ，我们利用逆矩阵的算法求出 E 的逆矩阵 $E^{-1}$，即视图矩阵。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">lookAt</span>(<span class="params">eye, target, up</span>) &#123;</span><br><span class="line">  eye = <span class="keyword">new</span> <span class="title class_">Vector3</span>(eye.<span class="property">x</span>, eye.<span class="property">y</span>, eye.<span class="property">z</span>)</span><br><span class="line">  target = <span class="keyword">new</span> <span class="title class_">Vector3</span>(target.<span class="property">x</span>, target.<span class="property">y</span>, target.<span class="property">z</span>)</span><br><span class="line">  up = <span class="keyword">new</span> <span class="title class_">Vector3</span>(up.<span class="property">x</span>, up.<span class="property">y</span>, up.<span class="property">z</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> xAxis = <span class="keyword">new</span> <span class="title class_">Vector3</span>()</span><br><span class="line">  <span class="keyword">const</span> yAxis = <span class="keyword">new</span> <span class="title class_">Vector3</span>()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> zAxis = eye.<span class="title function_">sub</span>(target) </span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果摄像机位置和目标位置处于同一点</span></span><br><span class="line">  <span class="keyword">if</span> (zAxis.<span class="title function_">lengthSq</span>() === <span class="number">0</span>) &#123;</span><br><span class="line">    zAxis.<span class="property">z</span> = <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  zAxis.<span class="title function_">normalize</span>()</span><br><span class="line">  xAxis.<span class="title function_">crossVectors</span>(up, zAxis)</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 处理 zAxis 和 upDirection 平行的情况</span></span><br><span class="line">  <span class="keyword">if</span> (xAxis.<span class="title function_">length</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="title class_">Math</span>.<span class="title function_">abs</span>(up.<span class="property">z</span> == <span class="number">1</span>)) &#123;</span><br><span class="line">      zAxis.<span class="property">x</span> += <span class="number">0.0001</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      zAxis.<span class="property">z</span> += <span class="number">0.0001</span></span><br><span class="line">    &#125;</span><br><span class="line">    zAxis.<span class="title function_">normalize</span>()</span><br><span class="line">    xAxis.<span class="title function_">crossVectors</span>(up, zAxis) <span class="comment">// 这样不会改变up,zAxis的值</span></span><br><span class="line">  &#125;</span><br><span class="line">  xAxis.<span class="title function_">normalize</span>()</span><br><span class="line">  yAxis.<span class="title function_">crossVectors</span>(zAxis, xAxis) <span class="comment">// 这样不会改变zAxis,xAxis的值</span></span><br><span class="line">  yAxis.<span class="title function_">normalize</span>()</span><br><span class="line"></span><br><span class="line">  <span class="comment">// prettier-ignore</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Matrix4</span>(</span><br><span class="line">    xAxis.<span class="property">x</span>, xAxis.<span class="property">y</span>, xAxis.<span class="property">z</span>, eye.<span class="property">x</span>,</span><br><span class="line">    yAxis.<span class="property">x</span>, yAxis.<span class="property">y</span>, yAxis.<span class="property">z</span>, eye.<span class="property">y</span>,</span><br><span class="line">    zAxis.<span class="property">x</span>, zAxis.<span class="property">y</span>, zAxis.<span class="property">z</span>, eye.<span class="property">z</span>,</span><br><span class="line">    <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-3-求解视图矩阵"><a href="#3-3-求解视图矩阵" class="headerlink" title="3.3 求解视图矩阵"></a>3.3 求解视图矩阵</h3><p>求相机矩阵的逆矩阵，即为视图矩阵</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 视图矩阵</span></span><br><span class="line"><span class="keyword">const</span> eye = &#123;</span><br><span class="line">  <span class="attr">x</span>: <span class="number">0</span>,</span><br><span class="line">  <span class="attr">y</span>: <span class="number">0.0</span>,</span><br><span class="line">  <span class="attr">z</span>: <span class="number">0.5</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> target = &#123;</span><br><span class="line">  <span class="attr">x</span>: <span class="number">0</span>,</span><br><span class="line">  <span class="attr">y</span>: <span class="number">0</span>,</span><br><span class="line">  <span class="attr">z</span>: <span class="number">0</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> up = &#123;</span><br><span class="line">  <span class="attr">x</span>: <span class="number">0</span>,</span><br><span class="line">  <span class="attr">y</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">z</span>: <span class="number">0</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> cameraMatrix = <span class="title function_">lookAt</span>(eye, target, up) <span class="comment">// 相机矩阵</span></span><br><span class="line"><span class="keyword">const</span> viewMatrix = cameraMatrix.<span class="title function_">clone</span>().<span class="title function_">invert</span>() <span class="comment">// 视图矩阵</span></span><br></pre></td></tr></table></figure>

<h2 id="4-投影变换"><a href="#4-投影变换" class="headerlink" title="4 投影变换"></a>4 投影变换</h2><h3 id="4-1-可视范围"><a href="#4-1-可视范围" class="headerlink" title="4.1 可视范围"></a>4.1 可视范围</h3><p>虽然你可以将三维物体放在三维空间中的任何地方，但是只有当它在可视范围内时，WbGL 才会绘制它。事实上，不绘制可视范围外的对象，是基本的降低程序开销的手段。</p>
<p><img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/20250103164714.png" alt="image.png"></p>
<p>除了水平和垂直范围内的限制，WbGL 还限制观察者的可视深度，即<strong>能够看多远</strong>。所有这些限制，包括水平视角、垂直视角和可视深度，定义了可视空间 <code>(view volume)</code>。</p>
<p>有两类常用的可视空间：</p>
<ul>
<li><p><strong>长方体可视空间</strong>，也称盒状空间，由正射投影 <code>(orthographic projection)</code> 产生。</p>
</li>
<li><p><strong>四棱锥/金字塔可视空间</strong>，由透视投影 <code>(perspective projection)</code> 产生。</p>
</li>
</ul>
<h3 id="4-2-投影变换"><a href="#4-2-投影变换" class="headerlink" title="4.2 投影变换"></a>4.2 投影变换</h3><p>投影变换，顾名思义，就是将 3D 坐标投影到 2D 平面的过程。</p>
<p><img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/20250329100500.png" alt="image.png|717"></p>
<h3 id="4-3-左手坐标系"><a href="#4-3-左手坐标系" class="headerlink" title="4.3 左手坐标系"></a>4.3 左手坐标系</h3><p>上节我们讲到，<strong>观察空间也沿用了右手坐标系</strong>，即 Z 轴正向朝向屏幕外侧</p>
<p><img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/20250329095533.png" alt="image.png"></p>
<p><img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/20250329095056.png" alt="image.png|591"></p>
<p><img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/20250329095611.png" alt="image.png"></p>
<p>但是<strong>裁剪坐标系是左手坐标系</strong>，即 Z 轴正向朝向屏幕内侧</p>
<p><img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/20250329095934.png" alt="image.png"></p>
<p>那么在投影变换阶段，我们除了要将 3D 坐标投影到 2D 平面，还要将<strong>右手坐标系变换成左手坐标系</strong>。</p>
<h3 id="4-4-投影原理"><a href="#4-4-投影原理" class="headerlink" title="4.4 投影原理"></a>4.4 投影原理</h3><p>正交投影和透视投影的原理大体相同，基本过程如下：</p>
<ul>
<li>首先指定可视范围，即什么范围内的物体能投影。此过程通过指定近平面和远平面来圈定范围。</li>
<li><strong>将可视范围内的所有物体坐标投影到近平面上</strong>，投影后的坐标根据相似三角形原理求得，比较简单。</li>
</ul>
<p>不同之处：</p>
<ul>
<li><p>正交投影的投影线是平行线，可视范围是一个立方体盒子。</p>
<p><img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/20250328173716.png" alt="image.png"></p>
</li>
</ul>
<ul>
<li><p>透视投影的投影线是相交线，可视范围是一个棱锥体盒子，这样经过投影后才能达到近大远小的效果。</p>
<p><img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/20250328173841.png" alt="image.png|870"></p>
</li>
</ul>
<p>上面两种<strong>投影坐标系原点均位于投影盒正中心位置</strong>，因为是左手坐标系，所以，Z 轴朝向屏幕内侧。</p>
<ol>
<li><strong>伸出左手</strong>，手掌朝着屏幕，手指指向屏幕。</li>
<li><strong>拇指朝右（X 轴），食指朝上（Y 轴），中指指向屏幕（Z 轴）</strong>。</li>
<li>你的 <strong>Z 轴是往屏幕里指的</strong>，这就是左手坐标系的特点。</li>
</ol>
<blockquote>
<p><strong>正交投影</strong> 的可视范围是一个立方体盒子，<strong>透视投影</strong> 的可视范围是一个棱锥体盒子</p>
<ul>
<li><code>X</code> 轴：从 <strong>左</strong> 到 <strong>右</strong>（-1 到 1）</li>
<li><code>Y</code> 轴：从 <strong>下</strong> 到 <strong>上</strong>（-1 到 1）</li>
<li><code>Z</code> 轴：从 <strong>近平面</strong> 到 <strong>远平面</strong>，范围通常是 <code>[-1, 1]</code> 或 <code>[0, 1]</code>（取决于深度缓冲的定义）。</li>
</ul>
<p><strong>左手坐标系</strong> 是指：</p>
<ul>
<li><code>X</code> 轴：右</li>
<li><code>Y</code> 轴：上</li>
<li><code>Z</code> 轴：<strong>指向屏幕内</strong><br>故：</li>
<li>越靠近相机（屏幕前面），Z 值越小</li>
<li>越远离相机（屏幕深处），Z 值越大</li>
</ul>
</blockquote>
<h3 id="4-5-投影算法推导"><a href="#4-5-投影算法推导" class="headerlink" title="4.5 投影算法推导"></a>4.5 投影算法推导</h3><p>接下来，我们推导一下投影变换算法。假设模型中有一点 <code>P</code>，且 <code>P</code> 的坐标为 <code>(x,y,z)</code>，那么投影到近平面后的坐标 <code>P&#39; = (x&#39;,y&#39;,z&#39;)</code>。那么 <code>P&#39;</code> 和 <code>P</code> 之间的关系是什么呢？</p>
<p>我们已知的条件有以下几个：</p>
<ul>
<li>近平面的 z 值 <code>zNear</code>。</li>
<li>近平面的宽度 <code>width</code> 和高度 <code>height</code>。</li>
<li>远平面的 z 值 <code>zFar</code>。</li>
</ul>
<p><code>zFar</code> 和 <code>zNear</code> 是相机坐标系中的 <code>Z</code> 轴坐标，由于相机坐标系是右手坐标系，<code>Z</code> 轴朝向屏幕外侧，所以 <code>zNear</code> 是大于 <code>zFar</code> 的，这点在做坐标转换时需要注意。</p>
<p>接下来分析一下如何根据这些已知条件推导出 <code>P&#39;</code> 坐标，当推导出 <code>P&#39;</code> 坐标之后，也就有了相应地投影矩阵。</p>
<h4 id="4-5-1-正交投影"><a href="#4-5-1-正交投影" class="headerlink" title="4.5.1 正交投影"></a>4.5.1 正交投影</h4><p><img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/20250329100302.png" alt="image.png"></p>
<p><strong>世界坐标系</strong>（投影盒）中的坐标范围</p>
<ul>
<li><strong>X 轴</strong>：范围是 <code>[left,right]</code></li>
<li><strong>Y 轴</strong>：范围是 <code> [bottom,top]</code></li>
<li><strong>Z 轴</strong>：范围是 <code>[zNear,zFar]</code></li>
</ul>
<p><strong>投影后（NDC 坐标系）中的坐标范围</strong></p>
<ul>
<li><strong>X 轴</strong>：<code>[−1,1]</code></li>
<li><strong>Y 轴</strong>：<code>[−1,1]</code></li>
<li><strong>Z 轴</strong>：<code>[−1,1]</code></li>
</ul>
<p>正射投影就是把可视空间内的坐标映射到 <code>x [-1,1], y [-1,1], z [-1,1]</code> 的区间内。</p>
<p><img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/20250329093349.png" alt="image.png"></p>
<p><img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/20250329100643.png" alt="image.png|650"></p>
<ul>
<li><code>&lt;canvas&gt;</code> 上显示的就是可视空间中物体在<strong>近裁剪面上的投影</strong>。</li>
<li>如果裁剪面的宽高比和 <code>&lt;canvas&gt;</code> 不一样，那么画面就会被按照 <code>&lt;canvas&gt;</code> 的宽高比进行压缩，物体会被扭曲。</li>
<li>近裁剪面与远裁剪面之间的盒形空间就是可视空间，只有在此空间内的物体会被显示出来。</li>
</ul>
<p>我们最终需要一个矩阵 M，使用该矩阵左乘顶点向量 P，即可得到 P’。</p>
<p>按照惯例，我们还是找出 P’ 和 P 之间的关系：</p>
<h5 id="x-轴变换"><a href="#x-轴变换" class="headerlink" title="x 轴变换"></a>x 轴变换</h5><p><img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/20250329090605.png" alt="image.png"></p>
<h5 id="y-轴变换"><a href="#y-轴变换" class="headerlink" title="y 轴变换"></a>y 轴变换</h5><p><img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/20250329090624.png" alt="image.png"></p>
<h5 id="Z-轴变换"><a href="#Z-轴变换" class="headerlink" title="Z 轴变换"></a>Z 轴变换</h5><p><img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/20250329090638.png" alt="image.png"></p>
<h5 id="正交投影矩阵"><a href="#正交投影矩阵" class="headerlink" title="正交投影矩阵"></a>正交投影矩阵</h5><p>将上面的 x’、y’、z’ 代入上式，即可求出正交投影矩阵：</p>
<p><img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/20250329090712.png" alt="image.png"></p>
<p>这个矩阵的作用是：</p>
<ul>
<li>把 <strong>世界坐标系</strong> 中的点转换到 <strong>NDC 坐标系</strong>，并保证所有坐标范围都落在 <code>[−1,1]</code> 之间。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getOrtho</span>(<span class="params">l, r, t, b, n, f</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> w = r - l;</span><br><span class="line">  <span class="keyword">const</span> h = t - b;</span><br><span class="line">  <span class="keyword">const</span> d = f - n;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> [</span><br><span class="line">    <span class="number">2</span> / w, <span class="number">0</span>, <span class="number">0</span>, -(r + l)/w,</span><br><span class="line">    <span class="number">0</span>, <span class="number">2</span> / h, <span class="number">0</span>, -(t + b)/h,</span><br><span class="line">    <span class="number">0</span>, <span class="number">0</span>, -<span class="number">2</span> / d, -(f+n)/d,</span><br><span class="line">    <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">  ];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h5><p>我们用一个立方体来演示一下，你会发现，<strong>无论远平面距离多远，立方体的大小是不会变的</strong>。</p>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/11/28/16759b62a70afdc2~tplv-t2oaga2asx-image.image"></p>
<p>可以看到，无论我们将镜头移到多远，物体投影后的大小始终不变。</p>
<p>那么什么会影响物体投影后的大小呢？有的同学已经猜到了，投影盒的宽度和高度。</p>
<p>我们试一下：</p>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/11/28/16759b75066d50e1~tplv-t2oaga2asx-image.image" alt="|734"></p>
<p>可以看到，<strong>将宽度和高度增大之后，物体投影后变小了</strong>。</p>
<h4 id="4-5-2-透视投影"><a href="#4-5-2-透视投影" class="headerlink" title="4.5.2 透视投影"></a>4.5.2 透视投影</h4><p>透视投影是我们比较常用的投影方式，它能够实现现实生活中人眼看向世界产生的近大远小的效果。接下来我们推导一下透视算法。</p>
<p>和正交投影类似，透视投影也接收近平面和远平面参数，不同的是，透视投影的投影盒是一个棱锥体。正因为如此，透视投影才可以实现近大远小的效果。</p>
<p><img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/20250328173841.png" alt="image.png|870"></p>
<p>通过上面透视投影示例图，根据相似三角形原理，我们可以知道如下关系：</p>
<p>$$<br>\frac{zNear}{z} = \frac{y_1}{y} = \frac{x_1}{x}<br>$$</p>
<p>所以有：</p>
<p>$$<br>\begin{aligned}</p>
<p>x_1 = \frac{zNear * x}{z} \\</p>
<p>y_1 = \frac{zNear * y}{z}</p>
<p>\end{aligned}<br>$$</p>
<p>其中 $x_1$ 和 $y_1$ 是相机坐标系坐标经过视线看向物体后在近平面上的交点坐标，此时 $x_1$ 和 $y_1$ 还是相机坐标系下坐标，并没有变换到裁剪坐标系，我们还要将 $x_1$ 和 $y_1$ 变换到【-1，1】之间。</p>
<p>$$<br>\begin{aligned}</p>
<p>x’ = \frac{x_1} {z * width /2} = \frac{zNear * x} {z * width /2} \\</p>
<p>\\</p>
<p>y’ = \frac{y_1} {z * height /2} = \frac{zNear * y} {z * height /2} \\</p>
<p>\end{aligned}<br>$$</p>
<p>注意这里，<code>x&#39;</code> 和 <code>y&#39;</code> 是已经映射到裁剪坐标系的坐标，而且由于相机坐标系与投影坐标系的 Z 轴方向相反，因此需要对 Z 轴坐标取反，最终公式变为：</p>
<p>$$<br>\begin{aligned}</p>
<p>x’ = - \frac{zNear * x} {z * width /2} \\</p>
<p>\\</p>
<p>y’ = - \frac{zNear * y} {z * height /2} \\</p>
<p>\end{aligned}<br>$$</p>
<p>看到这里，你会发现，<code>x&#39;</code> 和 <code>y&#39;</code> 不仅和投影面的宽度和高度有关系，还和 <code>z</code> 轴坐标有关系，<code>z</code> 轴坐标越大，<code>x&#39;</code> 和 <code>y&#39;</code> 越小，也就产生了近大远小的效果</p>
<p>因为投影后的坐标 <code>(x&#39;, y&#39;, z&#39;)</code> <strong>通过齐次坐标的除法来得到</strong> </p>
<p><img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/20250329110356.png" alt="image.png"></p>
<p>故这里我们将齐次坐标 <code>w</code> 分量设置为 <code>z</code>，即 <code>w=z</code>，因为最终还要除以 <code>w=z</code>，故这里等式右边乘以一个 <code>w=z</code></p>
<p>此时 <code>x&#39;</code> 和 <code>y&#39;</code> 的值为：</p>
<p>$$<br>\begin{aligned}</p>
<p>x’ = - \frac{zNear * x} {width /2} \\</p>
<p>\\</p>
<p>y’ = - \frac{zNear * y} {height /2} \\</p>
<p>\end{aligned}<br>$$</p>
<p>接下来，我们看下 <code>z&#39;</code> 和 <code>z</code> 之间的关系，因为矩阵变换本身是 <strong>线性的</strong></p>
<p>所以这里假设 <code>z&#39;</code> 和 <code>z</code> 有如下等式：</p>
<p>$$<br>z’ = az + b;<br>$$</p>
<p>其中 a 和 b 是常量，待求，又因为：</p>
<ul>
<li>当 <code>z = zNear</code> 时，<code>z&#39; = -1</code>；</li>
<li>当 <code>z = zFar</code> 时，<code>z&#39; = 1</code>。</li>
</ul>
<p>但这里的条件满足的是<strong>除以 w=z</strong>后的等式，即如下等式：</p>
<p>$$<br>z’ = a + b / z<br>$$</p>
<blockquote>
<p>最终的 <code>z&#39;</code> 和 <code>z</code> 之间是 <strong>反比关系</strong>，并且通过齐次坐标的处理（<code>w = z</code>）来确保 <strong>深度压缩</strong> 的效果</p>
</blockquote>
<p>代入得：</p>
<p>$$<br>a + \frac {b} { zNear} = -1<br>$$</p>
<p>$$<br>a + \frac {b} {zFar} = 1<br>$$</p>
<p>解这两个方程，可以求出 a 和 b 的值：</p>
<p>$$<br>a = \frac{zFar + zNear}{zFar - zNear}<br>$$</p>
<p>$$<br>b = \frac{2 \times zFar \times zNear}{zFar - zNear}<br>$$</p>
<p>依然按照正交投影的参数，<code>width</code> 由 <code>left</code> 和 <code>right</code> 决定，<code>height</code> 由 <code>top</code> 和 <code>bottom</code> 决定，</p>
<p>根据上述推导过程，我们可以得出透视投影的变换矩阵 M</p>
<p>$$<br>\begin{aligned}</p>
<p>M = \begin{pmatrix}</p>
<p>\frac{2 \times zNear}{right - left} &amp; 0 &amp; 0 &amp; \frac{right + left}{left - right} \\</p>
<p> 0 &amp; \frac{2 \times zNear}{top - bottom} &amp; 0 &amp; \frac{top + bottom}{bottom - top} \\</p>
<p> 0 &amp; 0 &amp; \frac{2(zFar + zNear)}{zNear - zFar} &amp; \frac{2 \times zFar \times zNear}{zNear - zFar} \\</p>
<p> 0 &amp; 0 &amp; -1 &amp; 0 </p>
<p>\end{pmatrix}</p>
<p>\end{aligned}<br>$$</p>
<p>除了传递以 <code>left</code> 、<code>right</code>、<code>top</code>、<code>bottom</code> 方式传递近平面参数以外，为了方便，业界往往用视角 <code>fov</code> 和宽高比 <code>aspect</code> 的方式代替它们，</p>
<ul>
<li>由于 <code>fov</code> 是垂直视场角，**<code>tan(fov/2)</code>** 就是从视点到近平面的视锥体一半的高度与深度的比值。</li>
<li><code>aspect</code> 则是视口的宽高比，表示宽度与高度之比，<code>width = aspect * height</code></li>
</ul>
<p>推导过程和上面几乎一样，只不过我们以 <code>aspect</code> 和 <code>fov</code> 角度 <code>θ</code> 来代替 <code>x&#39;</code> 和 <code>y&#39;</code></p>
<p>$$<br>\begin{aligned}</p>
<p>x’ &amp;= \frac {2 \times zNear} {width}\\</p>
<p>&amp;=\frac{1}{aspect \times tan(\theta/2)}</p>
<p>\end{aligned}<br>$$</p>
<p>$$<br>\begin{aligned}</p>
<p>y’ &amp;= \frac {2 \times zNear} {height}\\</p>
<p>&amp;=\frac{1}{tan(\theta/2)}</p>
<p>\end{aligned}<br>$$</p>
<p>所以这种方式下的透视投影矩阵为：</p>
<p><img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/20250329115008.png" alt="image.png|686"></p>
<p>当你用视角 (<code>fov</code>) 和宽高比 (<code>aspect</code>) 来替代裁剪平面的 <code>left</code>、<code>right</code>、<code>top</code>、<code>bottom</code> 时，矩阵的结构会发生一些变化。具体来说，<code>fov</code> 和 <code>aspect</code> 用来代替之前的投影平面参数。由于视角和宽高比已知，我们可以直接通过它们来计算 <code>x&#39;</code> 和 <code>y&#39;</code>：</p>
<p><img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/20250329121447.png" alt="image.png"></p>
<p>这就导致了透视投影矩阵中的 <code>x&#39;</code> 和 <code>y&#39;</code> 计算部分不再依赖于 <code>left</code>、<code>right</code>、<code>top</code> 和 <code>bottom</code>，所以矩阵的第 1 和第 2 行的值变为了 0，简化了计算。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取透视投影矩阵</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getPerspective</span>(<span class="params">fov, aspect, near, far</span>) &#123;</span><br><span class="line">  fov = (fov * <span class="title class_">Math</span>.<span class="property">PI</span>) / <span class="number">180</span>;</span><br><span class="line">  <span class="keyword">const</span> tanFov = <span class="title class_">Math</span>.<span class="title function_">tan</span>(fov / <span class="number">2</span>);</span><br><span class="line">  <span class="keyword">const</span> depthScale = <span class="number">2</span> *( far + near) / (near- far);</span><br><span class="line">  <span class="keyword">const</span> depthOffset = (<span class="number">2</span> * far * near) / (near- far);</span><br><span class="line">  <span class="comment">// 列主序排列</span></span><br><span class="line">  <span class="keyword">return</span> [</span><br><span class="line">    <span class="number">1</span> / (aspect * tanFov), <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">    <span class="number">0</span>, <span class="number">1</span> / tanFov, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">    <span class="number">0</span>, <span class="number">0</span>, depthScale, depthOffset,</span><br><span class="line">    <span class="number">0</span>, <span class="number">0</span>, -<span class="number">1</span>, <span class="number">0</span></span><br><span class="line">  ];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://VernalScenery.github.io">Scenery</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://vernalscenery.github.io/2025/03/28/%E5%9B%BE%E5%BD%A2%E5%AD%A6/WebGL/06_WeBGL_%E5%9D%90%E6%A0%87%E7%B3%BB%E8%AF%A6%E8%A7%A3/">https://vernalscenery.github.io/2025/03/28/%E5%9B%BE%E5%BD%A2%E5%AD%A6/WebGL/06_WeBGL_%E5%9D%90%E6%A0%87%E7%B3%BB%E8%AF%A6%E8%A7%A3/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://VernalScenery.github.io" target="_blank">春和景明的记事本</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/WebGL/">WebGL</a></div><div class="post_share"><div class="social-share" data-image="/./img/1.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2025/03/31/%E5%9B%BE%E5%BD%A2%E5%AD%A6/WebGL/08_WeBGL_%E5%85%89%E7%85%A7/" title="08_WeBGL_光照"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">08_WeBGL_光照</div></div></a></div><div class="next-post pull-right"><a href="/2025/03/26/%E5%9B%BE%E5%BD%A2%E5%AD%A6/WebGL/02_WebGL_%E7%BB%98%E5%9B%BE%E8%AF%A6%E8%A7%A3/" title="02_WebGL_绘图详解"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">02_WebGL_绘图详解</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2025/03/26/%E5%9B%BE%E5%BD%A2%E5%AD%A6/WebGL/01_WebGL_%E5%85%A5%E9%97%A8/" title="01_WebGL_入门"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2025-03-26</div><div class="title">01_WebGL_入门</div></div></a></div><div><a href="/2025/03/26/%E5%9B%BE%E5%BD%A2%E5%AD%A6/WebGL/00_WebGL_%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%88%9D%E8%AF%86/" title="00_WebGL_图形学初识"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2025-03-26</div><div class="title">00_WebGL_图形学初识</div></div></a></div><div><a href="/2024/12/31/%E5%9B%BE%E5%BD%A2%E5%AD%A6/WebGL/03_WebGL_%E4%BB%BF%E5%B0%84%E5%8F%98%E6%8D%A2/" title="02_WebGL_仿射变换"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-12-31</div><div class="title">02_WebGL_仿射变换</div></div></a></div><div><a href="/2025/01/03/%E5%9B%BE%E5%BD%A2%E5%AD%A6/WebGL/05_WeBGL_%E4%B8%89%E7%BB%B4%E5%9C%BA%E6%99%AF%E5%9F%BA%E7%A1%80/" title="05_WeBGL_三维场景基础"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2025-01-03</div><div class="title">05_WeBGL_三维场景基础</div></div></a></div><div><a href="/2025/03/26/%E5%9B%BE%E5%BD%A2%E5%AD%A6/WebGL/02_WebGL_%E7%BB%98%E5%9B%BE%E8%AF%A6%E8%A7%A3/" title="02_WebGL_绘图详解"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2025-03-26</div><div class="title">02_WebGL_绘图详解</div></div></a></div><div><a href="/2025/01/03/%E5%9B%BE%E5%BD%A2%E5%AD%A6/WebGL/04_WebGL_%E7%BA%B9%E7%90%86%E8%B4%B4%E5%9B%BE/" title="04_WebGL_纹理贴图"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2025-01-03</div><div class="title">04_WebGL_纹理贴图</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/./img/1.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Scenery</div><div class="author-info__description">今天不想跑，所以才去跑</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">73</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">13</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/chjm0121" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="/1595718686@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9D%90%E6%A0%87%E7%B3%BB"><span class="toc-text">坐标系</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E5%9D%90%E6%A0%87%E7%B3%BB%E5%88%86%E7%B1%BB"><span class="toc-text">1 坐标系分类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-%E6%A8%A1%E5%9E%8B%E5%9D%90%E6%A0%87%E7%B3%BB%EF%BC%88Model-Space%EF%BC%89"><span class="toc-text">1.1 模型坐标系（Model Space）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-%E4%B8%96%E7%95%8C%E5%9D%90%E6%A0%87%E7%B3%BB%EF%BC%88World-Space%EF%BC%89"><span class="toc-text">1.2 世界坐标系（World Space）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-%E8%A7%82%E5%AF%9F%E5%9D%90%E6%A0%87%E7%B3%BB-%E8%A7%86%E5%9B%BE%E5%9D%90%E6%A0%87%E7%B3%BB%EF%BC%88View-Camera-Space%EF%BC%89"><span class="toc-text">1.3 观察坐标系&#x2F;视图坐标系（View&#x2F;Camera Space）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-%E8%A3%81%E5%89%AA%E5%9D%90%E6%A0%87%E7%B3%BB%EF%BC%88Clip-Space%EF%BC%89"><span class="toc-text">1.4 裁剪坐标系（Clip Space）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-5-%E5%BD%92%E4%B8%80%E5%8C%96%E8%AE%BE%E5%A4%87%E5%9D%90%E6%A0%87%E7%B3%BB%EF%BC%88NDC-Normalized-Device-Coordinates%EF%BC%89"><span class="toc-text">1.5 归一化设备坐标系（NDC, Normalized Device Coordinates）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-6-%E5%B1%8F%E5%B9%95%E5%9D%90%E6%A0%87%E7%B3%BB%EF%BC%88Screen-Space%EF%BC%89"><span class="toc-text">1.6 屏幕坐标系（Screen Space）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E5%9D%90%E6%A0%87%E8%BD%AC%E6%8D%A2%E6%B5%81%E6%B0%B4%E7%BA%BF"><span class="toc-text">2 坐标转换流水线</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-CPU-%E7%AB%AF%E7%9A%84%E8%BD%AC%E6%8D%A2"><span class="toc-text">2.1 CPU 端的转换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-GPU-%E7%AB%AF%E7%9A%84%E8%BD%AC%E6%8D%A2"><span class="toc-text">2.2 GPU 端的转换</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E5%9D%90%E6%A0%87%E5%8F%98%E6%8D%A2%E4%B8%BE%E4%BE%8B"><span class="toc-text">3 坐标变换举例</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-%E6%A8%A1%E5%9E%8B%E5%9D%90%E6%A0%87"><span class="toc-text">3.1 模型坐标</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-%E4%B8%96%E7%95%8C%E5%9D%90%E6%A0%87%E7%B3%BB"><span class="toc-text">3.2 世界坐标系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-%E8%A7%82%E5%AF%9F%E5%9D%90%E6%A0%87%E7%B3%BB"><span class="toc-text">3.3 观察坐标系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-%E8%A3%81%E5%89%AA%E5%9D%90%E6%A0%87%E7%B3%BB"><span class="toc-text">3.4 裁剪坐标系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-5-NDC-%E5%9D%90%E6%A0%87%E7%B3%BB"><span class="toc-text">3.5 NDC 坐标系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-6-%E8%A7%86%E5%8F%A3%E5%8F%98%E6%8D%A2"><span class="toc-text">3.6 视口变换</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BB%BF%E5%B0%84%E5%8F%98%E6%8D%A2"><span class="toc-text">仿射变换</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E7%9F%A9%E9%98%B5%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5"><span class="toc-text">1 矩阵相关概念</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-text">1.1 注意事项</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A1%8C%E4%B8%BB%E5%BA%8F%E5%92%8C%E5%88%97%E4%B8%BB%E5%BA%8F"><span class="toc-text">行主序和列主序</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-%E9%BD%90%E6%AC%A1%E5%9D%90%E6%A0%87"><span class="toc-text">1.2 齐次坐标</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-%E7%94%A8%E7%9F%A9%E9%98%B5%E6%9D%A5%E8%A1%A8%E7%A4%BA%E5%B9%B3%E7%A7%BB%E5%8F%98%E6%8D%A2"><span class="toc-text">1.3 用矩阵来表示平移变换</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E5%8F%98%E6%8D%A2%E7%9F%A9%E9%98%B5%E7%9A%84%E6%8E%A8%E5%AF%BC"><span class="toc-text">2 变换矩阵的推导</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E5%8F%98%E6%8D%A2%E7%9F%A9%E9%98%B5%E7%9A%84%E6%B1%82%E8%A7%A3%E6%80%9D%E8%B7%AF"><span class="toc-text">2.1 变换矩阵的求解思路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-%E5%B9%B3%E7%A7%BB%E7%9F%A9%E9%98%B5"><span class="toc-text">2.2 平移矩阵</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-%E7%BC%A9%E6%94%BE%E7%9F%A9%E9%98%B5"><span class="toc-text">2.3 缩放矩阵</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-%E6%97%8B%E8%BD%AC%E7%9F%A9%E9%98%B5"><span class="toc-text">2.4 旋转矩阵</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-1-%E7%BB%95-X-%E8%BD%B4%E6%97%8B%E8%BD%AC"><span class="toc-text">2.4.1 绕 X 轴旋转</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-2-%E7%BB%95-Y-%E8%BD%B4%E6%97%8B%E8%BD%AC"><span class="toc-text">2.4.2 绕 Y 轴旋转</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-3-%E7%BB%95-Z-%E8%BD%B4%E6%97%8B%E8%BD%AC"><span class="toc-text">2.4.3 绕 Z 轴旋转</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-4-%E7%BB%95%E4%BB%BB%E6%84%8F%E8%BD%B4%E6%97%8B%E8%BD%AC"><span class="toc-text">2.4.4 绕任意轴旋转</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B1%82%E8%A7%A3%E6%AD%A5%E9%AA%A4"><span class="toc-text">求解步骤</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9D%90%E6%A0%87%E7%B3%BB%E5%8F%98%E6%8D%A2"><span class="toc-text">坐标系变换</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E5%9D%90%E6%A0%87%E7%B3%BB%E5%8F%98%E6%8D%A2%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-text">1 坐标系变换的分类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E6%A8%A1%E5%9E%8B%E5%8F%98%E6%8D%A2"><span class="toc-text">2 模型变换</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E5%BC%95%E5%85%A5"><span class="toc-text">2.1 引入</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-%E5%8F%98%E6%8D%A2%E9%A1%BA%E5%BA%8F"><span class="toc-text">2.2 变换顺序</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-1-%E5%B9%B3%E7%A7%BB%E4%B8%8E%E6%97%8B%E8%BD%AC"><span class="toc-text">2.2.1 平移与旋转</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-2-%E8%80%83%E8%99%91%E7%BC%A9%E6%94%BE"><span class="toc-text">2.2.2 考虑缩放</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-%E6%A8%A1%E5%9E%8B%E5%8F%98%E6%8D%A2%E5%85%AC%E5%BC%8F"><span class="toc-text">2.3 模型变换公式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-%E6%A8%A1%E5%9E%8B%E5%8F%98%E6%8D%A2%E7%9A%84%E6%84%8F%E4%B9%89"><span class="toc-text">2.4 模型变换的意义</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E8%A7%86%E5%9B%BE%E5%8F%98%E6%8D%A2"><span class="toc-text">3 视图变换</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-%E5%9D%90%E6%A0%87%E8%BD%AC%E6%8D%A2%E4%B8%8E%E9%80%86%E7%9F%A9%E9%98%B5%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-text">3.1 坐标转换与逆矩阵的关系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-%E6%B1%82%E8%A7%A3%E7%9B%B8%E6%9C%BA%E7%9F%A9%E9%98%B5"><span class="toc-text">3.2 求解相机矩阵</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-%E6%B1%82%E8%A7%A3%E8%A7%86%E5%9B%BE%E7%9F%A9%E9%98%B5"><span class="toc-text">3.3 求解视图矩阵</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E6%8A%95%E5%BD%B1%E5%8F%98%E6%8D%A2"><span class="toc-text">4 投影变换</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-%E5%8F%AF%E8%A7%86%E8%8C%83%E5%9B%B4"><span class="toc-text">4.1 可视范围</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-%E6%8A%95%E5%BD%B1%E5%8F%98%E6%8D%A2"><span class="toc-text">4.2 投影变换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-%E5%B7%A6%E6%89%8B%E5%9D%90%E6%A0%87%E7%B3%BB"><span class="toc-text">4.3 左手坐标系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-4-%E6%8A%95%E5%BD%B1%E5%8E%9F%E7%90%86"><span class="toc-text">4.4 投影原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-5-%E6%8A%95%E5%BD%B1%E7%AE%97%E6%B3%95%E6%8E%A8%E5%AF%BC"><span class="toc-text">4.5 投影算法推导</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-5-1-%E6%AD%A3%E4%BA%A4%E6%8A%95%E5%BD%B1"><span class="toc-text">4.5.1 正交投影</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#x-%E8%BD%B4%E5%8F%98%E6%8D%A2"><span class="toc-text">x 轴变换</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#y-%E8%BD%B4%E5%8F%98%E6%8D%A2"><span class="toc-text">y 轴变换</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Z-%E8%BD%B4%E5%8F%98%E6%8D%A2"><span class="toc-text">Z 轴变换</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%AD%A3%E4%BA%A4%E6%8A%95%E5%BD%B1%E7%9F%A9%E9%98%B5"><span class="toc-text">正交投影矩阵</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%89%B9%E7%82%B9"><span class="toc-text">特点</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-5-2-%E9%80%8F%E8%A7%86%E6%8A%95%E5%BD%B1"><span class="toc-text">4.5.2 透视投影</span></a></li></ol></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/08/05/Python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/02_%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90_Numpy/" title="02_数据分析_Numpy">02_数据分析_Numpy</a><time datetime="2025-08-04T21:11:38.000Z" title="发表于 2025-08-05 05:11:38">2025-08-05</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/08/05/Python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/01_%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90_python%E8%AF%AD%E6%B3%95/" title="01_数据分析_python语法">01_数据分析_python语法</a><time datetime="2025-08-04T18:44:45.000Z" title="发表于 2025-08-05 02:44:45">2025-08-05</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/07/29/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E5%9F%BA%E7%A1%80%E5%8E%9F%E7%90%86/13_%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0_%E6%A6%82%E7%8E%87%E5%9B%BE%E6%A8%A1%E5%9E%8B/" title="13_机器学习_概率图模型">13_机器学习_概率图模型</a><time datetime="2025-07-29T00:29:02.000Z" title="发表于 2025-07-29 08:29:02">2025-07-29</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/07/28/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E5%9F%BA%E7%A1%80%E5%8E%9F%E7%90%86/11_%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0_%E8%81%9A%E7%B1%BB/" title="11_机器学习_聚类">11_机器学习_聚类</a><time datetime="2025-07-28T00:19:53.000Z" title="发表于 2025-07-28 08:19:53">2025-07-28</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/07/28/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E5%9F%BA%E7%A1%80%E5%8E%9F%E7%90%86/12_%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0_%E9%99%8D%E7%BB%B4/" title="12_机器学习_降维">12_机器学习_降维</a><time datetime="2025-07-27T20:48:42.000Z" title="发表于 2025-07-28 04:48:42">2025-07-28</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('/./img/1.jpg')"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2025 By Scenery</div><div class="footer_custom_text"><div>波澜不惊</div><div class="footer-div"><img class="footer-icon" src="./img/备案图标.png"><a class="footer-a" target="_blank" rel="noopener" href="http://beian.miit.gov.cn/">皖ICP备2021016944号-1</a></div></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.13.0"></script><script src="/js/main.js?v=4.13.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@5.2.0/instantpage.min.js" type="module"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=4.13.0"></script></div></div></body></html>