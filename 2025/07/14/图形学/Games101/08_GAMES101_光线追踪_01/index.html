<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>08_GAMES101_光线追踪_01 | 春和景明的记事本</title><meta name="author" content="Scenery"><meta name="copyright" content="Scenery"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Why Ray Tracing?问题所在：像 Blinn-Phong 这样的局部光照模型，只计算从直接光源到物体表面的光照，无法处理全局效果。 具体例子：一个房间的天花板，除了被灯直接照亮，还可能被“窗户光线 → 照射地板 → 反射到天花板”的光照亮。这部分由反射产生的间接光照，局部模型无法模拟。"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://vernalscenery.github.io/2025/07/14/%E5%9B%BE%E5%BD%A2%E5%AD%A6/Games101/08_GAMES101_%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA_01/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=4.13.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '08_GAMES101_光线追踪_01',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2025-08-05 14:17:12'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><link rel="stylesheet" href="/css/style.css"><meta name="generator" content="Hexo 5.4.2"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/./img/1.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">73</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">14</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/./img/1.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="春和景明的记事本"><span class="site-name">春和景明的记事本</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">08_GAMES101_光线追踪_01</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-07-13T19:40:18.000Z" title="发表于 2025-07-14 03:40:18">2025-07-14</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-08-05T06:17:12.000Z" title="更新于 2025-08-05 14:17:12">2025-08-05</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">6.9k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>21分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="08_GAMES101_光线追踪_01"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="Why-Ray-Tracing"><a href="#Why-Ray-Tracing" class="headerlink" title="Why Ray Tracing?"></a>Why Ray Tracing?</h1><p><strong>问题所在</strong>：像 Blinn-Phong 这样的<strong>局部光照模型</strong>，只计算从直接光源到物体表面的光照，无法处理<strong>全局效果</strong>。</p>
<p><strong>具体例子</strong>：一个房间的天花板，除了被灯直接照亮，还可能被“窗户光线 → 照射地板 → 反射到天花板”的光照亮。这部分由反射产生的<strong>间接光照</strong>，局部模型无法模拟。</p>
<p><img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/20250715162303.png" alt="image.png"></p>
<p>光线追踪在物理上是<strong>精确</strong>的，它通过模拟光线的传播、反弹路径来生成图像。这使得它能够完美地实现光栅化难以做到的<strong>全局效果</strong>，例如：</p>
<ul>
<li>**软阴影 (Soft Shadows)**：由大面积光源产生的边缘柔和的阴影。</li>
<li>**光滑反射 (Glossy Reflection)**：像镜子或金属一样清晰地反射出周围环境。</li>
<li>**间接光照 (Indirect Illumination)**：光线从一个物体表面反弹到另一个物体上，照亮了没有被直接光源照射的区域（这是实现场景真实感的关键）。</li>
</ul>
<h1 id="Whitted-Style-光线追踪算法"><a href="#Whitted-Style-光线追踪算法" class="headerlink" title="Whitted-Style 光线追踪算法"></a>Whitted-Style 光线追踪算法</h1><h2 id="1-核心思想"><a href="#1-核心思想" class="headerlink" title="1 核心思想"></a>1 核心思想</h2><p>光线追踪听名字就知道，讨论的核心是光线，因此我们首先对光线做一些假设：</p>
<ol>
<li>光线沿<strong>直线</strong>传播。</li>
<li>光线之间<strong>不会碰撞</strong>。</li>
<li>光路是<strong>可逆</strong>的，即从 A 发出的到 B 的光线，一定也可以从 B 发出到 A（中途可发生反射和折射）。</li>
</ol>
<p>明白了光线的一些假设之后，想一想人为什么能看到不同的物体？是因为从物体表面上有光进入了人眼。那么能不能逆向思考一下，是不是也可理解为人眼发出了很多感知光线碰撞到了物体，所以可以看见呢？</p>
<ul>
<li><strong>基本思路</strong>：光线追踪的核心是模拟对最终成像有贡献的光路。</li>
<li><strong>遇到的困难</strong>：从光源发出无数光线来模拟整个场景是极其低效的，因为绝大部分光线永远不会进入到摄像机（人眼）中，做了大量无用功。</li>
<li><strong>巧妙的解决方案</strong>：利用<strong>光路可逆</strong>原理 (从 A 到 B 的光路，也存在从 B 到 A 的路径)。我们可以<strong>反向思考</strong>：不从光源追踪，而是从<strong>摄像机（人眼）向场景中发射“感知光线”</strong>。</li>
<li><strong>工作流程</strong>：<ol>
<li>从摄像机的每个像素位置，向场景发射一条光线。</li>
<li>追踪这条光线与物体的交点。</li>
<li>在交点处，根据物体材质，计算光线如何反射或折射，并继续追踪，直到光线最终击中光源或逃逸出场景。</li>
</ol>
</li>
<li><strong>本质</strong>：这种从摄像机出发的<strong>反向追踪</strong>方法，虽然物理上是“错”的（人眼不发光），但在计算上是等效且高效的。它确保了被追踪的每一条光线路径，都是对最终图像有贡献的路径。</li>
</ul>
<h2 id="2-算法流程"><a href="#2-算法流程" class="headerlink" title="2 算法流程"></a>2 算法流程</h2><blockquote>
<p> Whitted-Style 光线追踪算法（Whitted-Style Ray Tracing），又称经典光线追踪或递归光线追踪，是计算机图形学中一个里程碑式的算法。它由特纳·惠特（J. Turner Whitted）在 1979 年的论文《一种改进的阴影显示光照模型》中首次提出，极大地提升了计算机生成图像的真实感。</p>
</blockquote>
<p>该算法是一个优雅的递归过程，它将渲染分为两个主要阶段：</p>
<h3 id="2-1-第一步-：光线投射-Ray-Casting-确定可见性与直接光照"><a href="#2-1-第一步-：光线投射-Ray-Casting-确定可见性与直接光照" class="headerlink" title="2.1 第一步 ：光线投射 (Ray Casting) - 确定可见性与直接光照"></a>2.1 第一步 ：光线投射 (Ray Casting) - 确定可见性与直接光照</h3><blockquote>
<p> 这是整个算法的基础，目标是确定每个像素“看到”的是什么，并计算其从直接光源获得的光照。</p>
</blockquote>
<p><span style="color: #badc58; font-weight: 550;">1、投射主光线 (Primary Ray)：</span>从摄像机（或眼睛）出发，穿过成像平面上的<strong>每一个像素</strong>，向场景中发射一条主光线。</p>
<p><img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/20250715163612.png" alt="image.png"></p>
<p><span style="color: #badc58; font-weight: 550;">2、寻找最近交点：</span>一条光线可能会与场景中的多个物体相交，但我们只关心<strong>离摄像机最近的那个交点</strong>。这个点就是该像素最终在屏幕上可见的点。</p>
<p><span style="color: #badc58; font-weight: 550;">3、判断是否在阴影：</span>接着连接该交点和光源，只要判断这条连线之间是否有物体存在就可以知道该交点是否在阴影之中</p>
<p><img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/20250715163906.png" alt="image.png|625"></p>
<p><span style="color: #badc58; font-weight: 550;">4、计算局部光照 (Local Illumination)：</span>可以利用 Blinn-Phong 模型对这个最近点进行局部光照模型计算，得到该像素的颜色，那么遍历所有近投影平面上的像素就能得到一张完整的图像。</p>
<p>但如果光线追踪仅仅是在第一步 Ray Casting 就停止的话，那么它的效果与局部光照模型是一样的，因此我们需要第二步，真正的考虑全局效果</p>
<h3 id="2-2-第二步-：递归追踪-Recursive-Tracing-计算全局效果"><a href="#2-2-第二步-：递归追踪-Recursive-Tracing-计算全局效果" class="headerlink" title="2.2 第二步 ：递归追踪 (Recursive Tracing) - 计算全局效果"></a>2.2 第二步 ：递归追踪 (Recursive Tracing) - 计算全局效果</h3><blockquote>
<p> 这是 Whitted-Style 算法的精髓，它通过递归地追踪光线的后续路径来模拟全局光照效果。</p>
</blockquote>
<p><span style="color: #badc58; font-weight: 550;">1、生成次级光线 (Secondary Rays)：</span>当主光线击中物体表面后，算法并不会停止。根据物体材质的属性，它会生成新的“次级光线”：</p>
<ul>
<li>**反射光线 (Reflected Ray)**：如果表面是镜面或光滑的（如金属、玻璃），沿反射方向生成一条新的光线。</li>
<li>**折射光线 (Refracted Ray)**：如果表面是透明的（如玻璃、水），沿折射方向生成一条穿过物体的新光线。</li>
</ul>
<p><img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/20250715164727.png" alt="image.png|908"></p>
<p>将这些所有交点与光源连接，以于判断该点是否处于阴影之中</p>
<blockquote>
<p> 这些线被称为阴影光线 (shadow rays)</p>
</blockquote>
<p><img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/20250715165527.png" alt="image.png|905"></p>
<p><span style="color: #badc58; font-weight: 550;">2、递归过程：</span>这些新生成的反射/折射光线，本身又成为了新的“主光线”，被同样的方式进行追踪——寻找最近的交点，然后再次根据新交点处的材质生成再下一级的反射/折射光线。这个过程会像树状一样不断展开。</p>
<p>为了防止无限递归并控制计算量，追踪过程必须在以下几种情况下停止：</p>
<ul>
<li><strong>达到最大递归深度</strong>：例如，设定光线最多反弹 10 次。</li>
<li><strong>光线能量衰减</strong>：光线每反弹一次，其能量（对最终颜色的贡献）就会减弱。当能量低于某个阈值时，就停止追踪。</li>
<li><strong>光线未击中任何物体</strong>：光线飞出场景，击中了背景。</li>
<li><strong>光线击中了漫反射表面</strong>：如果物体表面不产生镜面反射或折射，则光线路径在此终止。</li>
</ul>
<p><span style="color: #badc58; font-weight: 550;">3、最终颜色的合成：</span>一个像素的最终颜色，不再仅仅是第一个交点的局部光照颜色。它是一个<strong>加权求和</strong>的结果，包含了整个光线追踪“树”上所有光照的贡献：</p>
<p><img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/20250715165710.png" alt="image.png"></p>
<ul>
<li>其中 $k_r$​ 和 $k_t$​ 分别是物体的反射和折射系数。</li>
</ul>
<h2 id="3-具体实现"><a href="#3-具体实现" class="headerlink" title="3 具体实现"></a>3 具体实现</h2><h3 id="3-1-光线的表示方法"><a href="#3-1-光线的表示方法" class="headerlink" title="3.1 光线的表示方法"></a>3.1 光线的表示方法</h3><p>我们可以将每一条光线想象成一条射线，那么每一条光线都会由起点及方向这两个属性所固定，如下图所示：</p>
<p><img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/20250715170336.png" alt="image.png|745"></p>
<p>除了起点 $o$, 以及方向 $d$ 之外，还额外定义了一个参数 t 来表示光线行进的长度。</p>
<h3 id="3-2-光线与物体求交的方法"><a href="#3-2-光线与物体求交的方法" class="headerlink" title="3.2 光线与物体求交的方法"></a>3.2 光线与物体求交的方法</h3><h4 id="3-2-1-光线与隐式曲面求交的方法"><a href="#3-2-1-光线与隐式曲面求交的方法" class="headerlink" title="3.2.1 光线与隐式曲面求交的方法"></a>3.2.1 光线与隐式曲面求交的方法</h4><p>首先介绍如何计算光线与隐式曲面的交点的方法，以一个球体为例，二者表示方程如下：</p>
<p><img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/20250715171302.png" alt="image.png"></p>
<p>光线的表示方法在上节已经介绍过，对于一个球体来说，其表面上所有点 $p$, 到圆心 $c$ 的距离是固定为 $R$ 的， 也就得到了上述的球的隐式曲面方程。</p>
<p><img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/20250715171327.png" alt="image.png"></p>
<p>那么对于一个光线会在什么时候与球相交呢？</p>
<p>当然是在一个点即满足光线方程，又满足球体方程的时候，所以可以把 $p = o + td$ 代入球体方程，利用一元二次方程的解法即可得到参数 $t$ 值</p>
<p><img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/20250715171504.png" alt="image.png|767"></p>
<p>同时根据 $b^2−4ac$ 的正负关系，即可判断光线与球是一个交点还是两个交点，或是没有交点</p>
<p>类似的，对于其他隐式曲面，只要将光线方程代入求解 t 即可，如下图所示</p>
<p><img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/20250715171705.png" alt="image.png|842"></p>
<h4 id="3-2-2-光线与显示曲面求交的方法"><a href="#3-2-2-光线与显示曲面求交的方法" class="headerlink" title="3.2.2 光线与显示曲面求交的方法"></a>3.2.2 光线与显示曲面求交的方法</h4><p>当然，真正在图形学中大量运用的其实是显示曲面，更具体来说就是许许多多个三角形，因此如何判断一条光线与显示曲面的交点，其实也就是计算光线与三角形面的交点。</p>
<p>首先，将三角形视为其所在的无限大平面的一部分。</p>
<p><img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/20250715172159.png" alt="image.png"></p>
<p><span style="color: #badc58; font-weight: 550;">平面方程的两种形式：</span></p>
<p><img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/20250715172255.png" alt="image.png|725"></p>
<ul>
<li><strong>向量形式</strong>: $(p−p′)⋅N=0$<br>从已知点 $p^{‘}$ 指向平面上任意点 $p$ 的向量 $(p−p′)$ 一定位于该平面内，因此它必然与法向量 $\vec{N}$ 垂直。两个相互垂直的向量，其点积（dot product）为零。</li>
<li><strong>通用形式</strong> (隐式方程): $ax+by+cz+d=0$<br>其中，系数 $(a,b,c)$ 正好就是法向量 N 的三个分量。</li>
</ul>
<p>推导过程：</p>
<p>令 $N=(a,b,c)$，$p=(x,y,z)$，$p′=(x′,y′,z′)$，故有</p>
<p>$$<br>(x−x′,y−y′,z−z′)⋅(a,b,c)=0<br>$$</p>
<p>根据点积的定义（对应分量相乘后求和），我们展开上式：</p>
<p>$$<br>a(x−x′)+b(y−y′)+c(z−z′)=0<br>$$</p>
<p>展开括号，将所有包含变量 $(x,y,z)$ 的项放在一起，所有<strong>常数项</strong>放在一起：</p>
<p>$$<br>(ax+by+cz)+(−ax′−by′−cz′)=0<br>$$</p>
<p><span style="color: #badc58; font-weight: 550;">光线与平面求交 (Ray Intersection With Plane)</span></p>
<p><img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/20250715174017.png" alt="image.png"></p>
<p>得到参数 $t$ 之后，自然可以计算出交点，并且<strong>再去计算出重心坐标就能判断该交点是否在三角形内</strong>了，但是这种方法略显繁琐，能不能一步就得到结果呢？当然可以！</p>
<p><span style="color: #badc58; font-weight: 550;">Möller-Trumbore 算法 (Möller-Trumbore Algorithm)</span></p>
<p>交点 $P$ 可以用光线起点 $o$、方向 $d$ 和参数 $t$ 来表示，也可以用三角形的三个顶点 $P_0​,P_1​,P_2$​ 和两个重心坐标参数 $b_1​,b_2​$ 来表示（第三个重心坐标是 $1−b_1​−b_2$​）：</p>
<p>令二者相等，可以得到如下一个等式：</p>
<p><img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/20250715174614.png" alt="image.png|661"></p>
<p>求解过程：</p>
<p><img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/20250715174726.png" alt="image.png|531"></p>
<h1 id="利用包围盒技术加速光线追踪"><a href="#利用包围盒技术加速光线追踪" class="headerlink" title="利用包围盒技术加速光线追踪"></a>利用包围盒技术加速光线追踪</h1><h2 id="1-轴对齐包围盒-Axis-Aligned-Bounding-Box"><a href="#1-轴对齐包围盒-Axis-Aligned-Bounding-Box" class="headerlink" title="1 轴对齐包围盒 (Axis-Aligned Bounding Box)"></a>1 轴对齐包围盒 (Axis-Aligned Bounding Box)</h2><h3 id="1-1-问题引入"><a href="#1-1-问题引入" class="headerlink" title="1.1 问题引入"></a>1.1 问题引入</h3><p>针对场景中的<strong>每一个三角形</strong>，都进行一次<strong>光线 - 三角形</strong>相交测试。完成所有测试后，找出最近的那个交点（即参数 <code>t</code> 值最小的那个点）。</p>
<p>这种朴素算法的计算量巨大，其复杂度约等于：</p>
<p><img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/20250715175037.png" alt="image.png"></p>
<p>这意味着，屏幕上的每个像素都需要投射一条主光线，而这条光线必须与场景中的所有三角形进行比较。如果使用递归光线追踪（例如为了实现反射或折射），每次反弹产生的新光线又会重复这个过程，导致计算量呈爆炸性增长。</p>
<p><span style="color: #badc58; font-weight: 550;">使用包围体加速计算 (Bounding Volumes)</span></p>
<ul>
<li>用一个几何形状简单的“包围体”（如长方体或球体）将复杂物体完全包裹起来。</li>
<li>光线首先与这个简单的包围体进行求交测试。</li>
<li><strong>如果光线没有击中包围体，那么它必然没有击中内部的复杂物体</strong>，可以直接忽略该物体，省去了大量的计算。</li>
<li>只有当光线击中包围体时，才需要进一步对内部的复杂物体进行精确的求交测试。</li>
</ul>
<p><img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/20250715175232.png" alt="image.png"></p>
<h3 id="1-2-轴对齐包围盒-AABB-及其求交算法"><a href="#1-2-轴对齐包围盒-AABB-及其求交算法" class="headerlink" title="1.2 轴对齐包围盒 (AABB) 及其求交算法"></a>1.2 轴对齐包围盒 (AABB) 及其求交算法</h3><blockquote>
<p> <strong>AABB (Axis-Aligned Bounding Box / 轴对齐包围盒)</strong> 是一种非常常用且计算高效的包围体。</p>
</blockquote>
<p><span style="color: #badc58; font-weight: 550;">AABB 的理解</span></p>
<ul>
<li>AABB 的所有面都与坐标系的 x, y, z 轴平行。</li>
<li>从几何上看，一个 AABB 可以被理解为<strong>三对互相垂直的、无限大的“厚板 (slabs)”</strong> 的相交区域。一对厚板沿 x 轴方向，一对沿 y 轴，一对沿 z 轴。</li>
</ul>
<p><img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/20250715175340.png" alt="image.png"></p>
<p><span style="color: #badc58; font-weight: 550;">光线与 AABB 的求交算法（Slab Test / 厚板测试法）</span></p>
<p>这个算法的核心思想是：<strong>光线要击中盒子，当且仅当光线穿过所有三个“厚板”的重叠区间。</strong></p>
<ol>
<li>只有当光线进入了所有的平面才算是真正进入了盒子中</li>
<li>只要当光线离开了任意平面就算是真正离开了盒子</li>
</ol>
<p><img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/20250715175428.png" alt="image.png"></p>
<p>这个算法的本质是在<strong>一维时间轴</strong>上寻找三个区间的<strong>交集</strong>：</p>
<ul>
<li>区间 1: <code>[t_min_x, t_max_x]</code></li>
<li>区间 2: <code>[t_min_y, t_max_y]</code></li>
<li>区间 3: <code>[t_min_z, t_max_z]</code></li>
</ul>
<p>这个交集的起始点，必然是所有起始点中最靠右（最大）的那个。 这个交集的终点，必然是所有终点中最靠左（最小）的那个。</p>
<p>下图以二维为例：</p>
<p><img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/20250715175604.png" alt="image.png|814"></p>
<p><span style="color: #badc58; font-weight: 550;">最终的相交判断条件：考虑光线的方向性</span></p>
<p>在 <code>t_enter &lt; t_exit</code> 的基础上，加入对 <strong>光线方向性</strong> 的考虑</p>
<p><img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/20250715175934.png" alt="image.png"></p>
<h3 id="1-3-为什么要用“轴对齐”？-Why-Axis-Aligned"><a href="#1-3-为什么要用“轴对齐”？-Why-Axis-Aligned" class="headerlink" title="1.3 为什么要用“轴对齐”？(Why Axis-Aligned?)"></a>1.3 为什么要用“轴对齐”？(Why Axis-Aligned?)</h3><p><img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/20250715180033.png" alt="image.png|796"></p>
<p>这张图解释了为什么 <code>AABB</code> 的求交测试<strong>计算速度极快</strong>，具体解释如下：</p>
<p><img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/20250715180109.png" alt="image.png"></p>
<p><span style="color: #badc58; font-weight: 550;">结论：</span>AABB 的“轴对 aligned”特性，使得其与光线的 6 次平面求交计算都简化到了极致，从而让整个算法非常高效。</p>
<h2 id="2-均匀空间划分-Uniform-Spatial-Partitions-Grids"><a href="#2-均匀空间划分-Uniform-Spatial-Partitions-Grids" class="headerlink" title="2 均匀空间划分 Uniform Spatial Partitions (Grids)"></a>2 均匀空间划分 Uniform Spatial Partitions (Grids)</h2><h3 id="2-1-引入"><a href="#2-1-引入" class="headerlink" title="2.1 引入"></a>2.1 引入</h3><p><strong>均匀空间划分</strong> (Uniform Spatial Partitioning) 是一种将一个大的空间（二维或三维）分割成<strong>无数个大小完全相同、形状规则的单元（Cell）</strong> 的技术。</p>
<p>最常见和最直观的例子就是<strong>网格（Grid）</strong>。</p>
<ul>
<li>在二维空间中，就是将一个平面划分成棋盘一样的方格。</li>
<li>在三维空间中，就是将一个立方体空间划分成无数个小立方体，我们称之为<strong>体素网格（Voxel Grid）</strong>。</li>
</ul>
<p>它的<strong>核心目的</strong>在于“缩小搜索范围”，从而极大地加速空间查询的速度。</p>
<p>想象一个游戏世界里有上千个物体。当你想知道某个物体 A 附近有哪些其他物体时（例如，用于碰撞检测），最笨的办法是让物体 A 和其余所有上千个物体都计算一遍距离。这非常耗时。</p>
<h3 id="2-2-工作原理"><a href="#2-2-工作原理" class="headerlink" title="2.2 工作原理"></a>2.2 工作原理</h3><p>第一步对所要考虑的场景找一个包围盒：</p>
<p><img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/20250716110032.png" alt="image.png"></p>
<p>第二步均匀划分这个大包围盒：</p>
<p><img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/20250716110042.png" alt="image.png"></p>
<p>第三步在每个重叠小包围盒上存储物体模型信息</p>
<p><img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/20250716110056.png" alt="image.png"></p>
<p>紧接着，根据光线的方向与判断出所有相交的方格 (这一步可以利用 bresenham 算法)，倘若方格中存储有物体，再进一步与方格中的物体模型或是三角形面求交。</p>
<p><img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/20250716110114.png" alt="image.png"></p>
<p>以上就是均匀空间划分的全部过程了，简单来说就是将空间划分为多个均匀的小的 AABB，再根据光线方向找出相交 grid(这一步并不需要判断所有方格，正如上文提示，可以用 brenham 类似的方法来做)，再判断 grid 中是否存储了模型信息，若有则进一步求交。</p>
<h3 id="2-3-网格划分尺度问题"><a href="#2-3-网格划分尺度问题" class="headerlink" title="2.3 网格划分尺度问题"></a>2.3 网格划分尺度问题</h3><p><img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/20250716110425.png" alt="image.png"></p>
<p><img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/20250716110433.png" alt="image.png"></p>
<p>这两张图说明了在使用均匀网格加速结构时，网格密度的选择至关重要。一个好的网格密度应该是在<strong>遍历成本</strong>和<strong>求交成本</strong>之间取得平衡。</p>
<p>为了在上述两种极端情况中找到一个平衡点，图片提出了一种经验法则，即<strong>启发式策略（Heuristic）</strong>，来自动确定一个合理的网格密度。</p>
<ul>
<li><strong>策略</strong>：让总的单元格数量（<code>#cells</code>）与场景中的物体数量（<code>#objs</code>）成正比。 <code>#cells = C * #objs</code></li>
<li><strong>经验值</strong>：在三维空间中，这个比例常数 <code>C</code> 的经验值大约是 <strong>27</strong>。</li>
</ul>
<h3 id="2-4-优缺点"><a href="#2-4-优缺点" class="headerlink" title="2.4 优缺点"></a>2.4 优缺点</h3><h4 id="2-4-1-优点-Pros"><a href="#2-4-1-优点-Pros" class="headerlink" title="2.4.1 优点 (Pros)"></a>2.4.1 优点 (Pros)</h4><ol>
<li><strong>定位速度极快</strong>：给定空间中的任意一个点 <code>(x, y)</code>，你只需要用它的坐标除以单元格的尺寸 <code>(x/cellSize, y/cellSize)</code>，就能立刻、瞬时地计算出它属于哪个网格单元。这比复杂的树状结构要快得多。</li>
<li><strong>邻居查找方便</strong>：计算一个单元格的相邻单元格也非常简单，只需对单元格索引进行加一或减一即可。</li>
<li><strong>对均匀分布的场景效果好</strong>：如果物体在空间中是均匀分布的（比如一片茂密的草地、一群飞鸟），这种划分方法的效率会非常高。</li>
</ol>
<p><img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/20250716110634.png" alt="image.png"></p>
<h4 id="2-4-2-缺点-Cons"><a href="#2-4-2-缺点-Cons" class="headerlink" title="2.4.2 缺点 (Cons)"></a>2.4.2 缺点 (Cons)</h4><ol>
<li>**“体育场中的茶壶”问题 (Teapot in a Stadium Problem)**： 这是均匀划分最致命的弱点。想象一个巨大的、空旷的体育场里，只在中心放了一个小茶壶。<ul>
<li>如果为了精确描述茶壶，把<strong>网格单元尺寸设得非常小</strong>，那么在广阔的空旷区域将会产生海量的、完全无用的空单元格，造成巨大的<strong>内存浪费</strong>。</li>
<li>如果为了节省内存，把<strong>网格单元尺寸设得非常大</strong>，那么体育场和茶壶可能都在同一个单元格里，这样网格就失去了“缩小搜索范围”的意义。</li>
</ul>
</li>
<li><strong>对非均匀分布的场景效率低下</strong>：对于物体密度差异巨大的场景（例如，城市中心建筑密集，而郊区空旷），它无法做到自适应调整，导致要么内存浪费，要么查询效率低下。</li>
<li><strong>单元格尺寸难以确定</strong>：网格的性能高度依赖于单元格尺寸的选择，而这个“最佳尺寸”往往很难确定，需要根据具体场景反复调试。</li>
</ol>
<p><img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/20250716110643.png" alt="image.png"></p>
<h2 id="3-KD-Tree-空间划分"><a href="#3-KD-Tree-空间划分" class="headerlink" title="3 KD-Tree 空间划分"></a>3 KD-Tree 空间划分</h2><h3 id="3-1-常用空间划分"><a href="#3-1-常用空间划分" class="headerlink" title="3.1 常用空间划分"></a>3.1 常用空间划分</h3><p>在具体介绍 KD-Tree 空间划分的方法之前，首先来看看一些常用的空间划分方法：</p>
<p><img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/20250716110749.png" alt="image.png"></p>
<ol>
<li><code>Oct-Tree</code>，也就是八叉树，每次将空间分为 8 个相等的部分，再递归的对子空间进行划分，因为图中是 2 维例子，所以只划分了 4 部分。当划分的子空间足够小或是空间中三角形面的数量很少的时候会停止划分。这种方法的显著缺点是，随着维度的上升划分的空间数量会呈指数级增长。</li>
<li><code>KD-Tree</code>，也是本小节将要主要介绍的方法，其每次将空间划分为两部分，且划分依次沿着 x-axis，y-axis，z-axis，即如图中所示，第一次横着将 2 维空间分为上下，第二次再竖着将上下两个子空间分别划分为左右部分，依次递归划分，终止条件与八叉树类似，细节问题之后按具体例子详解。</li>
<li><code>BSP-Tree</code>，其与 KD-Tree 类似，唯一不同的是划分不再沿着固定一轴，可以任意方向划分，缺点自然是划分的空间没有规则性，求交困难。</li>
</ol>
<h3 id="3-2-构建-KD-Tree"><a href="#3-2-构建-KD-Tree" class="headerlink" title="3.2 构建 KD-Tree"></a>3.2 构建 KD-Tree</h3><p>构建过程是一个自顶向下的递归过程：</p>
<ol>
<li><strong>选择划分轴</strong>：依次沿着 x-axis,y-axis,z-axis 划分，使得空间被划分的更加平衡</li>
<li><strong>选择划分位置</strong>：根据该空间内的物体（如三角形）的分布来确定一个最佳的划分位置。</li>
<li><strong>递归构建</strong>：将空间和物体集一分为二，生成两个子节点。然后对每个子节点，<strong>切换到下一个坐标轴</strong>（例如 y 轴），重复以上过程。</li>
<li><strong>终止条件</strong>：当一个节点内的空间太小，或者包含的物体数量足够少时，就停止划分，使其成为一个**叶子节点 (Leaf node)**。</li>
</ol>
<ul>
<li><strong>节点存储</strong>：<ul>
<li>**内部节点 (Internal node)**：只存储划分信息，如“沿 X 轴在 x=5.0 处划分”。</li>
<li>**叶子节点 (Leaf node)**：存储落入该空间区域内的所有物体。</li>
</ul>
</li>
</ul>
<p>下面通过一个例子感受一下：</p>
<p>第一步将空间分为两部分</p>
<p><img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/20250716110948.png" alt="image.png"></p>
<p>第二步对左右两个子空间换个方向再分为两部分</p>
<blockquote>
<p> 这里只画出了有半部分，其实左边也是一样</p>
</blockquote>
<p><img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/20250716111003.png" alt="image.png"></p>
<p>递归执行，最终可以得到</p>
<blockquote>
<p> 这里 1，2 内部也需要进行空间划分，只是没画出来</p>
</blockquote>
<p><img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/20250716111217.png" alt="image.png"></p>
<h3 id="3-3-利用-KD-Tree-判交"><a href="#3-3-利用-KD-Tree-判交" class="headerlink" title="3.3 利用 KD-Tree 判交"></a>3.3 利用 KD-Tree 判交</h3><p>当 KD-Tree 建立完成之后，如何进行光线与物体求交判断呢？过程如下： </p>
<ul>
<li><strong>从根节点开始</strong>：首先判断光线是否与整个场景的包围盒相交。</li>
<li><strong>递归遍历</strong>：<ul>
<li>如果当前节点是<strong>内部节点（代表一次划分）</strong>：判断光线会穿过哪个子空间（左边、右边，或两者都穿过），然后递归地进入相应的子节点进行遍历。</li>
<li>如果当前节点是<strong>叶子节点</strong>：则对该节点内存储的<strong>所有物体</strong>进行精确的光线求交测试。</li>
</ul>
</li>
</ul>
<p>如果算法判断出光线完全没有穿过某个节点所代表的空间区域，那么该节点下的<strong>整个分支（所有子孙节点和物体）都可以被完全忽略</strong>，从而极大地提升了计算效率。</p>
<p>下面通过一个例子感受一下：</p>
<p>第一步判断光线是否与最外层的包围盒相交</p>
<p><img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/20250716111858.png" alt="image.png"></p>
<p>如果相交进一步判断是否与对应的两个子空间相交</p>
<p><img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/20250716111921.png" alt="image.png|581"></p>
<blockquote>
<p> <strong>注意</strong>：因图中做了简化，最大包围盒的左半边并没继续进行划分 (实际上应该要划分的)，所以左半部分对应的 1 号空间是叶子节点</p>
</blockquote>
<p>如果光线与之相交，进一步判断与存储与叶子节点的物体信息求交。左半边判断完之后，接着判断右半部分</p>
<p><img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/20250716112135.png" alt="image.png|559"></p>
<p>同样如果对于有半部分存在相交情况，则对于右半部分的所有子空间，递归的执行这个步骤即可</p>
<p><img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/20250716112159.png" alt="image.png|538"></p>
<h3 id="3-4-优缺点"><a href="#3-4-优缺点" class="headerlink" title="3.4 优缺点"></a>3.4 优缺点</h3><ul>
<li>**优点 (Pro)**：<ul>
<li>主要的优点就是其高效的<strong>剪枝能力</strong>。通过跳过与光线不相干的大片空间，可以显著加速渲染和碰撞检测等过程。</li>
</ul>
</li>
<li>**缺点 (Con)**：<ul>
<li><strong>物体跨越边界问题</strong>：一个物体（如一个大的三角形）可能会被划分平面切割，导致它必须被同时存储在两个子节点的叶子节点中。这造成了数据冗余和管理复杂性。</li>
<li>判断包围盒与三角面的是否相交较难</li>
<li>构建过程相对复杂，需要找到合适的划分位置。</li>
</ul>
</li>
</ul>
<h2 id="4-BVH-Bounding-Volume-Hierarchy"><a href="#4-BVH-Bounding-Volume-Hierarchy" class="headerlink" title="4 BVH (Bounding Volume Hierarchy)"></a>4 BVH (Bounding Volume Hierarchy)</h2><h3 id="4-1-构建过程"><a href="#4-1-构建过程" class="headerlink" title="4.1 构建过程"></a>4.1 构建过程</h3><p>BVH 与前几种方法最显著的区别就是，<strong>不再以空间作为划分依据，而是从对象的角度考虑，即三角形面</strong></p>
<p>其<strong>核心思想</strong>是：将空间中邻近的物体用一个简单的、更大的几何体（即“包围盒”，Bounding Box）包裹起来，并以此构建一个树状的层级结构。</p>
<p>BVH 的构建是一个<strong>自顶向下</strong>的递归过程，主要步骤如下：</p>
<ol>
<li>**计算初始包围盒 (Find bounding box)**： 首先，为场景中所有的物体计算一个能将它们全部包裹住的最小包围盒。这个包围盒成为 BVH 树的根节点。<br><img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/20250716112617.png" alt="image.png|533"></li>
<li>**递归地划分物体集 (Recursively split set of objects)**： 将当前节点中的物体集合分成两个子集。划分的策略有很多种（例如，沿最长的轴将物体排序后从中间分开）。</li>
<li>**重新计算子集的包围盒 (Recompute the bounding box of the subsets)**： 为上一步中得到的两个子集分别计算新的、更紧密的包围盒。这两个新包围盒就构成了当前节点的子节点。<br><img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/20250716112656.png" alt="image.png"></li>
<li>**设置停止条件 (Stop when necessary)**： 重复执行第 2 步和第 3 步，直到满足某个预设的停止条件。例如，当一个节点中的物体数量少于某个阈值（比如只剩 1 个物体）时，就停止划分。</li>
<li>**在叶子节点中存储物体 (Store objects in each leaf node)**： 当递归停止时，该节点就成为一个“叶子节点”。场景中的实际物体（如图中的三角形）被存储在这些叶子节点中。<br><img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/20250716112707.png" alt="image.png"></li>
</ol>
<blockquote>
<p><strong>注意</strong>：这里为了画图方便，只进行了左半部分的划分，右半部分其实同理</p>
</blockquote>
<h3 id="4-2-BVH-解决的问题"><a href="#4-2-BVH-解决的问题" class="headerlink" title="4.2 BVH 解决的问题"></a>4.2 BVH 解决的问题</h3><p>BVH 与 KD-Tree 的根本区别在于其划分策略。BVH 采用的是<strong>物体划分</strong>，而非空间划分。</p>
<p>以 <strong>KD 树 (KD-tree)</strong> 为例：</p>
<p><img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/20250716113856.png" alt="image.png"></p>
<ul>
<li><strong>划分对象</strong>：直接对<strong>空间本身</strong>进行分割。</li>
<li><strong>核心特点</strong>：分割出的各个空间区域（如图中的蓝色和黄色区域）是<strong>互不重叠</strong>的。空间被干净地切分开了。</li>
<li><strong>带来的结果</strong>：由于空间是被强制分割的，一个完整的物体（如图中跨在分割线上的三角形）可能会被这个分割面“切开”，从而同时属于<strong>多个不同的空间区域</strong>。</li>
</ul>
<p>以 <strong>BVH (包围盒层次结构)</strong> 为例：</p>
<p><img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/20250716113911.png" alt="image.png"></p>
<ul>
<li><strong>划分对象</strong>：对<strong>物体的集合</strong>进行分组。</li>
<li><strong>核心特点</strong>：物体的分组是<strong>不相交</strong>的（disjoint），即任何一个物体都只属于唯一一个分组（如图中的蓝色三角形组和黄色三角形组）。</li>
<li><strong>带来的结果</strong>：虽然物体的分组是独立的，但包裹这些不同物体组的<strong>包围盒 (Bounding boxes) 在空间上却可能发生重叠</strong>。</li>
</ul>
<p>虽然 BVH 的<strong>包围盒在空间上可能重叠</strong>，但每个物体（如三角形面）都<strong>唯一地属于一个叶子节点</strong>。这完美地解决了 KD-Tree 的核心缺点——即一个物体可能被划分平面切割，导致需要被存储于多个叶子节点中，造成数据冗余。</p>
<h3 id="4-3-构建-BVH-的策略"><a href="#4-3-构建-BVH-的策略" class="headerlink" title="4.3 构建 BVH 的策略"></a>4.3 构建 BVH 的策略</h3><p>为了构建一棵高效、平衡的 BVH 树，通常采用以下一系列启发式策略：</p>
<ol>
<li><strong>选择划分轴</strong>：计算当前节点内所有物体共同形成的包围盒，并选择<strong>最长</strong>的那一根轴（X、Y 或 Z）作为本次的划分轴。这有助于最大化地分散物体。</li>
<li><strong>选择划分点</strong>：在选定的轴上，计算所有物体**重心的中位数 (Median)**。使用这个中位数作为划分点。<ul>
<li><strong>目的</strong>：这样做并非为了在空间上居中，而是为了确保划分后的两个子节点所包含的<strong>物体数量大致相等</strong>（各占 50%）。</li>
</ul>
</li>
<li><strong>递归构建</strong>：对划分出的两个子集递归地重复以上过程，直到满足终止条件。</li>
<li><strong>设置终止条件</strong>：当一个节点内的物体数量已经足够少时（例如，少于 5 个），就停止继续划分，使其成为一个<strong>叶子节点</strong>。</li>
</ol>
<h3 id="4-4-BVH-的数据结构-Data-Structure-for-BVHs"><a href="#4-4-BVH-的数据结构-Data-Structure-for-BVHs" class="headerlink" title="4.4 BVH 的数据结构 (Data Structure for BVHs)"></a>4.4 BVH 的数据结构 (Data Structure for BVHs)</h3><p><img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/20250716112707.png" alt="image.png"></p>
<p>一个 BVH 树由两种节点组成，它们共同构成了整个层次结构：</p>
<ul>
<li>**内部节点 (Internal nodes)**：<ul>
<li><strong>作用</strong>：代表场景中一群物体的集合，用于构建层级。</li>
<li><strong>存储内容</strong>：<ul>
<li>一个**包围盒 (Bounding box)**，该包围盒完全容纳其所有子节点中的全部物体。</li>
<li>指向两个**子节点的指针 (Pointers to child nodes)**。</li>
</ul>
</li>
</ul>
</li>
<li>**叶子节点 (Leaf nodes)**：<ul>
<li><strong>作用</strong>：代表层次结构的末端，实际存储物体。</li>
<li><strong>存储内容</strong>：<ul>
<li>一个**包围盒 (Bounding box)**，该包围盒仅容纳此节点内的物体。</li>
<li>一个**物体列表 (List of objects)**，包含具体的几何图元（如三角形）。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>核心思想</strong>：整个 BVH 树的任何一个节点，都代表了其下方整个子树中所有物体的集合。内部节点负责导航，叶子节点负责存储。</p>
<p>最后给出这样一个 BVH 加速结构遍历节点的伪代码参考：</p>
<p><img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/20250716113623.png" alt="image.png"></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://VernalScenery.github.io">Scenery</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://vernalscenery.github.io/2025/07/14/%E5%9B%BE%E5%BD%A2%E5%AD%A6/Games101/08_GAMES101_%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA_01/">https://vernalscenery.github.io/2025/07/14/%E5%9B%BE%E5%BD%A2%E5%AD%A6/Games101/08_GAMES101_%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA_01/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://VernalScenery.github.io" target="_blank">春和景明的记事本</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/GAMES101/">GAMES101</a></div><div class="post_share"><div class="social-share" data-image="/./img/1.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2025/07/17/%E5%9B%BE%E5%BD%A2%E5%AD%A6/Games101/08_GAMES101_%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA_02/" title="08_GAMES101_光线追踪_02"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">08_GAMES101_光线追踪_02</div></div></a></div><div class="next-post pull-right"><a href="/2025/07/11/%E5%9B%BE%E5%BD%A2%E5%AD%A6/Games101/02_GAMES101%E6%80%BB%E7%BB%93%E7%89%88_%E5%85%89%E6%A0%85%E5%8C%96/" title="02_GAMES101总结版_光栅化"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">02_GAMES101总结版_光栅化</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2025/06/26/%E5%9B%BE%E5%BD%A2%E5%AD%A6/Games101/02_GAMES101_%E5%90%91%E9%87%8F%E4%B8%8E%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/" title="02_GAMES101_向量与线性代数"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2025-06-26</div><div class="title">02_GAMES101_向量与线性代数</div></div></a></div><div><a href="/2025/06/26/%E5%9B%BE%E5%BD%A2%E5%AD%A6/Games101/01_GAMES101_%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E6%A6%82%E8%BF%B0/" title="01_GAMES101_计算机图形学概述"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2025-06-26</div><div class="title">01_GAMES101_计算机图形学概述</div></div></a></div><div><a href="/2025/07/10/%E5%9B%BE%E5%BD%A2%E5%AD%A6/Games101/01_GAMES101%E6%80%BB%E7%BB%93%E7%89%88_%E7%A9%BA%E9%97%B4%E5%8F%98%E6%8D%A2/" title="01_GAMES101总结版_空间变换"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2025-07-10</div><div class="title">01_GAMES101总结版_空间变换</div></div></a></div><div><a href="/2025/06/26/%E5%9B%BE%E5%BD%A2%E5%AD%A6/Games101/03_GAMES101_%E5%8F%98%E6%8D%A2(%E4%BA%8C%E7%BB%B4%E4%B8%8E%E4%B8%89%E7%BB%B4)/" title="03_GAMES101_变换(二维与三维)"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2025-06-26</div><div class="title">03_GAMES101_变换(二维与三维)</div></div></a></div><div><a href="/2025/07/11/%E5%9B%BE%E5%BD%A2%E5%AD%A6/Games101/02_GAMES101%E6%80%BB%E7%BB%93%E7%89%88_%E5%85%89%E6%A0%85%E5%8C%96/" title="02_GAMES101总结版_光栅化"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2025-07-11</div><div class="title">02_GAMES101总结版_光栅化</div></div></a></div><div><a href="/2025/07/01/%E5%9B%BE%E5%BD%A2%E5%AD%A6/Games101/06_GAMES101_%E7%9D%80%E8%89%B2/" title="06_GAMES101_着色"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2025-07-01</div><div class="title">06_GAMES101_着色</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/./img/1.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Scenery</div><div class="author-info__description">今天不想跑，所以才去跑</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">73</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">14</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/chjm0121" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="/1595718686@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Why-Ray-Tracing"><span class="toc-text">Why Ray Tracing?</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Whitted-Style-%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA%E7%AE%97%E6%B3%95"><span class="toc-text">Whitted-Style 光线追踪算法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E6%A0%B8%E5%BF%83%E6%80%9D%E6%83%B3"><span class="toc-text">1 核心思想</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E7%AE%97%E6%B3%95%E6%B5%81%E7%A8%8B"><span class="toc-text">2 算法流程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E7%AC%AC%E4%B8%80%E6%AD%A5-%EF%BC%9A%E5%85%89%E7%BA%BF%E6%8A%95%E5%B0%84-Ray-Casting-%E7%A1%AE%E5%AE%9A%E5%8F%AF%E8%A7%81%E6%80%A7%E4%B8%8E%E7%9B%B4%E6%8E%A5%E5%85%89%E7%85%A7"><span class="toc-text">2.1 第一步 ：光线投射 (Ray Casting) - 确定可见性与直接光照</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-%E7%AC%AC%E4%BA%8C%E6%AD%A5-%EF%BC%9A%E9%80%92%E5%BD%92%E8%BF%BD%E8%B8%AA-Recursive-Tracing-%E8%AE%A1%E7%AE%97%E5%85%A8%E5%B1%80%E6%95%88%E6%9E%9C"><span class="toc-text">2.2 第二步 ：递归追踪 (Recursive Tracing) - 计算全局效果</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0"><span class="toc-text">3 具体实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-%E5%85%89%E7%BA%BF%E7%9A%84%E8%A1%A8%E7%A4%BA%E6%96%B9%E6%B3%95"><span class="toc-text">3.1 光线的表示方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-%E5%85%89%E7%BA%BF%E4%B8%8E%E7%89%A9%E4%BD%93%E6%B1%82%E4%BA%A4%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-text">3.2 光线与物体求交的方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-1-%E5%85%89%E7%BA%BF%E4%B8%8E%E9%9A%90%E5%BC%8F%E6%9B%B2%E9%9D%A2%E6%B1%82%E4%BA%A4%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-text">3.2.1 光线与隐式曲面求交的方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-2-%E5%85%89%E7%BA%BF%E4%B8%8E%E6%98%BE%E7%A4%BA%E6%9B%B2%E9%9D%A2%E6%B1%82%E4%BA%A4%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-text">3.2.2 光线与显示曲面求交的方法</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%88%A9%E7%94%A8%E5%8C%85%E5%9B%B4%E7%9B%92%E6%8A%80%E6%9C%AF%E5%8A%A0%E9%80%9F%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA"><span class="toc-text">利用包围盒技术加速光线追踪</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E8%BD%B4%E5%AF%B9%E9%BD%90%E5%8C%85%E5%9B%B4%E7%9B%92-Axis-Aligned-Bounding-Box"><span class="toc-text">1 轴对齐包围盒 (Axis-Aligned Bounding Box)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-%E9%97%AE%E9%A2%98%E5%BC%95%E5%85%A5"><span class="toc-text">1.1 问题引入</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-%E8%BD%B4%E5%AF%B9%E9%BD%90%E5%8C%85%E5%9B%B4%E7%9B%92-AABB-%E5%8F%8A%E5%85%B6%E6%B1%82%E4%BA%A4%E7%AE%97%E6%B3%95"><span class="toc-text">1.2 轴对齐包围盒 (AABB) 及其求交算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%94%A8%E2%80%9C%E8%BD%B4%E5%AF%B9%E9%BD%90%E2%80%9D%EF%BC%9F-Why-Axis-Aligned"><span class="toc-text">1.3 为什么要用“轴对齐”？(Why Axis-Aligned?)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E5%9D%87%E5%8C%80%E7%A9%BA%E9%97%B4%E5%88%92%E5%88%86-Uniform-Spatial-Partitions-Grids"><span class="toc-text">2 均匀空间划分 Uniform Spatial Partitions (Grids)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E5%BC%95%E5%85%A5"><span class="toc-text">2.1 引入</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-text">2.2 工作原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-%E7%BD%91%E6%A0%BC%E5%88%92%E5%88%86%E5%B0%BA%E5%BA%A6%E9%97%AE%E9%A2%98"><span class="toc-text">2.3 网格划分尺度问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-text">2.4 优缺点</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-1-%E4%BC%98%E7%82%B9-Pros"><span class="toc-text">2.4.1 优点 (Pros)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-2-%E7%BC%BA%E7%82%B9-Cons"><span class="toc-text">2.4.2 缺点 (Cons)</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-KD-Tree-%E7%A9%BA%E9%97%B4%E5%88%92%E5%88%86"><span class="toc-text">3 KD-Tree 空间划分</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-%E5%B8%B8%E7%94%A8%E7%A9%BA%E9%97%B4%E5%88%92%E5%88%86"><span class="toc-text">3.1 常用空间划分</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-%E6%9E%84%E5%BB%BA-KD-Tree"><span class="toc-text">3.2 构建 KD-Tree</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-%E5%88%A9%E7%94%A8-KD-Tree-%E5%88%A4%E4%BA%A4"><span class="toc-text">3.3 利用 KD-Tree 判交</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-text">3.4 优缺点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-BVH-Bounding-Volume-Hierarchy"><span class="toc-text">4 BVH (Bounding Volume Hierarchy)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-%E6%9E%84%E5%BB%BA%E8%BF%87%E7%A8%8B"><span class="toc-text">4.1 构建过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-BVH-%E8%A7%A3%E5%86%B3%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-text">4.2 BVH 解决的问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-%E6%9E%84%E5%BB%BA-BVH-%E7%9A%84%E7%AD%96%E7%95%A5"><span class="toc-text">4.3 构建 BVH 的策略</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-4-BVH-%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-Data-Structure-for-BVHs"><span class="toc-text">4.4 BVH 的数据结构 (Data Structure for BVHs)</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/07/29/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E5%9F%BA%E7%A1%80%E5%8E%9F%E7%90%86/13_%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0_%E6%A6%82%E7%8E%87%E5%9B%BE%E6%A8%A1%E5%9E%8B/" title="13_机器学习_概率图模型">13_机器学习_概率图模型</a><time datetime="2025-07-29T00:29:02.000Z" title="发表于 2025-07-29 08:29:02">2025-07-29</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/07/28/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E5%9F%BA%E7%A1%80%E5%8E%9F%E7%90%86/11_%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0_%E8%81%9A%E7%B1%BB/" title="11_机器学习_聚类">11_机器学习_聚类</a><time datetime="2025-07-28T00:19:53.000Z" title="发表于 2025-07-28 08:19:53">2025-07-28</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/07/28/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E5%9F%BA%E7%A1%80%E5%8E%9F%E7%90%86/12_%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0_%E9%99%8D%E7%BB%B4/" title="12_机器学习_降维">12_机器学习_降维</a><time datetime="2025-07-27T20:48:42.000Z" title="发表于 2025-07-28 04:48:42">2025-07-28</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/07/26/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E5%9F%BA%E7%A1%80%E5%8E%9F%E7%90%86/10_%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0_%E9%9B%86%E6%88%90%E5%AD%A6%E4%B9%A0/" title="10_机器学习_集成学习">10_机器学习_集成学习</a><time datetime="2025-07-26T01:58:53.000Z" title="发表于 2025-07-26 09:58:53">2025-07-26</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/07/25/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E5%9F%BA%E7%A1%80%E5%8E%9F%E7%90%86/09_%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0_%E6%9C%B4%E7%B4%A0%E8%B4%9D%E5%8F%B6%E6%96%AF/" title="09_机器学习_朴素贝叶斯">09_机器学习_朴素贝叶斯</a><time datetime="2025-07-25T03:08:47.000Z" title="发表于 2025-07-25 11:08:47">2025-07-25</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('/./img/1.jpg')"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2025 By Scenery</div><div class="footer_custom_text"><div>波澜不惊</div><div class="footer-div"><img class="footer-icon" src="./img/备案图标.png"><a class="footer-a" target="_blank" rel="noopener" href="http://beian.miit.gov.cn/">皖ICP备2021016944号-1</a></div></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.13.0"></script><script src="/js/main.js?v=4.13.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@5.2.0/instantpage.min.js" type="module"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=4.13.0"></script></div></div></body></html>