<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>06_GAMES101_着色 | 春和景明的记事本</title><meta name="author" content="Scenery"><meta name="copyright" content="Scenery"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="着色 (Shading) 的定义  词典里的 Shading：平面、手动 的填色 &amp;#x2F; 加阴影（比如手绘插画里的阴影线 ）。 图形学课程里的 Shading：3D、自动 的材质与光影计算（比如游戏里金属盔甲的反光、布料的柔和阴影 ）。  着色模型1 冯氏光照模型  环境光 (Ambient) 漫反射"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://vernalscenery.github.io/2025/07/01/%E5%9B%BE%E5%BD%A2%E5%AD%A6/Games101/06_GAMES101_%E7%9D%80%E8%89%B2/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=4.13.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '06_GAMES101_着色',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2025-08-05 14:17:12'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><link rel="stylesheet" href="/css/style.css"><meta name="generator" content="Hexo 5.4.2"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/./img/1.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">73</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">14</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/./img/1.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="春和景明的记事本"><span class="site-name">春和景明的记事本</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">06_GAMES101_着色</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-06-30T18:08:20.000Z" title="发表于 2025-07-01 02:08:20">2025-07-01</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-08-05T06:17:12.000Z" title="更新于 2025-08-05 14:17:12">2025-08-05</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">12.6k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>40分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="06_GAMES101_着色"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="着色-Shading-的定义"><a href="#着色-Shading-的定义" class="headerlink" title="着色 (Shading) 的定义"></a>着色 (Shading) 的定义</h1><p><img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/20250701151336.png" alt="image.png|495"></p>
<ul>
<li>词典里的 Shading：<strong>平面、手动</strong> 的填色 / 加阴影（比如手绘插画里的阴影线 ）。</li>
<li>图形学课程里的 Shading：<strong>3D、自动</strong> 的材质与光影计算（比如游戏里金属盔甲的反光、布料的柔和阴影 ）。</li>
</ul>
<h1 id="着色模型"><a href="#着色模型" class="headerlink" title="着色模型"></a>着色模型</h1><h2 id="1-冯氏光照模型"><a href="#1-冯氏光照模型" class="headerlink" title="1 冯氏光照模型"></a>1 冯氏光照模型</h2><p><img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/20250701151530.png" alt="image.png"></p>
<ul>
<li>环境光 (Ambient)</li>
<li>漫反射 (Diffuse) <ul>
<li>平行光</li>
<li>点光源</li>
</ul>
</li>
<li>镜面高光 (Specular)</li>
</ul>
<h2 id="2-Shading-is-Local"><a href="#2-Shading-is-Local" class="headerlink" title="2 Shading is Local"></a>2 Shading is Local</h2><p>计算物体表面某一点的颜色时，<strong>只关注该点的局部信息</strong>（比如该点的法向量、光照方向等 ），不考虑场景中其他物体的影响（比如远处物体的反射、阴影 ）</p>
<p><img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/20250701151749.png" alt="image.png"></p>
<p>要计算反射光，需要以下局部信息：</p>
<ul>
<li><strong>Viewer direction, v</strong>（观察方向）：摄像机（观察者）看向 “着色点” 的方向向量。</li>
<li><strong>Surface normal, n</strong>（表面法向量）：着色点处物体表面的法线方向（垂直于表面的向量 ），决定了表面的朝向。</li>
<li><strong>Light direction, l</strong>（光照方向）：每个光源照射到 “着色点” 的方向向量（场景有多个光源时，每个都要算 ）。</li>
<li><strong>Surface parameters</strong>（表面参数）：物体表面的材质属性，比如颜色（color）、光泽度（shininess，影响高光）、粗糙度等。</li>
</ul>
<p><span style="color: #badc58; font-weight: 550;">Shading vs Shadow</span></p>
<p><img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/20250701151908.png" alt="image.png"></p>
<ul>
<li><strong>Shading（着色）</strong>：模拟 “物体表面某一点” 因光照反射呈现的颜色 / 明暗，是<strong>局部计算</strong>（只看该点 ）。</li>
<li><strong>Shadow（阴影）</strong>：模拟 “物体遮挡光线，在其他表面产生的暗区”，是<strong>全局计算</strong>（要看场景中物体的相互位置、光线传播 ）。</li>
</ul>
<h2 id="3-漫反射-Diffuse-Reflection"><a href="#3-漫反射-Diffuse-Reflection" class="headerlink" title="3 漫反射 (Diffuse Reflection)"></a>3 漫反射 (Diffuse Reflection)</h2><h3 id="3-1-概览"><a href="#3-1-概览" class="headerlink" title="3.1 概览"></a>3.1 概览</h3><p>光线被表面散射后，会 “均匀分布在所有方向”。比如红色入射光线（图中红箭头）打在表面，会向蓝色箭头指示的各个方向散开，没有明显的集中反射。</p>
<p><img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/20250701152041.png" alt="image.png"></p>
<p>由于光线均匀散射，<strong>从任何观察角度看，物体表面的颜色都基本一致</strong> 。不像镜面反射（高光），角度变了颜色 / 亮度会明显变化；漫反射的颜色更稳定，比如墙面、哑光塑料，无论从哪个方向看，颜色都差不多。</p>
<h3 id="3-2-参数定义"><a href="#3-2-参数定义" class="headerlink" title="3.2 参数定义"></a>3.2 参数定义</h3><h4 id="3-2-1-着色点实际接收的光能量"><a href="#3-2-1-着色点实际接收的光能量" class="headerlink" title="3.2.1 着色点实际接收的光能量"></a>3.2.1 着色点实际接收的光能量</h4><p>物体表面接收的光能量，与表面法线和光照方向夹角的<strong>余弦值</strong>成<strong>正比</strong> 。</p>
<p><img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/20250701152341.png" alt="image.png"></p>
<h4 id="3-2-2-光线衰减"><a href="#3-2-2-光线衰减" class="headerlink" title="3.2.2 光线衰减"></a>3.2.2 光线衰减</h4><p>光线衰减 指 “光线强度随传播距离增加而减弱” 的现象，常见于点光源（如灯泡、太阳近似点光源时 ）。</p>
<p>下图中：</p>
<ul>
<li>中心是<strong>点光源</strong>，向外发射光线。</li>
<li>黄色圆环代表 “等距球面”：距离光源 r 处的球面，面积是 $4πr^2$（球面面积公式 ）。</li>
</ul>
<p><img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/20250701152443.png" alt="image.png"></p>
<ul>
<li>距离光源 “1 单位” 处（内圈），光线强度为 I → 单位面积分到的能量是 $I/(4π×1^2)$。</li>
<li>距离光源 “r 单位” 处（外圈），光线散布在更大的球面（面积 $4π×r^2$ ）→ 单位面积分到的能量是 $I/(4π×r^2)$→ 即 <strong>强度与距离平方成反比</strong>，记为 $(1/r^2)$</li>
</ul>
<p>简单说：<strong>光线越远越弱，且减弱的速度和距离的平方成反比</strong> —— 这就是点光源衰减的核心规律，让渲染更贴近现实（比如离路灯越远，光照越暗 ）</p>
<h3 id="3-3-漫反射光照公式"><a href="#3-3-漫反射光照公式" class="headerlink" title="3.3 漫反射光照公式"></a>3.3 漫反射光照公式</h3><p><img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/20250701153231.png" alt="image.png"></p>
<p>$$<br>L_d = k_d \left( \frac{I}{r^2} \right) \max(0, \mathbf{n} \cdot \mathbf{l})<br>$$</p>
<ul>
<li><strong>$L_d$​</strong>：最终漫反射的光亮度（即着色结果，决定像素颜色 ）。</li>
<li>$k_d​$（diffuse coefficient (color)）：<strong>漫反射系数</strong>（物体表面的基础颜色，比如红色墙面的 $k_d$​ 就是红色 ）。</li>
<li>$\frac{I}{r^2}$（energy arrived at the shading point）：<strong>到达着色点的光能量</strong>。<ul>
<li>$I$ 是光源初始强度；</li>
<li>$r$ 是着色点到光源的距离；</li>
<li>$r^2$​ 体现 “光线衰减”（平方反比定律 ）。</li>
</ul>
</li>
<li>$\max(0, \mathbf{n} \cdot \mathbf{l})$（energy received by the shading point）：<strong>着色点实际接收的光能量</strong>。<ul>
<li>n⋅l=cosθ（法向量与光照方向的点积，即朗伯余弦定律 ）；</li>
<li>max(0,…) 确保点积为负时（光线从背面照来 ），贡献为 0（避免负光强 ）。</li>
</ul>
</li>
</ul>
<p><img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/20250701154557.png" alt="image.png"></p>
<ul>
<li>漫反射系数 $k_d$​：控制物体表面的 “基础颜色亮度”（也可理解为对漫反射光的反射能力 ）。</li>
<li>从左到右，$k_d$​ 逐渐增大 → 球体整体亮度逐渐提高（更亮 ）。</li>
</ul>
<h3 id="3-4-对不同光源类型的适用性"><a href="#3-4-对不同光源类型的适用性" class="headerlink" title="3.4 对不同光源类型的适用性"></a>3.4 对不同光源类型的适用性</h3><ul>
<li><strong>点光源</strong>：对于点光源，光向四周各个方向均匀辐射，光强随距离平方衰减，图中公式中包含了距离平方反比衰减项 $\frac{I}{r^2}$， 因此可以很好地用于计算点光源照射下物体表面的漫反射光强。</li>
<li><strong>其他光源</strong>：在实际应用中，朗伯漫反射模型也可以经过适当调整后用于其他类型的光源， 比如平行光（如太阳光），可以认为是距离无穷远的光源，此时不需要考虑距离平方衰减（因为在一定范围内光强近似不变，即 r 视为常量 ），可以将公式简化，只保留 $L_d = k_d I \max(0, \mathbf{n} \cdot \mathbf{l})$ 部分来计算漫反射光强 。</li>
</ul>
<p><span style="color: #badc58; font-weight: 550;">点光源 vs 平行光</span></p>
<ol>
<li><strong>点光源</strong>的光线方向是从顶点指向光源位置，因此与顶点位置有关<br><img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/20250401091246.png" alt="image.png"></li>
<li><strong>平行光</strong>的光线方向由一个全局方向向量定义，与顶点位置无关</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 点光源: 光线方向随顶点位置变化</span></span><br><span class="line">vec3 lightDirection = <span class="title function_">normalize</span>(u_LightPosition - v_Position);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 平行光: 光线方向全局统一</span></span><br><span class="line">vec3 lightDirection = <span class="title function_">normalize</span>(-u_LightDirection); <span class="comment">// 注意这里是负的方向向量</span></span><br></pre></td></tr></table></figure>

<h2 id="4-镜面高光-Specular"><a href="#4-镜面高光-Specular" class="headerlink" title="4 镜面高光 (Specular)"></a>4 镜面高光 (Specular)</h2><p>当观察方向 <code>v</code> 接近 “镜面反射方向 <code>R</code>” 时，高光最亮</p>
<p><img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/20250701154851.png" alt="image.png"></p>
<p>因为这里镜面反射方向 <code>R</code> 不太好算，故引入了半程向量的概念。</p>
<ul>
<li>半程向量是光源方向 (<code>l</code>) 与视线方向 (<code>v</code>) 的<strong>单位平均向量</strong>。</li>
<li>“观察方向 <code>v</code> 越接近<strong>镜面反射方向</strong>，半程向量 <code>h</code> 就越靠近**表面法向量 <code>n</code>**”</li>
</ul>
<p><img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/20250701155142.png" alt="image.png"></p>
<ul>
<li>$k_s$​：高光系数（控制高光 “基础强度”，比如金属高光强、塑料弱 ）。</li>
<li>$\frac{I}{r^2}$：光照衰减项（I 是光源强度，r 是物体到光源距离，模拟现实中光的距离衰减 ）。</li>
<li>$\max(0, \mathbf{n} \cdot \mathbf{h})^p$：核心高光控制。<br><code>n⋅h</code> 小于 0 时无高光（表面背向光线 / 观察方向，物理上不会有高光）；<br><code>p</code> 是 “高光指数”，控制高光<strong>集中程度</strong>（<code>p</code> 越大，高光越尖锐、集中；越小则高光越柔和、分散 ）。</li>
</ul>
<p><code>p</code> 模拟了<strong>表面光滑度</strong>：<code>p</code> 越小 → 表面越 “粗糙”，高光分散；<code>p</code> 越大 → 表面越 “光滑”，高光集中。</p>
<p><img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/20250701155636.png" alt="image.png"></p>
<p>各参数影响效果如下：</p>
<p><img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/20250701155706.png" alt="image.png"></p>
<h2 id="5-环境光-Ambient"><a href="#5-环境光-Ambient" class="headerlink" title="5 环境光 (Ambient)"></a>5 环境光 (Ambient)</h2><p><img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/20250401083120.png" alt="image.png"></p>
<p> <strong>环境光着色不依赖任何特定条件</strong>（比如光源方向、观察方向、物体位置等 ）。现实中，环境光可理解为光线经多次反射后，弥漫在整个空间的 “基础光”，所以模型里简化成 “全局恒定” 的计算。</p>
<p><img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/20250701155951.png" alt="image.png"></p>
<p>$$<br>L_a = k_a \cdot I_a<br>$$</p>
<ul>
<li>$L_a$​：物体表面反射的<strong>环境光亮度</strong>（最终加到着色结果里的环境光贡献 ）。</li>
<li>$k_a$​：<strong>环境光系数</strong>（控制物体对环境光的反射能力，类似材质属性，比如黑色物体 $k_a$​ 小，白色物体 $k_a$​ 大 ）。</li>
<li>$I_a$​：<strong>环境光强度</strong>（场景里环境光的基础亮度，全局统一设定 ）。</li>
</ul>
<h2 id="6-三项叠加"><a href="#6-三项叠加" class="headerlink" title="6 三项叠加"></a>6 三项叠加</h2><p><img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/20250701160323.png" alt="image.png"></p>
<h1 id="着色频率-Shading-Frequencies"><a href="#着色频率-Shading-Frequencies" class="headerlink" title="着色频率 (Shading Frequencies)"></a>着色频率 (Shading Frequencies)</h1><p>着色频率指 “多久计算一次着色（Shading）”</p>
<p> 即 3D 模型表面的每个点 / 面，在渲染时多久更新一次光照、颜色等计算。</p>
<h2 id="1-三种方案"><a href="#1-三种方案" class="headerlink" title="1 三种方案"></a>1 三种方案</h2><p><img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/20250701162617.png" alt="image.png"></p>
<ul>
<li><strong>左球：逐面着色（Per - Face Shading）</strong><ul>
<li>针对每一个面定义一个法线，三角形面<strong>共用一个法向量（normal vector）</strong> 计算光照。</li>
<li>模型表面被分成<strong>多个多边形面</strong>，<strong>每个面统一着色</strong>（一个面内颜色 / 明暗无变化 ）。</li>
</ul>
</li>
<li><strong>中球：逐顶点着色（Per - Vertex Shading）</strong><ul>
<li>针对每一个顶点定义一个法线，模型的每个顶点先计算好颜色 / 明暗，再在三角形面内，让相邻顶点的颜色 “渐变过渡”，即对颜色进行插值。</li>
<li>基于<strong>模型顶点</strong>计算着色，顶点间的颜色 / 明暗用<strong>插值</strong>填充。</li>
</ul>
</li>
<li><strong>右球：逐像素着色（Per - Pixel Shading）</strong><ul>
<li>特点：基于<strong>屏幕像素</strong>计算着色，<strong>每个像素都单独算光照、明暗</strong> 。  </li>
<li>针对每一个顶点定义一个法线，然后在三角形内，对<strong>顶点法向量</strong>进行插值，再逐像素独立计算光照。</li>
</ul>
</li>
</ul>
<blockquote>
<p> 注：利用重心坐标对三角形内部插值，见下面章节</p>
</blockquote>
<p><img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/20250701163938.png" alt="image.png"></p>
<ul>
<li>模型内部细分数足够时，逐面着色效果也是可以的</li>
</ul>
<h2 id="2-法线计算"><a href="#2-法线计算" class="headerlink" title="2 法线计算"></a>2 法线计算</h2><h3 id="2-1-平面法线计算"><a href="#2-1-平面法线计算" class="headerlink" title="2.1 平面法线计算"></a>2.1 平面法线计算</h3><p><img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/20250701164344.png" alt="image.png"></p>
<h3 id="2-2-顶点法线计算"><a href="#2-2-顶点法线计算" class="headerlink" title="2.2 顶点法线计算"></a>2.2 顶点法线计算</h3><p><img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/20250701164403.png" alt="image.png"></p>
<p>在定义逐顶点法向量时，<strong>加权平均通常比算术平均更合理</strong>。</p>
<p>加权平均可引入权重（如按面面积、与顶点夹角大小等），使法向量更贴近局部几何特征，尤其在面大小差异大或曲率变化明显的模型中，能减少平滑过渡时的 artifacts（如 “过度平滑” 或 “棱角残留”），提升着色精度。</p>
<p>$$<br>\mathbf{N}<em>v = \frac{\sum</em>{i=1}^{n} \text{Area}(F_i) \mathbf{N}<em>i}{\left| \sum</em>{i=1}^{n} \text{Area}(F_i) \mathbf{N}_i \right|}<br>$$</p>
<p><img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/20250701164625.png" alt="image.png"></p>
<h3 id="2-3-逐像素法向量"><a href="#2-3-逐像素法向量" class="headerlink" title="2.3 逐像素法向量"></a>2.3 逐像素法向量</h3><p><img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/20250701165151.png" alt="image.png"></p>
<ul>
<li><strong>顶点法向量</strong>：图中两个黑色圆点是三角形的顶点，每个顶点有自己的法向量（向上的箭头 ）。</li>
<li><strong>像素法向量推导</strong>：三角形内的每个像素（或采样点 ），根据其在三角形内的<strong>重心坐标</strong>，对顶点法向量进行插值。<ul>
<li>重心坐标决定了像素受每个顶点法向量的 “影响权重” → 越靠近某个顶点，该顶点法向量的权重越大。</li>
<li>图示中，中间的法向量接近垂直（受左右顶点法向量的均衡影响 ），两侧的法向量逐渐向顶点法向量 “靠拢”，模拟光滑表面的法向量过渡。</li>
</ul>
</li>
</ul>
<blockquote>
<p> 注：利用重心坐标对三角形内部插值，见下面的章节</p>
</blockquote>
<p>在 shader 中，顶点着色器接收顶点法向量，经<strong>光栅化阶段的重心插值</strong>后传递给片元着色器，最终为每个片元（像素）生成独立法向量。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">``</span><span class="string">`js</span></span><br><span class="line"><span class="string">  // 顶点着色器</span></span><br><span class="line"><span class="string">  const VERTEX_SHADER_SOURCE = /* glsl */ `</span></span><br><span class="line">    uniform mat4 u_MvpMatrix;</span><br><span class="line"></span><br><span class="line">    attribute vec3 a_Position;</span><br><span class="line">    attribute vec4 a_Color;</span><br><span class="line">    attribute vec3 a_Normal;</span><br><span class="line"></span><br><span class="line">    varying vec3 v_Normal;  <span class="comment">// 传递给片元着色器的法向量</span></span><br><span class="line">    varying vec4 v_Color;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">main</span>(<span class="params"></span>) &#123;</span><br><span class="line">      gl_Position = u_MvpMatrix * <span class="title function_">vec4</span>(a_Position, <span class="number">1</span>);</span><br><span class="line">      v_Normal = a_Normal;</span><br><span class="line">      v_Color = a_Color;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="string">`</span></span><br><span class="line"><span class="string">  // 片元着色器</span></span><br><span class="line"><span class="string">  const FRAGMENT_SHADER_SOURCE = /* glsl */ `</span></span><br><span class="line">    precision mediump float;</span><br><span class="line">    varying vec4 v_Color;</span><br><span class="line">    varying vec3 v_Normal; <span class="comment">// 片元法向量</span></span><br><span class="line"></span><br><span class="line">    uniform vec3 u_LightColor;   <span class="comment">// 光源颜色</span></span><br><span class="line">    uniform vec3 u_LightPosition; <span class="comment">// 平行光光源位置</span></span><br><span class="line"></span><br><span class="line">    uniform float u_AmbientFactor; <span class="comment">// 环境光强度因子</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">main</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="comment">// 环境光分量</span></span><br><span class="line">      vec3 ambient = u_AmbientFactor * u_LightColor;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 光源照射方向向量</span></span><br><span class="line">      vec3 lightDirection = u_LightPosition - <span class="title function_">vec3</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">      <span class="comment">// 漫反射因子  两个方向向量点乘得到的是cos值， cos和入射角成反比</span></span><br><span class="line">      float diffuseFactor = <span class="title function_">dot</span>(<span class="title function_">normalize</span>(lightDirection), <span class="title function_">normalize</span>(v_Normal));</span><br><span class="line">      <span class="comment">// 如果是负数，说明光线与法向量夹角大于 90 度，此时照不到平面上，所以没有光照，即黑色。</span></span><br><span class="line">      diffuseFactor = <span class="title function_">max</span>(diffuseFactor, <span class="number">0.0</span>);</span><br><span class="line">      <span class="comment">// 漫反射光照 = 光源颜色 * 漫反射因子。</span></span><br><span class="line">      vec3 diffuseLightColor = u_LightColor * diffuseFactor;</span><br><span class="line">      gl_FragColor = v_Color * <span class="title function_">vec4</span>((ambient + diffuseLightColor), <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">  <span class="string">`</span></span><br></pre></td></tr></table></figure>

<h3 id="2-4-模型变换对法线向量的影响"><a href="#2-4-模型变换对法线向量的影响" class="headerlink" title="2.4 模型变换对法线向量的影响"></a>2.4 模型变换对法线向量的影响</h3><p><strong>法线向量需变换的原因</strong>：模型变换会导致其位置和形状改变，若三角形面的法线向量不随之调整，所记录的法线向量就会出错，因此法线向量必须跟随模型一起变换。</p>
<p>在 3D 渲染中，物体的每个顶点都会被 <strong>模型矩阵（Model Matrix）</strong> 变换，以完成<strong>平移、旋转、缩放</strong>等操作：</p>
<p><img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/20250401090747.png" alt="image.png"></p>
<p>但是，<strong>法线不能直接用相同的模型矩阵变换！</strong> </p>
<ul>
<li><strong>平移（Translation）</strong> ✅ 不影响方向，可忽略</li>
<li><strong>旋转（Rotation）</strong> ✅ 可直接作用在法线向量上</li>
<li><strong>缩放（Scaling）</strong> ⚠️ 影响方向，不能直接作用！</li>
</ul>
<p><img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/20250401090824.png" alt="image.png"></p>
<p>数学上，<strong>正确的法线变换矩阵是</strong> <strong>模型矩阵的逆转置矩阵</strong>（Normal Matrix）：</p>
<p><img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/20250401090841.png" alt="image.png"></p>
<p><span style="color: #badc58; font-weight: 550;">下面通过一个例子进行推导</span></p>
<p>一个简单矩形经过一个<strong>剪切变换 M</strong> 之后：</p>
<p><img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/20250702152959.png" alt="image.png"></p>
<p>给矩形做<strong>剪切变换 M</strong>后，矩形右边的切线向量 t 变成 Mt，可法线向量 n 要是直接用 M・n 变换（得到 Mn），根本不垂直变换后的面！</p>
<p>这说明：法线变换不能直接用模型的变换矩阵 M，得找<strong>专门的法线变换矩阵</strong>。</p>
<p><img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/20250702153937.png" alt="image.png"></p>
<h1 id="图形管线"><a href="#图形管线" class="headerlink" title="图形管线"></a>图形管线</h1><p><img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/20250701172532.png" alt="image.png"></p>
<p><span style="color: #badc58; font-weight: 550;">Model , View, Projection transforms</span></p>
<p><img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/20250701172836.png" alt="image.png"></p>
<p><span style="color: #badc58; font-weight: 550;">Sampling triangle coverage</span></p>
<p><img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/20250701172845.png" alt="image.png"></p>
<p><span style="color: #badc58; font-weight: 550;">Z -Buffer Visibility Tests</span></p>
<p><img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/20250701172905.png" alt="image.png"></p>
<p><span style="color: #badc58; font-weight: 550;">Shading</span></p>
<p><img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/20250701172919.png" alt="image.png"></p>
<p><span style="color: #badc58; font-weight: 550;">Texture mapping</span></p>
<p><img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/20250701172934.png" alt="image.png"></p>
<h1 id="纹理映射-Texture-Mapping"><a href="#纹理映射-Texture-Mapping" class="headerlink" title="纹理映射 (Texture Mapping)"></a>纹理映射 (Texture Mapping)</h1><h2 id="1-概览"><a href="#1-概览" class="headerlink" title="1 概览"></a>1 概览</h2><p>3D 模型由很多小三角形（多边形）组成，<strong>每个三角形会从 2D 纹理图里 “取” 对应的一块图案，贴在自己表面</strong>，让原本单调的 3D 形状，变成有颜色、细节的逼真效果，这就是纹理应用到表面的过程</p>
<p><img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/20250702095621.png" alt="image.png"></p>
<p>3D 模型（比如左边的头部）是由很多三角形面组成的，<strong>每个三角形的顶点，都会被分配一组（u, v）坐标</strong> ，这组坐标对应右侧 2D 纹理空间里的位置。</p>
<p><img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/20250702095700.png" alt="image.png"></p>
<p>横轴和纵轴的最大值都为 1，为什么整幅 <code>texture</code> 图可视化之后是红色和绿色呢？可以将 <code>(u,v)</code> 坐标的两点想象成 <code>red</code> 和 <code>green</code> 就能明白了</p>
<p>有一种特殊的纹理称为 <code>tile</code>，这种纹理的特征是重复拼接之后上下左右都是连续的，因此这种纹理可以复制很多张贴在墙面或地板上。</p>
<p><img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/20250703090200.png" alt="image.png"></p>
<p>一个具体的重复利用这种贴图的例子如下:</p>
<p><img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/20250703090216.png" alt="image.png"></p>
<p>最后给出一个纹理坐标使用的伪代码供参考:</p>
<p><img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/20250703090250.png" alt="image.png"></p>
<p>简而言之就是对每个光栅化的屏幕坐标算出它的 uv 坐标 (利用三角形顶点重心坐标插值)，再利用这个 uv 坐标去查询 <code>texture</code> 上的颜色。</p>
<p>下面重点说下如何利用三角形顶点重心坐标插值。</p>
<h2 id="2-重心坐标"><a href="#2-重心坐标" class="headerlink" title="2 重心坐标"></a>2 重心坐标</h2><h3 id="2-1-三角形插值"><a href="#2-1-三角形插值" class="headerlink" title="2.1 三角形插值"></a>2.1 三角形插值</h3><h4 id="2-1-1-Why（为啥要插值）"><a href="#2-1-1-Why（为啥要插值）" class="headerlink" title="2.1.1 Why（为啥要插值）"></a>2.1.1 Why（为啥要插值）</h4><ul>
<li><strong>顶点定义值（Specify values at vertices）</strong>：图形渲染里，三角形的顶点会先设置属性（比如顶点颜色、纹理坐标），但三角形是面，需要让这些属性 “铺满” 整个面。</li>
<li><strong>平滑过渡（Obtain smoothly varying values across triangles）</strong>：直接用顶点值 “硬铺” 会很生硬，插值能让属性在三角形表面<strong>平滑变化</strong>，避免画面断层，让渲染效果更自然。</li>
</ul>
<h4 id="2-1-2-What（插值啥内容）"><a href="#2-1-2-What（插值啥内容）" class="headerlink" title="2.1.2 What（插值啥内容）"></a>2.1.2 What（插值啥内容）</h4><p>需要插值的，都是三角形渲染里的<strong>关键属性</strong>：</p>
<ul>
<li><strong>纹理坐标（Texture coordinates）</strong>：让纹理贴图贴合三角形时，过渡自然不撕裂；</li>
<li><strong>颜色（Colors）</strong>：实现顶点色到面的渐变（比如顶点红、绿、蓝，插值出中间渐变色 ）；</li>
<li><strong>法向量（Normal vectors）</strong>：影响光照计算，让光影在三角形表面平滑过渡，避免 “一块亮、一块暗”。</li>
</ul>
<h4 id="2-1-3-How（咋插值）"><a href="#2-1-3-How（咋插值）" class="headerlink" title="2.1.3 How（咋插值）"></a>2.1.3 How（咋插值）</h4><p>用<strong>重心坐标（Barycentric coordinates）</strong> ！它是三角形专属的坐标系统，通过顶点的 “权重比例”，把顶点属性<strong>平滑扩散</strong>到整个三角形区域（比如颜色插值：顶点色按重心坐标加权平均，得到面上任意点的颜色 ）。</p>
<h3 id="2-2-基础定义"><a href="#2-2-基础定义" class="headerlink" title="2.2 基础定义"></a>2.2 基础定义</h3><p><strong>Barycentric Coordinates</strong>：重心坐标，是<strong>专门为三角形设计</strong>的一种坐标系统，用 <code>(α,β,γ)</code> 三个参数表示三角形内任意一点的位置。</p>
<p><span style="color: #badc58; font-weight: 550;">定义：</span>给定三角形的三点坐标 A, B, C，该平面内一点 $(x,y)$ 可以写成这三点坐标的线性组合形式，即 $(x,y) = \alpha A + \beta B + \gamma C$ ，且三个坐标分量满足约束 $\alpha + \beta + \gamma = 1$，则称此时 3 个坐标 A,B,C 的权重为点 $(x,y)$ 的重心坐标。</p>
<p><img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/20250702100703.png" alt="image.png"></p>
<p><span style="color: #badc58; font-weight: 550;">判断点是否在三角形内的条件：</span>α、β、γ 都为<strong>非负数</strong>（即α≥0，β≥0，γ≥0 ）。</p>
<ul>
<li>若某分量为<strong>负</strong>：说明点在对应顶点的<strong>对边外侧</strong>（比如α&lt;0，点就在顶点 A 的对边 BC 外侧 ）；</li>
<li>若分量为<strong>1</strong>、其余为<strong>0</strong>：点就和对应顶点<strong>重合</strong>（比如α=1，β=γ=0，则 (x,y)=A ，即点就是顶点 A ）。</li>
</ul>
<h3 id="2-3-几何面积角度求解"><a href="#2-3-几何面积角度求解" class="headerlink" title="2.3 几何面积角度求解"></a>2.3 几何面积角度求解</h3><p>重心坐标的每个分量，是 “对应小三角形面积” 与 “原三角形总面积” 的比值，本质是用几何面积比例描述三角形内点的位置 。</p>
<p><img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/20250702101650.png" alt="image.png"></p>
<p>将一点 <code>(x,y)</code> 与 <code>A,B,C</code> 三点直接连接，构成三个三角形面积分别为 $A_A,A_B,A_C$，即可直接定义出重心坐标,，如图中公式所示。</p>
<blockquote>
<p> tips：如果这个点在某个边的外侧，那么该点与这条边构成的三角形面积计算为负值</p>
</blockquote>
<p><span style="color: #badc58; font-weight: 550;">补充：</span></p>
<p><img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/20250702101930.png" alt="image.png|612"></p>
<p>好了根据上述定义，我们只需求出各个三角形的面积便可以直接得出重心坐标了！</p>
<p>我们已知图中 4 点坐标，那么求出面积自然是很简单的，这里利用行列式 的几何意义直接求解</p>
<p><img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/20250702102626.png" alt="image.png"></p>
<p>设 <code>P(x,y)</code> 是三角形内任意一点，连接 P 与顶点，将原三角形 ABC 分割为 3 个小三角形：</p>
<ul>
<li>$A_A$​：△PBC 的面积（与 α 对应）</li>
<li>$A_B$​：△PCA 的面积（与 β 对应）</li>
<li>$A_C$​：△PAB 的面积（与 γ 对应）</li>
</ul>
<p><img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/20250702103046.png" alt="image.png"></p>
<p>利用行列式的几何意义，面积可表示为向量叉积的绝对值（或行列式的一半）。以 $A_C$​（△PAB 的面积）为例：</p>
<p><img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/20250702103116.png" alt="image.png"></p>
<p>同理，原三角形面积 $A_总​$ 为</p>
<p><img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/20250702103145.png" alt="image.png"></p>
<p>由于重心坐标是<strong>面积比值</strong>，计算时 “1/2” 会被约去。因此，直接用行列式的比值表示重心坐标分量：</p>
<p>以 <code>γ</code> 为例（对应 $A_C​$ 与 $A_总$​ 的比值）：</p>
<p><img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/20250702103234.png" alt="image.png"></p>
<p>展开行列式并整理（分子、分母分别展开计算），最终得到：</p>
<p>$$<br>\gamma = \frac{(y_A - y_B)x_C + (x_B - x_A)y_C + x_A y_B - x_B y_A}{(y_A - y_B)x_C + (x_B - x_A)y_C + x_A y_B - x_B y_A}<br>$$</p>
<p>β 对应 $A_B$​（△PCA 的面积）与 $A_总​$ 的比值，推导后形式为：</p>
<p>$$<br>\beta = \frac{(y_A - y_C)x_B + (x_C - x_A)y_B + x_A y_C - x_C y_A}{(y_A - y_C)x_B + (x_C - x_A)y_B + x_A y_C - x_C y_A}<br>$$</p>
<p>α 利用 $α=1−β−γ$ 直接得到（因为重心坐标和为 1 ）</p>
<p>综上：</p>
<p><img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/20250702103505.png" alt="image.png"></p>
<h3 id="2-4-坐标系角度求解"><a href="#2-4-坐标系角度求解" class="headerlink" title="2.4 坐标系角度求解"></a>2.4 坐标系角度求解</h3><p>针对重心坐标系的另外一种等价视角便是</p>
<ul>
<li>以顶点 A（记为 a ）为原点，</li>
<li>向量 <code>AB=b−a</code>、<code>AC=c−a</code> 作为<strong>新坐标系的基向量</strong>。</li>
</ul>
<p>如图所示：</p>
<p><img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/20250702103546.png" alt="image.png"></p>
<p>三角形内任意点 <code>P</code>（记为 p ），在新坐标系中用 <code> (β,γ) </code> 表示，满足：</p>
<p>$\boldsymbol{\mathrm{p} = \mathrm{a} + \beta(\mathrm{b} - \mathrm{a}) + \gamma(\mathrm{c} - \mathrm{a})}$</p>
<p>进一步化简得到：</p>
<p>$$<br>\boldsymbol{\mathrm{p} = (1 - \beta - \gamma)\mathrm{a} + \beta\mathrm{b} + \gamma\mathrm{c}}<br>$$</p>
<p>到这里其实就可以发现，我们已经成功的把 <code>P</code> 用三角形的三个顶点的线性组合表示了，并且 3 个权重之和为 1，完全符合定义，因此这是一种完全等价的角度！</p>
<p>从这种角度出发，我们完全可以将上式表现成一个线性方程组来求解出，两个未知量，两个式子，如下：</p>
<p>$$<br>\begin{bmatrix} x_b - x_a &amp; x_c - x_a \ y_b - y_a &amp; y_c - y_a \end{bmatrix} \begin{bmatrix} \beta \ \gamma \end{bmatrix} = \begin{bmatrix} x_p - x_a \ y_p - y_a \end{bmatrix}<br>$$</p>
<p>解此方程组，可得到 <code>β、γ</code>，进而得到 <code>α</code> ，与 “面积比例法” 推导结果<strong>完全一致</strong>。</p>
<p><img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/20250702104010.png" alt="image.png"></p>
<h3 id="2-5-如何用重心坐标做插值"><a href="#2-5-如何用重心坐标做插值" class="headerlink" title="2.5 如何用重心坐标做插值"></a>2.5 如何用重心坐标做插值</h3><p><img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/20250702104321.png" alt="image.png"></p>
<p><span style="color: #badc58; font-weight: 550;">核心：</span>利用α、β、γ，对 $V_A,V_B,V_C$ 顶点属性进行加权平均</p>
<p><img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/20250702104335.png" alt="image.png"></p>
<p>但要注意：</p>
<ul>
<li>重心坐标 <code>α,β,γ</code> 在投影变换下<strong>不保持</strong>不变，不能直接用原来的 3D 重心坐标做屏幕空间 (2D) 插值。</li>
<li>投影后的位置不满足简单的线性加权平均，直接用三维重心坐标对屏幕上点属性插值会导致错误</li>
</ul>
<h3 id="2-6-重心坐标在投影变换下不具有不变性"><a href="#2-6-重心坐标在投影变换下不具有不变性" class="headerlink" title="2.6 重心坐标在投影变换下不具有不变性"></a>2.6 重心坐标在投影变换下<strong>不具有</strong>不变性</h3><p>在图形学中，<strong>重心坐标在投影变换下不具有不变性</strong>，意味着：三维空间中三角形某点的重心坐标，在经过投影（如透视投影）映射到二维屏幕后，<strong>不能直接沿用</strong>，需要重新计算。这是由于 3D 到 2D 的投影过程是<strong>非线性</strong>的，导致线性关系发生改变。</p>
<p><span style="color: #badc58; font-weight: 550;">像素级插值发生在光栅化的屏幕空间：</span></p>
<ul>
<li>在渲染管线中，顶点属性（如颜色、纹理坐标）的插值发生在屏幕空间 (2D) 中，每个像素的属性值是通过该像素在屏幕空间三角形内的重心坐标插值得到的。</li>
<li>如果直接使用 3D 空间的重心坐标进行插值，会因透视投影的非线性而导致错误（如颜色过渡不均匀、纹理扭曲）</li>
</ul>
<p><span style="color: #badc58; font-weight: 550;">正确做法</span>：</p>
<ul>
<li>先在屏幕空间中，根据投影后的 2D 顶点坐标计算每个像素的重心坐标，</li>
<li>然后配合<strong>透视校正</strong>方法，对顶点属性做非线性插值，从而恢复正确的 3D 属性值。</li>
</ul>
<p><span style="color: #badc58; font-weight: 550;">总结：</span></p>
<table>
<thead>
<tr>
<th>转换方向</th>
<th>是否成立</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td><strong>3D → 2D 重心坐标</strong></td>
<td>❌ 不成立</td>
<td>因为透视投影非线性，3D 中线性结构投影后被破坏</td>
</tr>
<tr>
<td><strong>2D → 3D 属性值</strong></td>
<td>✅ 可行</td>
<td>通过<strong>透视校正</strong>插值，可以恢复 3D 空间中正确的颜色、纹理、深度等属性值</td>
</tr>
</tbody></table>
<ul>
<li>3D 重心坐标经过投影后，不能直接当作 2D 重心坐标使用（不成立）  </li>
<li>但 2D 重心坐标 + 透视校正，可以“还原”或“恢复”3D 空间中的属性值，如深度、纹理坐标、颜色等（不是恢复坐标位置）</li>
</ul>
<p><span style="color: #badc58; font-weight: 550;">类比理解：</span></p>
<p>想象你拍一张透视照片，三角形 A、B、C 在照片中变形了。你只能：</p>
<ul>
<li><strong>在照片（2D）上判断哪个点在哪个区域内</strong>（= 2D 重心坐标）</li>
<li>然后通过算法去“还原”这个像素点原本在 3D 空间中应该对应哪个颜色、纹理（= 透视校正）</li>
</ul>
<h3 id="2-7-透视校正插值"><a href="#2-7-透视校正插值" class="headerlink" title="2.7 透视校正插值"></a>2.7 透视校正插值</h3><p><strong>透视校正插值</strong>是指：为了在屏幕空间中正确插值顶点属性（如颜色、纹理坐标、深度等），必须纠正透视投影带来的非线性畸变。</p>
<h4 id="2-7-1-问题来源：为什么要“校正”？"><a href="#2-7-1-问题来源：为什么要“校正”？" class="headerlink" title="2.7.1 问题来源：为什么要“校正”？"></a>2.7.1 问题来源：为什么要“校正”？</h4><p><img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/20250702113946.png" alt="image.png"></p>
<p>透视矫正插值的核心矛盾就是：<strong>屏幕空间的线性插值（如点 c 的亮度），和 view space 中真实的插值结果（点 C 的亮度）不一致</strong>。</p>
<p><img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/20250702160425.png" alt="image.png"></p>
<blockquote>
<p>c 是在 a,b 中的线性插值，C 是 A,B 中的线性插值</p>
</blockquote>
<ul>
<li>屏幕空间是 2D 的、经过透视投影 “压缩” 的结果；</li>
<li>view space 是 3D 的、相机视角下 “真实” 的空间。</li>
</ul>
<p>直接用屏幕空间插值会出错，所以需要透视矫正，让屏幕空间插值结果等价于视图空间的正确结果。</p>
<h4 id="2-7-2-公式推导"><a href="#2-7-2-公式推导" class="headerlink" title="2.7.2 公式推导"></a>2.7.2 公式推导</h4><p>首先先分别定义屏幕空间 (screen space) 的比例为 <code>s</code>，视图空间 (view space) 中为 <code>t</code>，其余符号含义如下图所示：</p>
<p><img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/20250702161103.png" alt="image.png"></p>
<p>为了简便证明，将点的坐标用 2 维表示，第一维为图中所示的 x 轴，第二维为 z 轴。 简而言之，我们的目标就是得出 t 与 s 的关系式，这样就可以正确的利用屏幕空间的系数 s 插值到正确的视图空间的结果，推导过程如下：</p>
<p><span style="color: #badc58; font-weight: 550;">几何基础：透视投影的相似三角形</span></p>
<p>虚拟相机、3D 点（(A、B) ）、屏幕投影点（(a、b) ）构成<strong>相似三角形</strong>，利用相似比建立 3D 坐标 (X, Z) 和屏幕坐标 (u, d) 的关系：</p>
<p><img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/20250702161445.png" alt="image.png|727"></p>
<blockquote>
<p> <code>d</code> 是虚拟相机到屏幕的距离，是推导中的已知常量</p>
</blockquote>
<p><span style="color: #badc58; font-weight: 550;">代数变换：关联 s 和 t</span></p>
<p>利用屏幕空间以及视图空间的线性插值可以得到以下几个式子：</p>
<p><img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/20250702161558.png" alt="image.png|524"></p>
<p><strong>1、代入屏幕空间与视图空间的线性插值</strong>：将 (4)、(5) 代入 (3)，得到 $Z_t$ 关于 <code>s</code> 和 <code>t</code> 的表达式：</p>
<p><img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/20250702161625.png" alt="image.png|496"></p>
<p><strong>2、用相似三角形结果替换</strong> $X_1、X_2$：把 (1)、(2) 代入 (7)，化简后得到：</p>
<p><img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/20250702162134.png" alt="image.png"></p>
<p><strong>3、联立视图空间的深度插值</strong>：视图空间中，深度 $Z_t$ 也满足线性插值（公式 6 ）。将 (6) 代入 (8) 左边，得到：</p>
<p><img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/20250702162311.png" alt="image.png"></p>
<p><strong>4、解出 <code>t</code> 与 <code>s</code> 的关系</strong>：整理 (9)，最终得到 <code>t</code> 关于 <code>s</code> 的表达式（核心矫正公式）：</p>
<p><img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/20250702162358.png" alt="image.png"></p>
<h4 id="2-7-3-推广到任意属性（深度、亮度、纹理等）"><a href="#2-7-3-推广到任意属性（深度、亮度、纹理等）" class="headerlink" title="2.7.3 推广到任意属性（深度、亮度、纹理等）"></a>2.7.3 推广到任意属性（深度、亮度、纹理等）</h4><h5 id="深度-Z-t-的矫正插值"><a href="#深度-Z-t-的矫正插值" class="headerlink" title="深度 $Z_t$ 的矫正插值"></a>深度 $Z_t$ 的矫正插值</h5><p>代入 $Z_t = Z_1 + t(Z_2 - Z_1)$, 即可得深度 $Z_t$ 的矫正插值：</p>
<p><img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/20250702162605.png" alt="image.png"></p>
<blockquote>
<p> 本质是对 “深度的倒数 $\frac{1}{Z}$” 做线性插值，再取倒数恢复深度</p>
</blockquote>
<h5 id="任意属性-I-t-的矫正插值"><a href="#任意属性-I-t-的矫正插值" class="headerlink" title="任意属性 $I_t$ 的矫正插值"></a>任意属性 $I_t$ 的矫正插值</h5><p>正确得出深度的插值结果之后，再看看任意属性 (法线向量，纹理坐标，view space 坐标) 插值结果，依然以线性插值为例先进行推导：</p>
<p>用 $I$ 代表任意属性：</p>
<p><img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/20250702163643.png" alt="image.png"></p>
<p>不难看出插值的分母就是深度值的倒数，类推得出重心坐标任意属性的正确插值如下:</p>
<p><img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/20250702163724.png" alt="image.png"></p>
<h4 id="2-7-4-透视校正的核心思想"><a href="#2-7-4-透视校正的核心思想" class="headerlink" title="2.7.4 透视校正的核心思想"></a>2.7.4 透视校正的核心思想</h4><p><img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/20250702171046.png" alt="image.png"></p>
<p><img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/20250702172644.png"></p>
<p><strong>先理解 “ 1、回到齐次空间的线性逻辑 “ 这句话：</strong></p>
<p><img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/20250702174903.png" alt="image.png"></p>
<p><strong>再理解 “ 2、还原屏幕空间的正确值 “ 这句话：</strong><br><img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/20250702175349.png" alt="image.png"></p>
<p><span style="color: #badc58; font-weight: 550;">类比：</span></p>
<ul>
<li>投影时，将属性 $I$ 与 $1/w$ 绑定，即 $I$ <strong>乘</strong> $1/w$（类似透视投影变换中乘 $w$，将非线性关系 “<strong>压缩</strong>” 到 $w$ 中），使齐次空间中的插值可线性处理；</li>
<li>还原时，通过<strong>除以</strong> $1/w$，将 “压缩” 的线性关系 “<strong>解压缩</strong>”（类似透视除法，除以 $w$），得到屏幕空间的正确属性，确保与视图空间的物理规律一致。</li>
</ul>
<p>可以把整个过程想象成 <strong>“拍照时压缩，插值时还原”</strong>：</p>
<ul>
<li>投影（拍照）：为了用矩阵处理，通过 “乘 z” 把透视的非线性 “压缩” 到 w 分量里（类似把真实世界的 “近大远小” 先记录下来 ）。</li>
<li>插值（后期）：直接用屏幕空间的线性插值会 “忘掉压缩的非线性”，<strong>所以需要先按 “压缩的规律”（(I/w) ）插值，再 “还原”（除以 (1/w) ）</strong>，让结果符合真实世界的视觉规律。</li>
</ul>
<p><span style="color: #badc58; font-weight: 550;">总结：</span></p>
<p>在透视投影中，插值之前先<strong>除以 w</strong>，插值之后再乘回来，恢复正确值。</p>
<p>以纹理坐标 uv 为例：</p>
<p><img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/20250702114026.png" alt="image.png"></p>
<p>对于亮度、纹理坐标等任意属性 $I$，同理推导：先对 “$\frac{属性}{深度} = \frac{I}{Z}$” 做线性插值，再用 “深度倒数 $\frac{1}{Z}$” 归一化，公式为：</p>
<p><img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/20250702163923.png" alt="image.png"></p>
<p><img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/20250702173026.png" alt="image.png"></p>
<p><img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/20250702164003.png" alt="image.png|439"></p>
<h4 id="2-7-5-应用场景"><a href="#2-7-5-应用场景" class="headerlink" title="2.7.5 应用场景"></a>2.7.5 应用场景</h4><p><img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/20250709211650.png" alt="image.png"></p>
<ul>
<li>正确插值纹理坐标（uv）</li>
<li>插值颜色（防止颜色跳变）</li>
<li>插值深度值（保证 Z-buffer 准确）</li>
<li>插值法线、光照参数等</li>
</ul>
<h2 id="3-纹理尺寸与显示需求不匹配"><a href="#3-纹理尺寸与显示需求不匹配" class="headerlink" title="3 纹理尺寸与显示需求不匹配"></a>3 纹理尺寸与显示需求不匹配</h2><h3 id="3-1-纹理过小"><a href="#3-1-纹理过小" class="headerlink" title="3.1 纹理过小"></a>3.1 纹理过小</h3><h4 id="3-1-1-问题"><a href="#3-1-1-问题" class="headerlink" title="3.1.1 问题"></a>3.1.1 问题</h4><p>当纹理尺寸（如 100×100 ）远小于应用的屏幕空间（如 500×500 ），屏幕多个像素会对应纹理单个像素，仅取最近像素点会让画面 “糊”“失真” 。</p>
<p><img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/20250703091532.png"></p>
<p>如图中红色点是屏幕空间内 多个 像素所对应在 <code>texture</code> 空间中的点，每个屏幕像素直接取<strong>离它最近的纹素颜色</strong>（橙色框内的黑点 ）</p>
<h4 id="3-1-2-双线性插值-Bilinear-Interpolation"><a href="#3-1-2-双线性插值-Bilinear-Interpolation" class="headerlink" title="3.1.2 双线性插值 (Bilinear Interpolation)"></a>3.1.2 双线性插值 (Bilinear Interpolation)</h4><p>在图形渲染中，让纹理映射更平滑，避免 “取最近像素” 导致的失真，通过融合周围像素颜色，计算出更自然的过渡值。</p>
<ul>
<li><strong>选邻域像素</strong>：找红色点（屏幕像素对应纹理空间的点）周围<strong>最近的 4 个黑色顶点</strong>（纹理像素），记为 <code>u00</code>、<code>u10</code>、<code>u01</code>、<code>u11</code> 。</li>
<li><strong>算偏移比率</strong>：计算红色点在水平（<code>s</code>）和竖直（<code>t</code>）方向相对 4 个顶点的偏移比例，描述其位置关系。</li>
</ul>
<p><img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/20250703092037.png" alt="image.png"></p>
<ul>
<li><strong>一次线性插值（水平）</strong>：用偏移 <code>s</code>，对水平方向的两组顶点（<code>u00 &amp; u10</code>、<code>u01 &amp; u11</code> ）做线性插值，得到中间临时值 <code>u0</code> 和 <code>u1</code> 。公式是 <code>u0 = lerp(s, u00, u10)</code>、<code>u1 = lerp(s, u01, u11)</code> ，本质是按比例混合水平相邻像素的颜色。</li>
<li><strong>二次线性插值（竖直）</strong>：用偏移 <code>t</code>，对 <code>u0</code> 和 <code>u1</code> 做线性插值，得到红色点最终颜色 <code>f(x,y) = lerp(t, u0, u1)</code> 。通过两次线性插值，融合了 4 个邻域像素的影响。</li>
</ul>
<blockquote>
<p> 还有一种插值方法叫做双三次插值 (Bicubic),是利用三次方程来进行两次插值，效果可能更好，但是计算速度很低</p>
</blockquote>
<h4 id="3-1-3-三种方法对比"><a href="#3-1-3-三种方法对比" class="headerlink" title="3.1.3 三种方法对比"></a>3.1.3 三种方法对比</h4><p><img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/20250703092329.png" alt="image.png"></p>
<ol>
<li><p>Nearest（最近邻插值）</p>
<ul>
<li><strong>效果</strong>：最粗糙，有明显锯齿（如发丝、眼部边缘的像素块 ）。</li>
<li><strong>性能</strong>：计算最快（直接取最近纹素颜色 ）。</li>
</ul>
</li>
<li><p>Bilinear（双线性插值，红色标注）</p>
<ul>
<li><strong>效果</strong>：比最近邻平滑很多，锯齿大幅减少（发丝和眼部过渡自然 ）。</li>
<li><strong>性能</strong>：计算成本适中（对周围 4 个纹素做两次线性插值 ）。</li>
</ul>
</li>
<li><p>Bicubic（双三次插值）</p>
<ul>
<li><strong>效果</strong>：最平滑（发丝和皮肤细节过渡最自然 ）。</li>
<li><strong>性能</strong>：计算成本最高（对周围 16 个纹素做三次函数插值 ）。</li>
</ul>
</li>
</ol>
<h3 id="3-2-纹理过大"><a href="#3-2-纹理过大" class="headerlink" title="3.2 纹理过大"></a>3.2 纹理过大</h3><h4 id="3-2-1-问题"><a href="#3-2-1-问题" class="headerlink" title="3.2.1 问题"></a>3.2.1 问题</h4><p>纹理过大时（如大面积地板重复方格纹理 ），直接采样会出现严重走样：</p>
<ul>
<li><strong>近处物体</strong>在屏幕投影大 (近大远小)，单个屏幕像素对应纹理的<strong>覆盖区域小</strong>（足迹小），需<strong>放大纹理</strong>（Upsampling）。若直接采样（如最近邻插值），会因单个纹素覆盖多个屏幕像素，导致颜色过渡生硬，形成锯齿 (Jaggies) 边缘。</li>
<li><strong>远处物体</strong>在屏幕投影小 (近大远小)，单个屏幕像素对应纹理的<strong>覆盖区域大</strong>（足迹大），覆盖<strong>多个纹素</strong>。直接采样仅取单个纹素颜色，未对多纹素信息聚合 (信息丢失)，导致纹素间的颜色差异（高频信号）与采样频率冲突，形成周期性干涉图案（摩尔纹 Moire）。</li>
</ul>
<blockquote>
<ul>
<li>若纹理过小（100×100），无论物体远近，近处需放大采样（足迹小），远处虽足迹大，但纹理分辨率仍不足（大足迹覆盖的纹素数仍少），仍需通过插值补充细节。</li>
</ul>
</blockquote>
<p><img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/20250703092654.png" alt="image.png"></p>
<p><span style="color: #badc58; font-weight: 550;">足迹（Footprint）</span></p>
<p>屏幕上一个像素覆盖纹理的范围，称为纹理的 <strong>足迹（Footprint）</strong></p>
<ul>
<li><strong>灰色小点</strong>：代表<strong>纹理空间的像素（纹素，Texel）</strong> ，是纹理本身的最小单位；</li>
<li><strong>蓝色小点 + 紫色框</strong>：代表<strong>屏幕空间的像素（Pixel）</strong> ，蓝色点是像素中心，紫色框是像素覆盖的纹理区域范围；</li>
</ul>
<p><img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/20250703093056.png" alt="image.png"></p>
<p>从左到右，屏幕像素（蓝点 + 紫框）离 “相机 / 观察者”<strong>越来越远</strong>（可理解为纹理在画面中被 “缩小显示” ）：</p>
<ul>
<li><strong>最左侧（Upsampling）</strong>：屏幕像素很小，覆盖的纹理像素也少（紫框小）。此时纹理被 “放大” 显示，容易出现<strong>纹理过小问题</strong>（比如 1 个屏幕像素对应少量纹素，采样不足会模糊 ）。</li>
<li><strong>最右侧（Downsampling）</strong>：屏幕像素不变，但离得远，覆盖的纹理像素变多（紫框大）。此时纹理被 “缩小” 显示，容易出现<strong>纹理过大问题</strong>（1 个屏幕像素要覆盖大量纹素，点采样会丢失信息，产生锯齿、摩尔纹 ）。</li>
</ul>
<h4 id="3-2-2-初步解法与缺陷（超采样-Supersampling）"><a href="#3-2-2-初步解法与缺陷（超采样-Supersampling）" class="headerlink" title="3.2.2 初步解法与缺陷（超采样 Supersampling）"></a>3.2.2 初步解法与缺陷（超采样 Supersampling）</h4><p>为解决 “1 个屏幕像素覆盖纹理多像素” 的问题，直观思路是<strong>超采样</strong>：把 1 个屏幕像素细分为多个子采样点，用更多采样覆盖纹理区域。</p>
<ul>
<li><strong>效果</strong>：512 倍超采样可大幅缓解走样（如地板纹理更平滑 ）；</li>
<li><strong>缺陷</strong>：计算量爆炸（1 像素拆 512×512 子点，计算量暴增 25 万倍 ），且远处像素需更高采样频率，实用价值低。</li>
</ul>
<p><img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/20250703093346.png" alt="image.png"></p>
<h4 id="3-2-3-Mipmap"><a href="#3-2-3-Mipmap" class="headerlink" title="3.2.3 Mipmap"></a>3.2.3 Mipmap</h4><p>正如上文所提，一个采样点的颜色信息不足以代表 “footprint”里一个区域的颜色信息，如果可以求出这样一个区域里面所有颜色的均值，是不是就是一种可行的方法呢？没错我们的目标就是从点查询 Point Query 迈向区域查询 Range Query。</p>
<p><img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/20250703101933.png" alt="image.png"></p>
<p>但依然存在一个问题，从上图不难看出，不同的屏幕像素所对应的 footprint size 是不一样大小的，看下图这样一个例子：</p>
<p><img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/20250703093932.png" alt="image.png|643"></p>
<ul>
<li><strong>近处物体</strong>：在屏幕上占的像素多（显得大），所以<strong>每个像素对应纹理的区域很小</strong>；</li>
<li><strong>远处物体</strong>：在屏幕上占的像素少（显得小），所以<strong>每个像素对应纹理的区域很大</strong>。</li>
</ul>
<p>远处圆圈里的 <code>footprint</code> 必然比近处的要大，因此必须要准备不同 <code>level</code> 的区域查询才可以，而这正是 Mipmap。</p>
<blockquote>
<p> Mipmap 的核心设计逻辑：根据物体距离（屏幕像素的纹理足迹大小），动态选择匹配的纹理分辨率</p>
</blockquote>
<p><span style="color: #badc58; font-weight: 550;">预生成多级纹理</span></p>
<p><img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/20250703102444.png" alt="image.png"></p>
<ul>
<li>原始纹理为 Level 0（如 128×128 ），每提升一级（Level +1 ），将 4 个相邻纹素（纹理像素 ）均值合并为 1 个，生成更小分辨率的纹理（如 Level 1 为 64×64 ，Level 2 为 32×32 … 直到 1×1 ）。</li>
<li>高 Level 纹理对应<strong>更大 footprint</strong>（覆盖更多原始纹素 ），适配远处屏幕像素需求。<ul>
<li>近处像素 → 选高分辨率层级（小 D）</li>
<li>远处像素 → 选低分辨率层级（大 D）</li>
</ul>
</li>
</ul>
<p><img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/20250703102817.png" alt="image.png"></p>
<p><span style="color: #badc58; font-weight: 550;">动态选择 Level</span></p>
<p>那么如何去确定使用哪个 level 的 texture 呢？利用屏幕像素的相邻像素点估算 <code>footprint</code> 大小再确定 level D！如下图:</p>
<p><strong>核心思想</strong>：取相邻像素（比如红色箭头的像素），看它们的 UV 坐标在纹理空间中跑了多远 → 这个距离决定了 “纹理足迹有多大”。</p>
<p><img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/20250703103848.png" alt="image.png|734"></p>
<p>用 “纹理坐标的变化率” 计算层级 D</p>
<p><img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/20250703103520.png" alt="image.png"></p>
<p>举个例子</p>
<p><img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/20250703103654.png" alt="image.png"></p>
<p><span style="color: #badc58; font-weight: 550;">3 线性插值</span></p>
<p>计算出的 D 常为连续值（非整数 ），为避免 Level 切换生硬，采用：</p>
<ul>
<li>对 D 向下取整（D_floor ）和向上取整（D_ceil ）的两个 Level，分别做<strong>双线性插值</strong>（融合该 Level 纹理的邻域颜色 ）；</li>
<li>再根据 D 的小数部分，对两个 Level 的插值结果做<strong>线性混合</strong>，让过渡更平滑。</li>
</ul>
<p><img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/20250703104044.png" alt="image.png"></p>
<ul>
<li>在 D_floor，D_ceil 上分别用<strong>双线性插值</strong>计算采样点颜色（红色圆点 → 粉色区域的加权平均 ）。</li>
<li>由于 Mipmap 层级是 “连续” 的（实际计算的 D 可能是小数，比如 D=1.3 ），需要在 Level D_floor 和 Level D_ceil 的双线性结果之间，再做一次线性插值。</li>
<li>插值权重由 “连续的 D 值” 决定（比如 D=1.3 时，70% 取 Level D_floor 的结果，30% 取 Level D_ceil 的结果 ）。</li>
</ul>
<blockquote>
<p> D=1.3，更接近 1, 即应该更清晰，故 D_floor 占比更高</p>
</blockquote>
<p>如下图展示使用三线性过滤（Trilinear filtering）时，连续 Mipmap 层级 D 的可视化效果，能呈现层级间更平滑的过渡</p>
<p><img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/20250703105312.png" alt="image.png"></p>
<h4 id="3-2-4-各向异性过滤-Mipmap"><a href="#3-2-4-各向异性过滤-Mipmap" class="headerlink" title="3.2.4 各向异性过滤 Mipmap"></a>3.2.4 各向异性过滤 Mipmap</h4><p>Mipmap 用 “正方形区域均值” 适配屏幕像素的 <code>footprint</code>，但实际场景中，屏幕像素的 <code>footprint</code> <strong>常是长方形、不规则形状</strong>（比如倾斜视角的地板纹理 ）。</p>
<p>此时 Mipmap 统一用正方形层级均值，会导致<strong>过度模糊（远处纹理细节丢失严重 ）</strong> 。</p>
<p><img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/20250703105154.png" alt="image.png"></p>
<p>如下图：</p>
<p>当模型存在<strong>倾斜、透视变形或非线性变换</strong>时（比如地面网格因视角变形成梯形），屏幕像素对应到纹理空间的采样区域会从 “规则矩形” 变成<strong>不规则形状</strong>（右侧纹理空间的白色长条、碎片状区域 ）。</p>
<p><img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/20250703110015.png" alt="image.png"></p>
<ul>
<li><strong>Screen space（屏幕空间）</strong>：左侧是最终渲染到屏幕的 2D 图像，白色方块代表屏幕像素。</li>
<li><strong>Texture space（纹理空间）</strong>：右侧是纹理的 2D 网格，箭头表示 “屏幕像素→纹理采样区域” 的映射。</li>
</ul>
<p>这会导致：</p>
<ul>
<li>传统 “轴对齐矩形采样”（如 Mipmap 默认的方形区域）无法精准匹配，出现失真；</li>
<li>需要更复杂的过滤算法（如<strong>各向异性过滤</strong>）处理不规则区域的采样。</li>
</ul>
<p><span style="color: #badc58; font-weight: 550;">Ripmaps + Summed Area Tables（早期方案）</span></p>
<p><strong>Ripmaps（矩形层级纹理）</strong>：预存不同方向、不同分辨率的矩形纹理层级。比如针对水平、垂直、45 度等常见轴对齐方向，提前生成多分辨率的纹理版本。这样在渲染时，若采样区域是规则的轴对齐矩形，可直接选取对应方向和分辨率的预存纹理，减少实时计算量。</p>
<p><strong>Summed Area Tables（累积区域表）</strong>：</p>
<ul>
<li>是一种快速计算矩形区域颜色均值的数学工具。预先对纹理的每个位置，计算从纹理原点到该位置所形成矩形区域内的颜色总和（可按 RGB 通道分别计算 ）。</li>
<li>当需要计算任意轴对齐矩形区域的颜色均值时，无需逐像素遍历求和，而是通过简单的四则运算（利用累积区域表中预存的四个角点数值 ），就能快速得到结果，大幅优化采样时计算区域颜色的效率。</li>
</ul>
<p><img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/20250703111408.png" alt="image.png"></p>
<p>当采样区域是倾斜、不规则形状时（如前面图中的对角线区域 ），这类轴对齐方案会因无法匹配形状导致失真。</p>
<blockquote>
<p> 这种早期方案虽然有局限性，但为后续更先进的各向异性过滤技术（如 EWA Filtering ）奠定了基础</p>
</blockquote>
<p><span style="color: #badc58; font-weight: 550;">椭圆加权平均 EWA Filtering （更优方案）</span></p>
<blockquote>
<p> Elliptical Weighted Average Filtering</p>
</blockquote>
<p>EWA 通过<strong>椭圆模型拟合不规则足迹</strong>，以椭圆中心为基准，根据采样点到中心的距离分配权重，实现更精准的区域采样。</p>
<p><img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/20250703111546.png" alt="image.png"></p>
<ul>
<li><strong>多次采样</strong>：在椭圆区域内对多个纹理点进行采样，而非仅取单一纹素；</li>
<li><strong>距离加权</strong>：离椭圆中心越近的采样点权重越高，越远则权重越低（通常采用高斯函数或类似衰减模型），确保中心区域对最终颜色的贡献更大，边缘区域贡献更小，模拟人眼对中心细节更敏感的特性。</li>
</ul>
<p>EWA 过滤仍依赖 Mipmap 的多分辨率纹理层级：</p>
<ol>
<li><strong>根据足迹大小选择 Mipmap 层级</strong>：先通过计算确定当前像素对应的 Mipmap 层级（如根据纹理坐标变化率计算 D 值），选择对应分辨率的纹理进行采样，避免直接使用高分辨率纹理导致计算量爆炸；</li>
<li><strong>预过滤减少高频信号干扰</strong>：Mipmap 的低分辨率层级已对纹理进行预平均，EWA 在此基础上对椭圆区域内的纹素做加权平均，进一步降低频率混叠（如摩尔纹）的风险。</li>
</ol>
<h2 id="4-纹理映射的应用"><a href="#4-纹理映射的应用" class="headerlink" title="4 纹理映射的应用"></a>4 纹理映射的应用</h2><h3 id="4-1-法线贴图-Normal-Maps"><a href="#4-1-法线贴图-Normal-Maps" class="headerlink" title="4.1 法线贴图 (Normal Maps)"></a>4.1 法线贴图 (Normal Maps)</h3><h4 id="4-1-1-法线贴图的作用"><a href="#4-1-1-法线贴图的作用" class="headerlink" title="4.1.1 法线贴图的作用"></a>4.1.1 法线贴图的作用</h4><p>在 Blinn - Phong 光照模型里，法线向量对光照计算影响大。把高精度模型的法线信息，通过纹理（Texture）存储法线向量，套用到低精度模型，能提升低精度模型渲染效果，让简化后的模型也有丰富细节。</p>
<p><img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/20250703150107.png" alt="image.png"></p>
<h4 id="4-1-2-法线信息存储方式"><a href="#4-1-2-法线信息存储方式" class="headerlink" title="4.1.2 法线信息存储方式"></a>4.1.2 法线信息存储方式</h4><ul>
<li><strong>物体空间（object space）</strong>：存法线向量坐标，优点是转世界坐标可直接用；但模型面变形（如人物动画）时，法线向量会失效。</li>
<li><strong>切线空间（tangent space，简称 tbn）</strong>：存切线空间下法线向量坐标，更适配模型变形场景，是常用方案。</li>
</ul>
<p><span style="color: #badc58; font-weight: 550;">物体空间，也称为模型空间</span></p>
<ul>
<li><strong>定位子零件</strong>：模型空间是物体 “自身的局部坐标系”，子零件（比如汽车的车轮、车窗）在模型空间里定义位置、朝向，方便建模时 “相对物体自身” 调整细节。</li>
<li><strong>特点</strong>：与物体绑定，<strong>子零件的坐标、方向 “相对于物体整体” 描述，不管场景里物体怎么移动 / 旋转，子零件在模型空间的相对关系不变</strong>。</li>
</ul>
<p><span style="color: #badc58; font-weight: 550;">切线空间</span></p>
<ul>
<li><strong>定位法线</strong>：切线空间是物体表面 “<strong>某一点的局部坐标系</strong>”，法线（尤其是法线贴图里的细节法线）在切线空间里定义方向，方便 <strong>“相对表面局部” 描述凹凸细节</strong>。</li>
<li><strong>特点</strong>：与表面局部绑定，法线的方向 “相对于该点的表面朝向” 描述，不管模型怎么变形 / 动画，切线空间能 “跟着表面局部一起变”，保证细节法线始终贴合表面。</li>
</ul>
<h4 id="4-1-3-切线空间坐标系的求解"><a href="#4-1-3-切线空间坐标系的求解" class="headerlink" title="4.1.3 切线空间坐标系的求解"></a>4.1.3 切线空间坐标系的求解</h4><p>切线空间由切线轴 T（tangant）、副切线轴 B（bitangent）、法线轴 N（原模型几何法线，指向物体表面外侧 ）三个正交基底向量组成。其中，T、B 由模型表面贴图的 u、v 方向变化构成，<strong>N 基于原模型信息获取</strong>。</p>
<ul>
<li>N 轴对应切线空间的 <strong>z 轴</strong>（或理解为 “法向维度”）</li>
<li>T（切线）、B（副切线）对应 x、y 轴（纹理 uv 方向的维度）</li>
</ul>
<p>如下图所示：</p>
<p><img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/20250703151437.png" alt="image.png|479"></p>
<p>法线向量 N 可以根据原来的模型信息得到，如何去计算 T，B 呢？</p>
<p><img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/20250703152322.png" alt="image.png|494"></p>
<p>如上图所示，记一个三角形的面的三个顶点分别为 $p_0, p_1, p_2$，并且使用 $(u_i,v_i)$ 来表示对应顶点的 <code>texture</code> 坐标，那么根据顶点坐标的差值，纹理坐标的差值，以及 t, b 两轴，可以得到如下关系</p>
<p><img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/20250703152716.png" alt="image.png"></p>
<p>为了进一步简化公式，设：</p>
<p><img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/20250703152837.png" alt="image.png"></p>
<p>那么便可以把第一个公式简化为如下形式：</p>
<p><img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/20250703152855.png" alt="image.png"></p>
<p>利用线代知识，将其写为矩阵形式:</p>
<p><img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/20250703154606.png" alt="image.png"></p>
<p>相信熟悉线性方程组的同学，已经知道如何解出 t，b 向量了，两边同乘系数矩阵的逆即可得到:</p>
<p><img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/20250703154618.png" alt="image.png"></p>
<p>其中右边式子中的变量全部已知，自然就已经成功求出 <code>t、b</code> 两轴向量，再加上原几何法线向量 <code>n</code>，至此便已经得出了切线空间 (<code>tbn</code>)。</p>
<blockquote>
<ul>
<li><strong>施密特正交化</strong>：计算出的 t、b 可能不垂直，需用施密特正交化处理，去除非垂直分量，让二者正交，更贴合切线空间要求。</li>
<li><strong>存储优化</strong>：实际存储只需 t 和 N，b 可由 t 与 N 叉乘得到；t 像法线一样，可作为顶点属性，取共享顶点的三角形计算均值插值。</li>
</ul>
</blockquote>
<p>当模型表面 “没有细节变动”（比如平坦区域），其法线方向 <strong>天然与切线空间的 N 轴对齐</strong> 。此时，切线空间下记录的法线向量就是 <code>(0,0,1)</code>—— x、y 分量为 0（无切线 / 副切线方向的偏移），z 分量为 1（完全沿法线轴正向）。</p>
<p>法线贴图本质是 <strong>“存储切线空间下法线向量” 的纹理</strong> ，它用 RGB 颜色通道对应切线空间法线的 <code>(x,y,z)</code> 分量。但直接存储原始向量会有问题（比如负数无法表示），因此会先做 <strong>“范围映射”</strong>：</p>
<p><img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/20250703155700.png" alt="image.png"></p>
<p>要让这些 “切线空间的局部法线信息” 能用于 <strong>全局光照计算</strong>（比如 Blinn - Phong 模型需要世界空间 / 物体空间的法线），就需要用 <code>[t b N]</code> 组成的矩阵（本质是 “切线空间到目标空间的转换矩阵”），乘以法线贴图里的压缩数据（先解码回 <code>[−1,1]</code> 范围的向量）。</p>
<p>这个乘法的作用是：<strong>把切线空间局部定义的法线向量，转换到与 t,b,N 同属的坐标系</strong>（通常是物体空间或世界空间），让渲染管线能正确计算光照，让 “法线贴图模拟的细节” 能体现在最终渲染结果里。</p>
<blockquote>
<p> 类比：通过乘模型矩阵可以让物体 从 局部坐标 转换 到世界坐标系</p>
</blockquote>
<h3 id="4-2-凹凸贴图-Bump-Maps"><a href="#4-2-凹凸贴图-Bump-Maps" class="headerlink" title="4.2 凹凸贴图 (Bump Maps)"></a>4.2 凹凸贴图 (Bump Maps)</h3><h4 id="4-2-1-介绍"><a href="#4-2-1-介绍" class="headerlink" title="4.2.1 介绍"></a>4.2.1 介绍</h4><p>Bump Mapping 的本质是在<strong>着色阶段（shading stage）</strong> ，通过纹理（如高度图或法线图）对表面法向量进行扰动，让光线反射计算时模拟出凹凸效果，但<strong>模型的实际几何形状（顶点坐标、三角面连接关系）完全不变</strong>。</p>
<ul>
<li>Normal Maps <strong>直接存切线空间的法线向量</strong>，可直接用于光照计算；</li>
<li>Bump Maps <strong>存 “逻辑相对高度”</strong>（可正可负，体现表面凸起 / 凹陷），<strong>利用该高度信息</strong>，再计算出该点法线向量，最后再利用该法线计算光照</li>
</ul>
<p><img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/20250703162853.png" alt="image.png"></p>
<h4 id="4-2-2-从相对高度计算出法线向量"><a href="#4-2-2-从相对高度计算出法线向量" class="headerlink" title="4.2.2 从相对高度计算出法线向量"></a>4.2.2 从相对高度计算出法线向量</h4><p>那么所需要关心的问题就是，如何从相对高度计算出法线向量呢？</p>
<p><img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/20250703163039.png" alt="image.png"></p>
<p><span style="color: #badc58; font-weight: 550;">2 维场景</span></p>
<p><img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/20250703163731.png" alt="image.png"></p>
<p>本质上，这是用<strong>离散的 “高度差” 模拟连续的 “表面斜率”</strong>，再用<strong>斜率调整法线方向</strong>，让 2D 表面的 “凹凸细节” 能通过法线变化体现出来，最终影响渲染的光照效果（比如凸起处更亮、凹陷处更暗 ）。</p>
<p><img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/20250703163312.png" alt="image.png|572"></p>
<p><span style="color: #badc58; font-weight: 550;">3 维情况可以类推得到：</span></p>
<p><img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/20250703163810.png" alt="image.png"></p>
<h3 id="4-3-位移贴图-Displacement-Maps"><a href="#4-3-位移贴图-Displacement-Maps" class="headerlink" title="4.3 位移贴图 (Displacement Maps)"></a>4.3 位移贴图 (Displacement Maps)</h3><ul>
<li><strong>Bump Maps（凹凸贴图）</strong>：<strong>不改变模型顶点</strong>，只是通过 “欺骗法线方向”，让渲染觉得表面有凹凸。模型实际几何（顶点位置）没变，所以阴影边缘相对规整（因为几何没真变，阴影是 “假凹凸” 的投影 ）。</li>
<li><strong>Displacement Maps（位移贴图）</strong>：<strong>真的改变模型顶点</strong>，物理上把表面 “顶起来 / 凹下去”。模型几何实实在在变了，所以阴影边缘会因为真实的高低起伏，变得 “破碎、不规则”（阴影是 “真凹凸” 的投影 ）。</li>
</ul>
<p>Bump Maps 是逻辑上的高度改变，而 Displacement Maps 则是物理上的高度改变，二者的区别就在此处，可以通过物体阴影的边缘发现这点：</p>
<p><img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/20250703164236.png" alt="image.png"></p>
<h3 id="4-4-环境贴图-Environment-Maps"><a href="#4-4-环境贴图-Environment-Maps" class="headerlink" title="4.4 环境贴图 (Environment Maps)"></a>4.4 环境贴图 (Environment Maps)</h3><h4 id="4-4-1-介绍"><a href="#4-4-1-介绍" class="headerlink" title="4.4.1 介绍"></a>4.4.1 介绍</h4><p><strong>环境贴图</strong>，顾名思义就是将环境光存储在一个贴图之上。</p>
<ul>
<li>当光照距离物体极远（如天空、无限远光源 ），物体各点光照方向近似一致 (平行光)，那么唯一的变量就是人眼所观察的方向了；</li>
<li>用 “贴图存储环境光”，让不同观察方向对应贴图上的像素（texel），模拟环境光照效果。</li>
</ul>
<p><span style="color: #badc58; font-weight: 550;">类比理解</span></p>
<ul>
<li>把环境光想象成 “包裹物体的球面光影”，类似镜子反射周围环境 —— 任意 3D 观察方向，都能对应球面上一个点，存储该点颜色即环境光信息。</li>
</ul>
<h4 id="4-4-2-球面映射（Spheremap）"><a href="#4-4-2-球面映射（Spheremap）" class="headerlink" title="4.4.2 球面映射（Spheremap）"></a>4.4.2 球面映射（Spheremap）</h4><p><span style="color: #badc58; font-weight: 550;">原理</span>：像 “地球仪展开成平面地图”，用<strong>墨卡托投影（或类似方法）</strong>，把 “球面环境信息” 转换成<strong>2D 纹理（环境 Texture）</strong>。</p>
<p><img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/20250703165221.png" alt="image.png"></p>
<p><span style="color: #badc58; font-weight: 550;">问题</span>：球面展开后，<strong>上下方会出现严重扭曲</strong>（类似世界地图两极拉伸），影响渲染精度。</p>
<p><img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/20250703165531.png" alt="image.png"></p>
<h4 id="4-4-3-优化方案：Cube-Map（天空盒）"><a href="#4-4-3-优化方案：Cube-Map（天空盒）" class="headerlink" title="4.4.3 优化方案：Cube Map（天空盒）"></a>4.4.3 优化方案：Cube Map（天空盒）</h4><p><img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/20250703165951.png" alt="image.png"></p>
<p>用<strong>6 张纹理（前 / 后 / 左 / 右 / 上 / 下）</strong> 组成 “立方体环境”，替代球面存储环境光。</p>
<p>任意 3D 方向，先判断它 “击中立方体的哪个面”，再计算该面上的 (u, v) 坐标，查对应纹理。</p>
<p><img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/20250703170038.png" alt="image.png"></p>
<p><span style="color: #badc58; font-weight: 550;">Cube Map 坐标计算的核心逻辑</span></p>
<ol>
<li><strong>找面</strong>：比较方向向量分量的绝对值，选最大的轴，确定对应的立方体面（前 / 后 / 左 / 右 / 上 / 下 ）。</li>
<li><strong>求交点</strong>：固定最大分量的轴，计算方向向量与该面的交点坐标。</li>
<li><strong>转纹理坐标</strong>：剔除最大分量的轴，把剩余两轴的坐标从 <code>[-1, 1]</code> 映射到 <code>[0, 1]</code> ，得到 (u, v) 。</li>
</ol>
<p><span style="color: #badc58; font-weight: 550;">示例：</span></p>
<p><img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/20250703170641.png" alt="image.png"></p>
<h4 id="4-4-4-环境贴图在渲染中的应用"><a href="#4-4-4-环境贴图在渲染中的应用" class="headerlink" title="4.4.4 环境贴图在渲染中的应用"></a>4.4.4 环境贴图在渲染中的应用</h4><p><strong>1、光线追踪场景</strong>：当光线没撞击物体时，用<strong>光线方向</strong>查环境贴图的 (u, v) 坐标，返回环境颜色（模拟 “光线射向无穷远环境” 的效果 ）。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">trace_ray(ray, scene) &#123;</span><br><span class="line">    <span class="keyword">if</span> (surface = scene.intersect(ray)) &#123;</span><br><span class="line">        <span class="keyword">return</span> surface.shade(ray)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        u, v = spheremap_coords(r.direction) <span class="comment">// 球面映射坐标</span></span><br><span class="line">        <span class="keyword">return</span> texture_lookup(scene.env_map, u, v)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>2、Blinn - Phong 模型</strong>：在基础漫反射、高光反射外，<strong>增加 “环境映射反射项”</strong>—— 用<strong>观察方向的反射方向</strong>查环境贴图，模拟物体反射环境光的效果。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">shade_fragment(view_dir, normal) &#123;</span><br><span class="line">    out_color = diffuse_shading(k_d, normal) </span><br><span class="line">    out_color += specular_shading(k_s, view_dir, normal)</span><br><span class="line">    u, v = spheremap_coords(reflect(view_dir, normal)) <span class="comment">// 反射方向查环境</span></span><br><span class="line">    out_color += k_m * texture_lookup(environment_map, u, v) </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-5-阴影贴图-Shadow-Maps"><a href="#4-5-阴影贴图-Shadow-Maps" class="headerlink" title="4.5 阴影贴图 (Shadow Maps)"></a>4.5 阴影贴图 (Shadow Maps)</h3><h4 id="4-5-1-阴影贴图的核心原理"><a href="#4-5-1-阴影贴图的核心原理" class="headerlink" title="4.5.1 阴影贴图的核心原理"></a>4.5.1 阴影贴图的核心原理</h4><p>阴影的本质是 <strong>“摄像机可见，但光源不可见的区域”</strong> 。</p>
<p>阴影贴图通过<strong>两步渲染 + 深度对比</strong>，模拟这种效果：</p>
<p><span style="color: #badc58; font-weight: 550;">Pass 1：从光源视角渲染深度（生成阴影贴图）</span></p>
<ul>
<li>把<strong>光源当 “摄像机”</strong>，渲染整个场景，记录每个像素从光源出发的深度值 $d_{map}$（即<strong>阴影贴图</strong> ）。</li>
<li>作用：存储 “光源能看到的场景深度”，后续用于判断 “哪些区域对光源可见”。</li>
</ul>
<blockquote>
<p> 注意：这里的光源只针对<strong>点光源</strong></p>
</blockquote>
<p><img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/20250703171715.png" alt="image.png"></p>
<p><span style="color: #badc58; font-weight: 550;">Pass 2：从摄像机视角渲染场景 + 阴影判断</span></p>
<ul>
<li><strong>Pass 2A</strong>：正常从摄像机视角渲染场景，得到每个可见点的位置。</li>
<li><strong>Pass 2B</strong>：将这些可见点，用 “光源视角的投影矩阵” 重新投影回光源，得到 “该点在光源视角下的深度”。</li>
</ul>
<p><img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/20250703171837.png" alt="image.png"></p>
<p><span style="color: #badc58; font-weight: 550;">深度对比</span></p>
<ul>
<li><p>若 “投影回光源的深度” ≈  $d_{map}$​​ 的深度 → 该点<strong>能被光源照射</strong>（不在阴影中 ）。如下图黄线：<br><img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/20250703172306.png" alt="image.png"></p>
</li>
<li><p>若 “投影回光源的深度” ＞ $d_{map}$​​ 的深度 → 该点<strong>被遮挡</strong>（在阴影中 ）。如下图红线：<br><img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/20250703172327.png" alt="image.png"></p>
</li>
</ul>
<p>如此便能确定每个可见像素点是否在阴影之中了，如果在阴影之中就不去计算 Blinn-Phong 中的镜面反射项与漫反射项。效果如下图：</p>
<p><img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/20250703172416.png" alt="image.png"></p>
<p>对应可视化的 <code>shadow maps</code> 如下，距离光源越近代表深度越小，所以颜色越黑，反之亦然：</p>
<p><img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/20250703172433.png" alt="image.png"></p>
<h4 id="4-5-2-阴影贴图的缺陷与细节"><a href="#4-5-2-阴影贴图的缺陷与细节" class="headerlink" title="4.5.2 阴影贴图的缺陷与细节"></a>4.5.2 阴影贴图的缺陷与细节</h4><ul>
<li><strong>浮点数精度问题</strong>：直接对比 “深度相等” 容易出错，需设置<strong>容差（tolerance）</strong> 避免误判。</li>
<li><strong>边缘失真</strong>：查询阴影贴图时<strong>不做双线性插值</strong>，只取最近点。因为倘若<strong>插值发生在物体边缘时</strong>，与邻接点的深度差距很大，会导致插值结果会有很大的误差</li>
<li><strong>硬阴影局限</strong>：仅适用于<strong>点光源</strong>，阴影边缘 “一刀切”（无过渡 ），不够真实（现实中光源有体积，会产生 “半影（Penumbra）” 软过渡 ）。</li>
</ul>
<p>软硬阴影示意如下，上方棱角分明为硬阴影，下方为软阴影：</p>
<p><img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/20250703172731.png" alt="image.png"></p>
<p>现实中，光源有体积（如太阳、灯泡 ），会导致：</p>
<ul>
<li><strong>本影（Umbra）</strong>：完全被遮挡，看不到光源的区域（硬阴影 ）。</li>
<li><strong>半影（Penumbra）</strong>：能看到部分光源的区域（软阴影，边缘有过渡 ）。</li>
</ul>
<p>阴影贴图因 “<strong>假设光源是点</strong>”，只能模拟硬阴影；软阴影需要更复杂的算法（如区域光源采样、光线追踪 ），但计算成本更高。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://VernalScenery.github.io">Scenery</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://vernalscenery.github.io/2025/07/01/%E5%9B%BE%E5%BD%A2%E5%AD%A6/Games101/06_GAMES101_%E7%9D%80%E8%89%B2/">https://vernalscenery.github.io/2025/07/01/%E5%9B%BE%E5%BD%A2%E5%AD%A6/Games101/06_GAMES101_%E7%9D%80%E8%89%B2/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://VernalScenery.github.io" target="_blank">春和景明的记事本</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/GAMES101/">GAMES101</a></div><div class="post_share"><div class="social-share" data-image="/./img/1.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2025/07/03/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E5%9F%BA%E7%A1%80%E5%8E%9F%E7%90%86/00_%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0_%E6%A6%82%E8%A7%88%E3%80%81%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/" title="00_机器学习_概览、环境搭建"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">00_机器学习_概览、环境搭建</div></div></a></div><div class="next-post pull-right"><a href="/2025/06/30/%E5%9B%BE%E5%BD%A2%E5%AD%A6/Games101/05_GAMES101_%E5%85%89%E6%A0%85%E5%8C%96/" title="05_GAMES101_光栅化"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">05_GAMES101_光栅化</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2025/06/26/%E5%9B%BE%E5%BD%A2%E5%AD%A6/Games101/02_GAMES101_%E5%90%91%E9%87%8F%E4%B8%8E%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/" title="02_GAMES101_向量与线性代数"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2025-06-26</div><div class="title">02_GAMES101_向量与线性代数</div></div></a></div><div><a href="/2025/06/26/%E5%9B%BE%E5%BD%A2%E5%AD%A6/Games101/01_GAMES101_%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E6%A6%82%E8%BF%B0/" title="01_GAMES101_计算机图形学概述"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2025-06-26</div><div class="title">01_GAMES101_计算机图形学概述</div></div></a></div><div><a href="/2025/07/10/%E5%9B%BE%E5%BD%A2%E5%AD%A6/Games101/01_GAMES101%E6%80%BB%E7%BB%93%E7%89%88_%E7%A9%BA%E9%97%B4%E5%8F%98%E6%8D%A2/" title="01_GAMES101总结版_空间变换"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2025-07-10</div><div class="title">01_GAMES101总结版_空间变换</div></div></a></div><div><a href="/2025/06/26/%E5%9B%BE%E5%BD%A2%E5%AD%A6/Games101/03_GAMES101_%E5%8F%98%E6%8D%A2(%E4%BA%8C%E7%BB%B4%E4%B8%8E%E4%B8%89%E7%BB%B4)/" title="03_GAMES101_变换(二维与三维)"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2025-06-26</div><div class="title">03_GAMES101_变换(二维与三维)</div></div></a></div><div><a href="/2025/07/11/%E5%9B%BE%E5%BD%A2%E5%AD%A6/Games101/02_GAMES101%E6%80%BB%E7%BB%93%E7%89%88_%E5%85%89%E6%A0%85%E5%8C%96/" title="02_GAMES101总结版_光栅化"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2025-07-11</div><div class="title">02_GAMES101总结版_光栅化</div></div></a></div><div><a href="/2025/06/30/%E5%9B%BE%E5%BD%A2%E5%AD%A6/Games101/05_GAMES101_%E5%85%89%E6%A0%85%E5%8C%96/" title="05_GAMES101_光栅化"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2025-06-30</div><div class="title">05_GAMES101_光栅化</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/./img/1.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Scenery</div><div class="author-info__description">今天不想跑，所以才去跑</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">73</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">14</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/chjm0121" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="/1595718686@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%9D%80%E8%89%B2-Shading-%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-text">着色 (Shading) 的定义</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%9D%80%E8%89%B2%E6%A8%A1%E5%9E%8B"><span class="toc-text">着色模型</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E5%86%AF%E6%B0%8F%E5%85%89%E7%85%A7%E6%A8%A1%E5%9E%8B"><span class="toc-text">1 冯氏光照模型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-Shading-is-Local"><span class="toc-text">2 Shading is Local</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E6%BC%AB%E5%8F%8D%E5%B0%84-Diffuse-Reflection"><span class="toc-text">3 漫反射 (Diffuse Reflection)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-%E6%A6%82%E8%A7%88"><span class="toc-text">3.1 概览</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-%E5%8F%82%E6%95%B0%E5%AE%9A%E4%B9%89"><span class="toc-text">3.2 参数定义</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-1-%E7%9D%80%E8%89%B2%E7%82%B9%E5%AE%9E%E9%99%85%E6%8E%A5%E6%94%B6%E7%9A%84%E5%85%89%E8%83%BD%E9%87%8F"><span class="toc-text">3.2.1 着色点实际接收的光能量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-2-%E5%85%89%E7%BA%BF%E8%A1%B0%E5%87%8F"><span class="toc-text">3.2.2 光线衰减</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-%E6%BC%AB%E5%8F%8D%E5%B0%84%E5%85%89%E7%85%A7%E5%85%AC%E5%BC%8F"><span class="toc-text">3.3 漫反射光照公式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-%E5%AF%B9%E4%B8%8D%E5%90%8C%E5%85%89%E6%BA%90%E7%B1%BB%E5%9E%8B%E7%9A%84%E9%80%82%E7%94%A8%E6%80%A7"><span class="toc-text">3.4 对不同光源类型的适用性</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E9%95%9C%E9%9D%A2%E9%AB%98%E5%85%89-Specular"><span class="toc-text">4 镜面高光 (Specular)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E7%8E%AF%E5%A2%83%E5%85%89-Ambient"><span class="toc-text">5 环境光 (Ambient)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E4%B8%89%E9%A1%B9%E5%8F%A0%E5%8A%A0"><span class="toc-text">6 三项叠加</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%9D%80%E8%89%B2%E9%A2%91%E7%8E%87-Shading-Frequencies"><span class="toc-text">着色频率 (Shading Frequencies)</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E4%B8%89%E7%A7%8D%E6%96%B9%E6%A1%88"><span class="toc-text">1 三种方案</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E6%B3%95%E7%BA%BF%E8%AE%A1%E7%AE%97"><span class="toc-text">2 法线计算</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E5%B9%B3%E9%9D%A2%E6%B3%95%E7%BA%BF%E8%AE%A1%E7%AE%97"><span class="toc-text">2.1 平面法线计算</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-%E9%A1%B6%E7%82%B9%E6%B3%95%E7%BA%BF%E8%AE%A1%E7%AE%97"><span class="toc-text">2.2 顶点法线计算</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-%E9%80%90%E5%83%8F%E7%B4%A0%E6%B3%95%E5%90%91%E9%87%8F"><span class="toc-text">2.3 逐像素法向量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-%E6%A8%A1%E5%9E%8B%E5%8F%98%E6%8D%A2%E5%AF%B9%E6%B3%95%E7%BA%BF%E5%90%91%E9%87%8F%E7%9A%84%E5%BD%B1%E5%93%8D"><span class="toc-text">2.4 模型变换对法线向量的影响</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9B%BE%E5%BD%A2%E7%AE%A1%E7%BA%BF"><span class="toc-text">图形管线</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BA%B9%E7%90%86%E6%98%A0%E5%B0%84-Texture-Mapping"><span class="toc-text">纹理映射 (Texture Mapping)</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E6%A6%82%E8%A7%88"><span class="toc-text">1 概览</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E9%87%8D%E5%BF%83%E5%9D%90%E6%A0%87"><span class="toc-text">2 重心坐标</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E4%B8%89%E8%A7%92%E5%BD%A2%E6%8F%92%E5%80%BC"><span class="toc-text">2.1 三角形插值</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-1-Why%EF%BC%88%E4%B8%BA%E5%95%A5%E8%A6%81%E6%8F%92%E5%80%BC%EF%BC%89"><span class="toc-text">2.1.1 Why（为啥要插值）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-2-What%EF%BC%88%E6%8F%92%E5%80%BC%E5%95%A5%E5%86%85%E5%AE%B9%EF%BC%89"><span class="toc-text">2.1.2 What（插值啥内容）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-3-How%EF%BC%88%E5%92%8B%E6%8F%92%E5%80%BC%EF%BC%89"><span class="toc-text">2.1.3 How（咋插值）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-%E5%9F%BA%E7%A1%80%E5%AE%9A%E4%B9%89"><span class="toc-text">2.2 基础定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-%E5%87%A0%E4%BD%95%E9%9D%A2%E7%A7%AF%E8%A7%92%E5%BA%A6%E6%B1%82%E8%A7%A3"><span class="toc-text">2.3 几何面积角度求解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-%E5%9D%90%E6%A0%87%E7%B3%BB%E8%A7%92%E5%BA%A6%E6%B1%82%E8%A7%A3"><span class="toc-text">2.4 坐标系角度求解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5-%E5%A6%82%E4%BD%95%E7%94%A8%E9%87%8D%E5%BF%83%E5%9D%90%E6%A0%87%E5%81%9A%E6%8F%92%E5%80%BC"><span class="toc-text">2.5 如何用重心坐标做插值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-6-%E9%87%8D%E5%BF%83%E5%9D%90%E6%A0%87%E5%9C%A8%E6%8A%95%E5%BD%B1%E5%8F%98%E6%8D%A2%E4%B8%8B%E4%B8%8D%E5%85%B7%E6%9C%89%E4%B8%8D%E5%8F%98%E6%80%A7"><span class="toc-text">2.6 重心坐标在投影变换下不具有不变性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-7-%E9%80%8F%E8%A7%86%E6%A0%A1%E6%AD%A3%E6%8F%92%E5%80%BC"><span class="toc-text">2.7 透视校正插值</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-7-1-%E9%97%AE%E9%A2%98%E6%9D%A5%E6%BA%90%EF%BC%9A%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E2%80%9C%E6%A0%A1%E6%AD%A3%E2%80%9D%EF%BC%9F"><span class="toc-text">2.7.1 问题来源：为什么要“校正”？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-7-2-%E5%85%AC%E5%BC%8F%E6%8E%A8%E5%AF%BC"><span class="toc-text">2.7.2 公式推导</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-7-3-%E6%8E%A8%E5%B9%BF%E5%88%B0%E4%BB%BB%E6%84%8F%E5%B1%9E%E6%80%A7%EF%BC%88%E6%B7%B1%E5%BA%A6%E3%80%81%E4%BA%AE%E5%BA%A6%E3%80%81%E7%BA%B9%E7%90%86%E7%AD%89%EF%BC%89"><span class="toc-text">2.7.3 推广到任意属性（深度、亮度、纹理等）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B7%B1%E5%BA%A6-Z-t-%E7%9A%84%E7%9F%AB%E6%AD%A3%E6%8F%92%E5%80%BC"><span class="toc-text">深度 $Z_t$ 的矫正插值</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%BB%E6%84%8F%E5%B1%9E%E6%80%A7-I-t-%E7%9A%84%E7%9F%AB%E6%AD%A3%E6%8F%92%E5%80%BC"><span class="toc-text">任意属性 $I_t$ 的矫正插值</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-7-4-%E9%80%8F%E8%A7%86%E6%A0%A1%E6%AD%A3%E7%9A%84%E6%A0%B8%E5%BF%83%E6%80%9D%E6%83%B3"><span class="toc-text">2.7.4 透视校正的核心思想</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-7-5-%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-text">2.7.5 应用场景</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E7%BA%B9%E7%90%86%E5%B0%BA%E5%AF%B8%E4%B8%8E%E6%98%BE%E7%A4%BA%E9%9C%80%E6%B1%82%E4%B8%8D%E5%8C%B9%E9%85%8D"><span class="toc-text">3 纹理尺寸与显示需求不匹配</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-%E7%BA%B9%E7%90%86%E8%BF%87%E5%B0%8F"><span class="toc-text">3.1 纹理过小</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-1-%E9%97%AE%E9%A2%98"><span class="toc-text">3.1.1 问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-2-%E5%8F%8C%E7%BA%BF%E6%80%A7%E6%8F%92%E5%80%BC-Bilinear-Interpolation"><span class="toc-text">3.1.2 双线性插值 (Bilinear Interpolation)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-3-%E4%B8%89%E7%A7%8D%E6%96%B9%E6%B3%95%E5%AF%B9%E6%AF%94"><span class="toc-text">3.1.3 三种方法对比</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-%E7%BA%B9%E7%90%86%E8%BF%87%E5%A4%A7"><span class="toc-text">3.2 纹理过大</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-1-%E9%97%AE%E9%A2%98"><span class="toc-text">3.2.1 问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-2-%E5%88%9D%E6%AD%A5%E8%A7%A3%E6%B3%95%E4%B8%8E%E7%BC%BA%E9%99%B7%EF%BC%88%E8%B6%85%E9%87%87%E6%A0%B7-Supersampling%EF%BC%89"><span class="toc-text">3.2.2 初步解法与缺陷（超采样 Supersampling）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-3-Mipmap"><span class="toc-text">3.2.3 Mipmap</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-4-%E5%90%84%E5%90%91%E5%BC%82%E6%80%A7%E8%BF%87%E6%BB%A4-Mipmap"><span class="toc-text">3.2.4 各向异性过滤 Mipmap</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E7%BA%B9%E7%90%86%E6%98%A0%E5%B0%84%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-text">4 纹理映射的应用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-%E6%B3%95%E7%BA%BF%E8%B4%B4%E5%9B%BE-Normal-Maps"><span class="toc-text">4.1 法线贴图 (Normal Maps)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-1-%E6%B3%95%E7%BA%BF%E8%B4%B4%E5%9B%BE%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-text">4.1.1 法线贴图的作用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-2-%E6%B3%95%E7%BA%BF%E4%BF%A1%E6%81%AF%E5%AD%98%E5%82%A8%E6%96%B9%E5%BC%8F"><span class="toc-text">4.1.2 法线信息存储方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-3-%E5%88%87%E7%BA%BF%E7%A9%BA%E9%97%B4%E5%9D%90%E6%A0%87%E7%B3%BB%E7%9A%84%E6%B1%82%E8%A7%A3"><span class="toc-text">4.1.3 切线空间坐标系的求解</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-%E5%87%B9%E5%87%B8%E8%B4%B4%E5%9B%BE-Bump-Maps"><span class="toc-text">4.2 凹凸贴图 (Bump Maps)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-1-%E4%BB%8B%E7%BB%8D"><span class="toc-text">4.2.1 介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-2-%E4%BB%8E%E7%9B%B8%E5%AF%B9%E9%AB%98%E5%BA%A6%E8%AE%A1%E7%AE%97%E5%87%BA%E6%B3%95%E7%BA%BF%E5%90%91%E9%87%8F"><span class="toc-text">4.2.2 从相对高度计算出法线向量</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-%E4%BD%8D%E7%A7%BB%E8%B4%B4%E5%9B%BE-Displacement-Maps"><span class="toc-text">4.3 位移贴图 (Displacement Maps)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-4-%E7%8E%AF%E5%A2%83%E8%B4%B4%E5%9B%BE-Environment-Maps"><span class="toc-text">4.4 环境贴图 (Environment Maps)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-4-1-%E4%BB%8B%E7%BB%8D"><span class="toc-text">4.4.1 介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-4-2-%E7%90%83%E9%9D%A2%E6%98%A0%E5%B0%84%EF%BC%88Spheremap%EF%BC%89"><span class="toc-text">4.4.2 球面映射（Spheremap）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-4-3-%E4%BC%98%E5%8C%96%E6%96%B9%E6%A1%88%EF%BC%9ACube-Map%EF%BC%88%E5%A4%A9%E7%A9%BA%E7%9B%92%EF%BC%89"><span class="toc-text">4.4.3 优化方案：Cube Map（天空盒）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-4-4-%E7%8E%AF%E5%A2%83%E8%B4%B4%E5%9B%BE%E5%9C%A8%E6%B8%B2%E6%9F%93%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-text">4.4.4 环境贴图在渲染中的应用</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-5-%E9%98%B4%E5%BD%B1%E8%B4%B4%E5%9B%BE-Shadow-Maps"><span class="toc-text">4.5 阴影贴图 (Shadow Maps)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-5-1-%E9%98%B4%E5%BD%B1%E8%B4%B4%E5%9B%BE%E7%9A%84%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86"><span class="toc-text">4.5.1 阴影贴图的核心原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-5-2-%E9%98%B4%E5%BD%B1%E8%B4%B4%E5%9B%BE%E7%9A%84%E7%BC%BA%E9%99%B7%E4%B8%8E%E7%BB%86%E8%8A%82"><span class="toc-text">4.5.2 阴影贴图的缺陷与细节</span></a></li></ol></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/07/29/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E5%9F%BA%E7%A1%80%E5%8E%9F%E7%90%86/13_%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0_%E6%A6%82%E7%8E%87%E5%9B%BE%E6%A8%A1%E5%9E%8B/" title="13_机器学习_概率图模型">13_机器学习_概率图模型</a><time datetime="2025-07-29T00:29:02.000Z" title="发表于 2025-07-29 08:29:02">2025-07-29</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/07/28/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E5%9F%BA%E7%A1%80%E5%8E%9F%E7%90%86/11_%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0_%E8%81%9A%E7%B1%BB/" title="11_机器学习_聚类">11_机器学习_聚类</a><time datetime="2025-07-28T00:19:53.000Z" title="发表于 2025-07-28 08:19:53">2025-07-28</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/07/28/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E5%9F%BA%E7%A1%80%E5%8E%9F%E7%90%86/12_%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0_%E9%99%8D%E7%BB%B4/" title="12_机器学习_降维">12_机器学习_降维</a><time datetime="2025-07-27T20:48:42.000Z" title="发表于 2025-07-28 04:48:42">2025-07-28</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/07/26/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E5%9F%BA%E7%A1%80%E5%8E%9F%E7%90%86/10_%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0_%E9%9B%86%E6%88%90%E5%AD%A6%E4%B9%A0/" title="10_机器学习_集成学习">10_机器学习_集成学习</a><time datetime="2025-07-26T01:58:53.000Z" title="发表于 2025-07-26 09:58:53">2025-07-26</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/07/25/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E5%9F%BA%E7%A1%80%E5%8E%9F%E7%90%86/09_%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0_%E6%9C%B4%E7%B4%A0%E8%B4%9D%E5%8F%B6%E6%96%AF/" title="09_机器学习_朴素贝叶斯">09_机器学习_朴素贝叶斯</a><time datetime="2025-07-25T03:08:47.000Z" title="发表于 2025-07-25 11:08:47">2025-07-25</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('/./img/1.jpg')"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2025 By Scenery</div><div class="footer_custom_text"><div>波澜不惊</div><div class="footer-div"><img class="footer-icon" src="./img/备案图标.png"><a class="footer-a" target="_blank" rel="noopener" href="http://beian.miit.gov.cn/">皖ICP备2021016944号-1</a></div></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.13.0"></script><script src="/js/main.js?v=4.13.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@5.2.0/instantpage.min.js" type="module"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=4.13.0"></script></div></div></body></html>