<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>02_GAMES101总结版_光栅化 | 春和景明的记事本</title><meta name="author" content="Scenery"><meta name="copyright" content="Scenery"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="1 Bresenham 直线绘制算法1.1 问题问题：给定两点 $P_1(x_0,y_0)$ 到 $P_2(x_1,y_1)$，如何在屏幕像素空间绘制一条直线 先讲最简单情况：  $x_0&amp;lt;x_1$ 斜率 $m$ 满足： $0 \le m \le 1$，即线段从左往右、向上偏但不陡   设："><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://vernalscenery.github.io/2025/07/11/%E5%9B%BE%E5%BD%A2%E5%AD%A6/Games101/02_GAMES101%E6%80%BB%E7%BB%93%E7%89%88_%E5%85%89%E6%A0%85%E5%8C%96/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=4.13.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '02_GAMES101总结版_光栅化',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2025-08-05 14:17:12'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><link rel="stylesheet" href="/css/style.css"><meta name="generator" content="Hexo 5.4.2"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/./img/1.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">73</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">13</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/./img/1.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="春和景明的记事本"><span class="site-name">春和景明的记事本</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">02_GAMES101总结版_光栅化</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-07-10T19:29:51.000Z" title="发表于 2025-07-11 03:29:51">2025-07-11</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-08-05T06:17:12.000Z" title="更新于 2025-08-05 14:17:12">2025-08-05</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">8k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>25分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="02_GAMES101总结版_光栅化"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="1-Bresenham-直线绘制算法"><a href="#1-Bresenham-直线绘制算法" class="headerlink" title="1 Bresenham 直线绘制算法"></a>1 Bresenham 直线绘制算法</h2><h3 id="1-1-问题"><a href="#1-1-问题" class="headerlink" title="1.1 问题"></a>1.1 问题</h3><p><span style="color: #badc58; font-weight: 550;">问题</span>：给定两点 $P_1(x_0,y_0)$ 到 $P_2(x_1,y_1)$，如何在屏幕像素空间绘制一条直线</p>
<p>先讲最简单情况：</p>
<ol>
<li>$x_0&lt;x_1$</li>
<li>斜率 $m$ 满足： $0 \le m \le 1$，即线段从左往右、向上偏但不陡</li>
</ol>
<p><img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/20250711154307.png" alt="image.png"></p>
<p>设：</p>
<ul>
<li>起点为 $(x_0, y_0)$，终点为 $(x_1, y_1)$</li>
<li>直线斜率 $m = \frac{dy}{dx}$</li>
</ul>
<p>每次 x 加 1，根据直线与像素中心之间的距离决定 y 是否加 1：</p>
<p><img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/20250711154451.png" alt="image.png|399"></p>
<h3 id="1-2-前置知识"><a href="#1-2-前置知识" class="headerlink" title="1.2 前置知识"></a>1.2 前置知识</h3><p>给定直线起始点 $P_1(x_0,y_0)$ 和 $P_2(x_1,y_1)$，<strong>定义两个向量</strong>：</p>
<p><img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/20250712095542.png" alt="image.png"></p>
<p>那么这两个向量的叉积就是：</p>
<p><img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/20250712095618.png" alt="image.png"></p>
<p>对于当前点：</p>
<ul>
<li>若它在线的左边，叉积为正（逆时针方向）-&gt; 即<strong>直线在点的下方</strong></li>
<li>若它在线的右边，叉积为负（顺时针方向）-&gt; 即<strong>直线在点的下方</strong></li>
<li>若正好在线上，叉积为 0 → 共线</li>
</ul>
<p>我们反转一下方向，加个负号，更加符合直觉</p>
<p><img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/20250712095644.png" alt="image.png"></p>
<ul>
<li>$F(x,y) &gt; 0$：直线在点的上方 -&gt; 点亮上方的像素</li>
<li>$F(x,y) &lt; 0$：直线在点的下方 -&gt; 点亮下方的像素</li>
</ul>
<p>并且 $\vec{D} \times \vec{P}$：是两向量张成平行四边形的面积（带正负号）</p>
<p>故 $F(x,y)$ 的值是在衡量：“当前路径点与理想直线之间的<strong>偏差</strong>”，即向上偏离了还是还在下边。</p>
<ul>
<li>它不是几何意义上的“最短距离”</li>
<li>但它的值越大，说明我们越偏离直线 → 需要“修正”</li>
</ul>
<h3 id="1-3-具体推导"><a href="#1-3-具体推导" class="headerlink" title="1.3 具体推导"></a>1.3 具体推导</h3><p>先判断起始点所在的像素位置，即先对浮点数取整</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x0 = <span class="title class_">Math</span>.<span class="title function_">round</span>(x0)</span><br><span class="line">y0 = <span class="title class_">Math</span>.<span class="title function_">round</span>(y0)</span><br><span class="line">x1 = <span class="title class_">Math</span>.<span class="title function_">round</span>(x1)</span><br><span class="line">y1 = <span class="title class_">Math</span>.<span class="title function_">round</span>(y1)</span><br></pre></td></tr></table></figure>

<p>令 $Δx = x_1 - x_0,  Δy = y_1-y_0$ </p>
<p>我们定义一个“误差函数”：</p>
<blockquote>
<p>这里的输入值 $(x,y)$ 是当前正在测试的像素格子的坐标</p>
</blockquote>
<p><img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/20250712095644.png" alt="image.png"></p>
<ul>
<li>如果 $F(x,y)&gt;0$，说明理想直线在像素中心的<strong>上方</strong>，应该选择 $y+1$ 的点</li>
<li>如果 $F(x,y)&lt;0$，说明理想直线在像素中心<strong>下方</strong>，保持当前 y</li>
<li>因为 $x,x_0​,y,y_0​$ 都是像素坐标，故这个式子完全是整数计算 </li>
</ul>
<p>对于任意像素点 $(x,y)$，我们要判断下一个点是 $(x+1,y)$, 还是 $(x+1,y+1)$，我们可以取这两点的中点，即 $(x+1,y+0.5)$</p>
<p><img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/20250712104216.png" alt="image.png|224"></p>
<p>代入误差函数：</p>
<p><img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/20250712103512.png" alt="image.png"></p>
<p>乘以 2 消除小数：</p>
<p><img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/20250712103532.png" alt="image.png"></p>
<p>得到：</p>
<p><img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/20250712103545.png" alt="image.png"></p>
<p>特别地，当 $x=x_0, y = y_0​$ 时，就是第一步判断：</p>
<p><img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/20250712103623.png" alt="image.png"></p>
<p>在第 k 步之后，如果当前误差项为 $d_k$，我们要判断下一个点。</p>
<p><img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/20250712105026.png"></p>
<blockquote>
<p> 关注 $x_k$ 和 $y_k$ 之前的系数</p>
</blockquote>
<p>即每次 x 增加 1，对应：</p>
<ul>
<li>$+2Δy$（x 越多，y 期望越高）</li>
<li>若我们不跳 $y$，就积累误差</li>
<li>若我们跳 $y+1$，就减去 $2Δx$ 的误差</li>
</ul>
<p>故：</p>
<p><img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/20250712105219.png" alt="image.png|520"></p>
<p>具体代码实现如下</p>
<p><img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/20250712110313.png" alt="image.png"></p>
<h3 id="1-4-特殊情况的转换"><a href="#1-4-特殊情况的转换" class="headerlink" title="1.4 特殊情况的转换"></a>1.4 特殊情况的转换</h3><p>上面只是考虑了斜率 <em>0≤m≤1， x1&lt;x2</em> 的情况，实际还有下面七种情形：</p>
<p><img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/20250712110751.png" alt="image.png"></p>
<p>实际只需要写一个“第一象限<strong>缓坡</strong>”的核心算法，其他 7 个方向都可以通过坐标交换、方向反转等预处理转换成这种情况，从而实现统一处理。</p>
<p>流程如下图：</p>
<table>
<thead>
<tr>
<th>阶段</th>
<th>做的事</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><strong>1. 输入预处理（转换进来）</strong></td>
<td>交换点、交换 x/y、翻转方向</td>
<td>把所有线段统一成“向右、缓坡”</td>
</tr>
<tr>
<td><strong>2. 执行标准算法</strong></td>
<td>只处理 <code>x++</code> 情况，y 按误差判断</td>
<td>最核心、最简洁的算法</td>
</tr>
<tr>
<td><strong>3. 绘制时转换回去</strong></td>
<td>还原坐标（比如：如果之前交换了 x/y，就画成 y,x）</td>
<td>保证画出的像素是用户原始线段的路径</td>
</tr>
</tbody></table>
<p>下面是常见“转化逻辑”总结表：</p>
<table>
<thead>
<tr>
<th>步骤 (Step)</th>
<th>判断条件 (Condition to Check)</th>
<th>处理方式 (Action to Take)</th>
<th>目的与效果 (Purpose &amp; Effect)</th>
</tr>
</thead>
<tbody><tr>
<td><strong>1</strong></td>
<td><code>x₁ &gt; x₂</code>  <br>(线段从右向左)</td>
<td>交换起点 <code>(x₁, y₁)</code> 与终点 <code>(x₂, y₂)</code></td>
<td>**确保绘图方向总是从左到右 (<code>dx ≥ 0</code>)**。  <br>这是所有后续判断的基础。</td>
</tr>
<tr>
<td><strong>2</strong></td>
<td><code>y₁ &gt; y₂</code>  <br>(在上一步处理后，线段方向依然向下)</td>
<td>设定 Y 轴步进方向 <code>stepY = -1</code><br>(默认值为 <code>+1</code>)</td>
<td><strong>确定 Y 轴的移动方向</strong>。  <br>核心算法中只需执行 <code>y += stepY</code>，无需再关心 <code>dy</code> 的正负。</td>
</tr>
<tr>
<td><strong>3</strong></td>
<td><code>|dy| &gt; dx</code> (斜率的 m 绝对值大于 1)</td>
<td>设定为陡坡模式 <code>is_steep = true</code>。在核心算法中，将 <code>dx</code> 与 <code>|dy|</code> 的角色互换。</td>
<td><strong>统一主驱动轴</strong>。确保主驱动轴的增量 (<code>d_major</code>) 总是大于等于次驱动轴 (<code>d_minor</code>)，此时 Y 成为主轴。<br></td>
</tr>
</tbody></table>
<p><img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/20250712113010.png" alt="image.png"></p>
<h2 id="2-三角形光栅化算法"><a href="#2-三角形光栅化算法" class="headerlink" title="2 三角形光栅化算法"></a>2 三角形光栅化算法</h2><h3 id="2-1-采样"><a href="#2-1-采样" class="headerlink" title="2.1 采样"></a>2.1 采样</h3><p><img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/20250630105202.png" alt="image.png"></p>
<p>一种简单方法：<strong>采样</strong> </p>
<p>把连续的函数 <code>f(x)</code> ，转成离散的数组 <code>output</code> ，完成 “离散化” 。比如 <code>f(x)</code> 是一条曲线，采样后变成一系列离散的点，方便计算机存储、处理 。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> x = <span class="number">0</span>; x &lt; xmax; ++x)</span><br><span class="line">    output[x] = f(x);</span><br></pre></td></tr></table></figure>

<p><span style="color: #badc58; font-weight: 550;">具体实现：</span></p>
<p><img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/20250630110003.png" alt="image.png|320"></p>
<p><img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/20250630110012.png" alt="image.png|318"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> x = <span class="number">0</span>; x &lt; xmax; ++x) <span class="comment">// 遍历屏幕 X 方向的像素 </span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> y = <span class="number">0</span>; y &lt; ymax; ++y) <span class="comment">// 遍历屏幕 Y 方向的像素 </span></span><br><span class="line">		image[x][y] = inside(tri, x + <span class="number">0.5</span>, y + <span class="number">0.5</span>); <span class="comment">// 判断 (x+0.5, y+0.5) 是否在三角形 tri 内</span></span><br></pre></td></tr></table></figure>

<ul>
<li>像素的坐标 <code>(x, y)</code> 是整数（离散的像素网格 ），但像素本身是 “小方块”，为了精准判断，通常用<strong>像素中心</strong> <code>(x + 0.5, y + 0.5)</code> 作为采样点 。</li>
</ul>
<h3 id="2-2-inSide-的实现"><a href="#2-2-inSide-的实现" class="headerlink" title="2.2 inSide 的实现"></a>2.2 inSide 的实现</h3><h4 id="2-2-1-判断点-x-y-是否在三角形内"><a href="#2-2-1-判断点-x-y-是否在三角形内" class="headerlink" title="2.2.1 判断点 (x, y) 是否在三角形内"></a>2.2.1 判断点 (x, y) 是否在三角形内</h4><p><img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/20250630110449.png" alt="image.png"></p>
<p>判断点 <code>Q</code> 是否在三角形 <code>P₀P₁P₂</code> 内部，可以通过计算<strong>三个边对应的叉积</strong>，根据叉积的符号判断点在边的哪一侧，从而确定是否在三角形内 。</p>
<p>若三角形是<strong>逆时针顺序</strong>（<code>P₀→P₁→P₂→P₀</code> ），则：</p>
<ul>
<li>点 <code>Q</code> 在三角形<strong>内部</strong> → 三个叉积的符号<strong>全部相同</strong>（都正或都负，取决于边的方向定义 ）。</li>
<li>点 <code>Q</code> 在三角形<strong>外部</strong> → 至少有一个叉积的符号与其他不同 。</li>
</ul>
<h3 id="2-3-包围盒-性能优化"><a href="#2-3-包围盒-性能优化" class="headerlink" title="2.3 包围盒 (性能优化)"></a>2.3 包围盒 (性能优化)</h3><blockquote>
<p> 用包围盒（Bounding Box）减少需要判断的像素数量</p>
</blockquote>
<p><img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/20250630111025.png" alt="image.png"></p>
<ul>
<li>先找到三角形的<strong>最小包围盒</strong>（轴对齐矩形，由三角形顶点的最小 / 最大 X、Y 坐标确定 ）。</li>
<li>只遍历包围盒内的像素（蓝色矩形内的像素 ），而非整个屏幕。这样能大幅减少需要判断的像素数量，提升效率 。</li>
</ul>
<p><span style="color: #badc58; font-weight: 550;">包围盒的计算方法: </span></p>
<ul>
<li><strong>X 范围</strong>：取三角形三个顶点 X 坐标的最小值（<code>min(P₀.x, P₁.x, P₂.x)</code> ）和最大值（<code>max(P₀.x, P₁.x, P₂.x)</code> ），作为包围盒的左右边界 。</li>
<li><strong>Y 范围</strong>：取三角形三个顶点 Y 坐标的最小值（<code>min(P₀.y, P₁.y, P₂.y)</code> ）和最大值（<code>max(P₀.y, P₁.y, P₂.y)</code> ），作为包围盒的上下边界 。</li>
</ul>
<h3 id="2-4-采样带来的问题"><a href="#2-4-采样带来的问题" class="headerlink" title="2.4 采样带来的问题"></a>2.4 采样带来的问题</h3><p><img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/20250630141607.png" alt="image.png|552"></p>
<ul>
<li><p><strong>锯齿（Jaggies）</strong>：是空间采样（比如图像像素采样 ）时，因采样不足，使斜线、边缘等呈现锯齿状不光滑的视觉问题。<br><img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/20250630112121.png" alt="image.png"></p>
</li>
<li><p><strong>莫尔条纹（Moire）</strong>：图像欠采样（采样频率低于信号频率要求 ）引发，如下图里衬衫纹理叠加出现的干涉条纹，就是典型的莫尔现象。<br><img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/20250630141445.png" alt="image.png"></p>
</li>
<li><p><strong>车轮效应（Wagon wheel effect）</strong>：属于时间采样问题，比如视频里车轮转动，因采样帧率等问题，看起来像车轮倒转或转动异常，生活中拍摄旋转物体易出现。<br><img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/%E5%B1%8F%E5%B9%95%E5%BD%95%E5%88%B6-%E5%AE%9A%E5%88%B6%E5%8A%A8%E4%BD%9C%E8%81%94%E7%B3%BBQQ1783420665-%E4%BD%9C%E8%80%85Mcc-2025-06-30-14-15-02.gif" alt="2025-06-30-14-15-02.gif"></p>
</li>
</ul>
<p><span style="color: #badc58; font-weight: 550;">混叠伪像的本质原因：</span></p>
<p>信号变化过快（高频信号，比如快速运动、细密纹理 ），但采样速度跟不上（采样频率低 ），就会让采样后的信号无法真实还原原始信号，产生视觉或听觉等层面的伪像，这在图形渲染、视频处理等领域是需重视和解决的问题，常通过提高采样率、抗锯齿算法（如超采样抗锯齿等 ）来改善 。</p>
<h2 id="3-抗锯齿-反走样（Anti-Aliasing）"><a href="#3-抗锯齿-反走样（Anti-Aliasing）" class="headerlink" title="3 抗锯齿 / 反走样（Anti-Aliasing）"></a>3 抗锯齿 / 反走样（Anti-Aliasing）</h2><h3 id="3-1-混叠-走样-Aliasing"><a href="#3-1-混叠-走样-Aliasing" class="headerlink" title="3.1 混叠 / 走样 (Aliasing)"></a>3.1 混叠 / 走样 (Aliasing)</h3><p><strong>频率越高的信号，需要越快的采样频率才能正确还原</strong>。若采样频率不够，高频信号会被错误识别成低频信号（混叠，Aliasing） 。</p>
<p><img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/20250630171912.png" alt="image.png"></p>
<ul>
<li>**横轴 <code>x</code>**：代表信号的 “空间位置”（如图像像素位置）或 “时间”（如声音的时间轴 ），体现信号的分布维度。</li>
<li><strong>纵轴</strong>：代表信号的 “振幅”，可理解为信号的强度，比如声音的音量大小、图像像素的亮度值 。</li>
<li>从 <code>f1​(x)</code> 到 <code>f5​(x)</code> ，曲线越来越 “密集”，意味着信号频率逐渐升高 。<ul>
<li><code>f1</code>​ 是<strong>低频信号</strong>，曲线最稀疏，完成一个周期所需的 x 长度长，频率低 。</li>
<li><code>f5</code>​ 是<strong>高频信号</strong>，曲线最密集，完成一个周期所需的 x 长度短，频率高 。</li>
</ul>
</li>
</ul>
<p>欠采样（Undersampling）会导致频率混叠（Frequency Aliases）</p>
<blockquote>
<p> 采样频率不够时，高频信号的采样点会 “伪装” 成低频信号，产生 “频率混叠”（高频和低频变得无法区分 ）</p>
</blockquote>
<p><img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/20250630172344.png" alt="image.png"></p>
<h3 id="3-2-傅里叶级数"><a href="#3-2-傅里叶级数" class="headerlink" title="3.2 傅里叶级数"></a>3.2 傅里叶级数</h3><p>将一个函数表示为正弦和余弦函数的加权和</p>
<p>这是傅里叶变换的本质：任何复杂的周期函数（或满足一定条件的非周期函数），都可以分解为不同频率的正弦波（Sine）和余弦波（Cosine）的线性组合，每个波的 “权重”（系数）反映其在原函数中的贡献。</p>
<blockquote>
<p> 傅里叶级数是用来处理“<strong>周期性</strong>”信号的，傅里叶变换是用来处理“<strong>非周期性</strong>”信号的</p>
</blockquote>
<p><img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/20250630173924.png" alt="image.png"></p>
<ul>
<li><strong>第一行（最稀疏）</strong>：<br>  单个低频余弦波（棕色曲线） + 原始函数（黑色方框）。<br>  此时仅用 1 个频率成分近似，误差大，波形与方框差异明显。</li>
<li><strong>第二行</strong>：<br>  叠加 1 个高频余弦波（绿色曲线）。<br>  波形更接近方框，但边缘仍有明显波动。</li>
<li><strong>第三行</strong>：<br>  叠加更多高频余弦波（青色、蓝色等）。<br>  波形进一步逼近方框，边缘更平滑。</li>
<li><strong>第四行（最密集）</strong>：<br>  叠加大量高频余弦波，波形几乎完全贴合黑色方框。</li>
</ul>
<h3 id="3-3-傅里叶变换"><a href="#3-3-傅里叶变换" class="headerlink" title="3.3 傅里叶变换"></a>3.3 傅里叶变换</h3><p>想象你面前有一杯混合果汁，里面有苹果、橙子、菠萝的味道，但你不知道每种水果占多少。傅里叶变换就像一个 “吸管过滤器”，能把混合果汁拆开，告诉你里面每种水果的 “浓度”</p>
<ul>
<li>在<strong>声音</strong>里，它能把交响乐拆成小提琴（高频）、鼓（低频）的单独声音；</li>
<li>在<strong>图像</strong>里，它能把一张照片拆成 “大面积色块”（低频）和 “边缘细节”（高频）。 </li>
</ul>
<p><strong>本质</strong>：把复杂的东西变成简单的组合，方便分析和处理。</p>
<h4 id="3-3-1-转换公式"><a href="#3-3-1-转换公式" class="headerlink" title="3.3.1 转换公式"></a>3.3.1 转换公式</h4><p><img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/20250630173628.png" alt="image.png"></p>
<p>傅里叶变换的本质是 “域转换”：把空间域（或时域）的信号 f(x)，分解为频率域的频率成分 F(ω)；反之，逆变换可从频率域恢复空间域信号。</p>
<ul>
<li>信号 <code>f(x)</code> 是我们直观看到的形式，比如：<ul>
<li>图像：x 是像素的空间坐标，f(x) 是像素的颜色 / 亮度。</li>
<li>声音：x 是时间，f(x) 是声音的振幅（音量）。</li>
</ul>
</li>
<li><code>F(ω)</code> 表示信号的频率成分，ω 是频率（单位：Hz 或弧度 / 秒），F(ω) 的幅值表示该频率成分的强度。</li>
</ul>
<h4 id="3-3-2-时域和频域"><a href="#3-3-2-时域和频域" class="headerlink" title="3.3.2 时域和频域"></a>3.3.2 时域和频域</h4><ul>
<li><p><strong>时域（原始视角）</strong>：<br>  信号以 “时间” 或 “空间位置” 为横轴，直接展示信号的变化过程。</p>
<ul>
<li>例：<ul>
<li>声音波形（时域）：横轴是时间，纵轴是空气振动幅度（音量），能看到声音的高低起伏。</li>
<li>图像（空间域，类似时域）：横轴 / 纵轴是像素坐标，像素值是颜色或亮度，能看到物体的形状和细节。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>频域（傅里叶变换后的视角）</strong>：<br>  信号以 “频率” 为横轴，纵轴表示该频率成分的<strong>强度（幅值）</strong>，揭示信号的 “内在构成”。</p>
<ul>
<li>核心逻辑：<ul>
<li>任何复杂信号都可分解为不同频率的正弦波 / 余弦波的叠加（傅里叶级数 / 变换的本质）。</li>
<li>频域中每个点对应一个特定频率的简单波，强度表示该频率在原始信号中的 “贡献度”。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/20250630171859.png" alt="image.png"></p>
<h4 id="3-3-3-低频和高频"><a href="#3-3-3-低频和高频" class="headerlink" title="3.3.3 低频和高频"></a>3.3.3 低频和高频</h4><p><span style="color: #badc58; font-weight: 550;">低频成分（频域左侧）</span></p>
<ul>
<li><strong>定义</strong>：频率低（变化缓慢）的信号成分，对应时域 / 空间域中 “大范围、平缓变化” 的部分。</li>
<li><strong>图形学中的表现</strong>：<ul>
<li>图像：大面积均匀色块（如天空、墙面）、模糊背景，像素值变化小。</li>
<li>声音：低沉的鼓声、长音，振动频率低（如 20-200 Hz）。</li>
</ul>
</li>
<li><strong>频域特征</strong>：<ul>
<li>靠近频率轴原点（左侧），强度集中在低频率区间。</li>
<li>示例：一幅纯色背景的图像，频域中低频区域（中心）强度高，高频区域几乎无值。</li>
</ul>
</li>
</ul>
<p><span style="color: #badc58; font-weight: 550;"> 高频成分（频域右侧）</span></p>
<ul>
<li><strong>定义</strong>：频率高（变化快速）的信号成分，对应时域 / 空间域中 “局部、剧烈变化” 的部分。</li>
<li><strong>图形学中的表现</strong>：<ul>
<li>图像：物体边缘、纹理细节（如毛发、树叶脉络）、噪声（如数码照片的颗粒感），像素值突变。</li>
<li>声音：尖锐的高音、短促的打击声，振动频率高（如 2000-20000 Hz）。</li>
</ul>
</li>
<li><strong>频域特征</strong>：<ul>
<li>远离频率轴原点（右侧），强度分布在高频率区间。</li>
<li>示例：一张清晰的建筑照片，频域中高频区域（边缘）强度高，反映建筑线条的锐利细节。</li>
</ul>
</li>
</ul>
<p><img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/20250630173812.png" alt="image.png"></p>
<ul>
<li><p>低频信号（红色曲线）提供 “基础框架”（类似图像的宏观轮廓）；</p>
</li>
<li><p>高频信号（彩色曲线）叠加在框架上，提供 “波动细节”（类似图像的微观纹理）。</p>
</li>
<li><p>低频对应的 “轮廓” 是<strong>宏观形状</strong>（如人物的整体外框、建筑的大致形状），由缓慢变化的像素值构成。</p>
</li>
<li><p>高频对应的 “细节” 是<strong>微观纹理</strong>（如边缘的锯齿、毛发的细微起伏），由快速变化的像素值构成。</p>
</li>
</ul>
<h3 id="3-4-滤波-Filtering"><a href="#3-4-滤波-Filtering" class="headerlink" title="3.4 滤波 (Filtering)"></a>3.4 滤波 (Filtering)</h3><p><img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/20250630175153.png" alt="image.png"></p>
<ul>
<li><strong>中心亮斑</strong>：对应图像的<strong>低频成分</strong>（像素值变化缓慢的区域）。<ul>
<li>低频成分决定了图像的<strong>整体轮廓和背景</strong>（如人物的大致形状、背景的模糊区域）。</li>
<li>中心亮斑越亮、范围越大，说明图像的低频成分越强（即图像整体越平滑）。</li>
</ul>
</li>
<li><strong>四周的放射状亮点</strong>：对应图像的<strong>高频成分</strong>（像素值变化剧烈的区域）。<ul>
<li>高频成分决定了图像的<strong>细节和边缘</strong>（如头发的纹理、衣物的褶皱、手指的轮廓）。</li>
<li>放射状亮点越分散、越亮，说明图像的高频成分越强（即图像细节越丰富）。</li>
</ul>
</li>
</ul>
<p><span style="color: #badc58; font-weight: 550;">高通滤波器</span></p>
<ul>
<li>允许<strong>高频成分</strong>通过（保留图像的边缘、细节）。</li>
<li>阻止<strong>低频成分</strong>通过（过滤图像的平滑背景、大块颜色）。</li>
</ul>
<p><img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/20250630175200.png" alt="image.png"></p>
<p><span style="color: #badc58; font-weight: 550;">低通滤波器</span></p>
<ul>
<li>允许<strong>低频成分</strong>通过（保留图像的平滑背景、大块颜色）。</li>
<li>阻止<strong>高频成分</strong>通过（过滤图像的边缘、细节）。</li>
</ul>
<p><img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/20250630175204.png" alt="image.png"></p>
<p><span style="color: #badc58; font-weight: 550;">过滤低频和高频成分（仅保留中间频率）</span></p>
<ul>
<li>阻止<strong>低频成分</strong>（图像的平滑背景、大块颜色）通过。</li>
<li>阻止<strong>高频成分</strong>（图像的边缘、细节）通过。</li>
<li>仅保留<strong>中间频率成分</strong>（图像中变化适中的区域）。</li>
</ul>
<p><img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/20250630175212.png" alt="image.png"></p>
<p><img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/20250630175218.png" alt="image.png"></p>
<h3 id="3-5-卷积-Convolution"><a href="#3-5-卷积-Convolution" class="headerlink" title="3.5 卷积 (Convolution)"></a>3.5 卷积 (Convolution)</h3><p><img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/20250630180852.png" alt="image.png"></p>
<ul>
<li><strong>滤波（Filtering）</strong>：对信号（如图像、声音）进行处理，改变其频率成分（如模糊、锐化、去噪）。</li>
<li><strong>卷积（Convolution）</strong>：一种数学运算，通过 “滑动窗口加权求和” 实现信号变换。<br><img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/20250630180923.png" alt="image.png"></li>
<li><strong>平均（Averaging）</strong>：最基础的卷积操作之一，通过 “窗口内像素值平均” 实现模糊效果。</li>
</ul>
<h4 id="3-5-1-空间域卷积-↔-频率域乘法"><a href="#3-5-1-空间域卷积-↔-频率域乘法" class="headerlink" title="3.5.1 空间域卷积 ↔ 频率域乘法"></a>3.5.1 空间域卷积 ↔ 频率域乘法</h4><p><span style="color: #badc58; font-weight: 550;">核心等式：</span>空间域的<strong>卷积</strong> ≡ 频率域的<strong>乘法</strong>，反之亦然：频率域的<strong>卷积</strong> ≡ 空间域的<strong>乘法</strong></p>
<p><img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/20250630181244.png" alt="image.png"></p>
<p><span style="color: #badc58; font-weight: 550;">两种滤波方案：</span></p>
<p><img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/20250630181218.png" alt="image.png"></p>
<h4 id="3-5-2-方框滤波器"><a href="#3-5-2-方框滤波器" class="headerlink" title="3.5.2 方框滤波器"></a>3.5.2 方框滤波器</h4><p><img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/20250630181457.png" alt="image.png"></p>
<ul>
<li><strong>核的数值</strong>：所有元素均为 1（表示对窗口内像素平等加权）。</li>
<li><strong>归一化系数</strong>：1/9（因 3x3 核共有 9 个元素，求和为 9，需除以 9 保证亮度不变）。</li>
<li><strong>效果</strong>：图像变模糊（平滑），因为每个像素被周围像素的平均值替代，削弱了高频成分（边缘、细节）。</li>
</ul>
<p><span style="color: #badc58; font-weight: 550;">方框函数是一种低通滤波器</span></p>
<p><img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/20250630181647.png" alt="image.png"></p>
<ul>
<li><strong>左侧</strong>：空间域的方框函数</li>
<li><strong>右侧</strong>：对左侧方框函数进行<strong>傅里叶变换</strong>后的<strong>频率域表示</strong>，展示其频率成分的分布。</li>
</ul>
<p><span style="color: #badc58; font-weight: 550;">更宽的滤波器核 → 过滤更低频率</span></p>
<blockquote>
<p> 滤波器核的宽度决定了其在频率域中 “允许通过的频率范围”—— 核越宽，频率域中 “中心低频区” 越窄，意味着<strong>更低的频率才能通过</strong>，高频被更强烈地削弱</p>
</blockquote>
<p><img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/20250630181842.png" alt="image.png"></p>
<h3 id="3-6-采样-重复频率成分"><a href="#3-6-采样-重复频率成分" class="headerlink" title="3.6 采样 = 重复频率成分"></a>3.6 采样 = 重复频率成分</h3><p><img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/20250701094908.png" alt="image.png"></p>
<ul>
<li><strong>(e) 时域</strong>：<ul>
<li>s(t) 是<strong>采样后的离散信号</strong>（比如数字信号），由 “原始信号 xa​(t) 与时域采样脉冲 Pδ​(t) 相乘” 得到（s(t)=xa​(t)⋅Pδ​(t) ）。</li>
<li>直观看：原始信号被 “采样脉冲”“打点”，变成离散的样本点（蓝色箭头高度是采样值，红色虚线是原始信号辅助理解）。</li>
</ul>
</li>
<li><strong>(f) 频域</strong>：<ul>
<li>S(f) 是采样后信号的频谱，根据<strong>傅里叶变换的 “时域相乘 = 频域卷积”</strong> ，原始频谱 Xa​(f) 会和采样脉冲的频谱 Pδ​(f) 做 “卷积运算”。</li>
<li>结果就是：<strong>原始频谱 Xa​(f) 会以 fs​ 为间隔，不断重复出现</strong>（图里橙色、绿色、蓝色的频谱形状，都是原始频谱的 “复制粘贴” ）。</li>
</ul>
</li>
</ul>
<p>采样的本质，是通过 “采样脉冲的频谱特性”，让原始信号的频谱 <strong>以采样频率 fs​ 为周期，无限重复</strong>（Repeating Frequency Contents）。</p>
<p>如果原始信号是 “带限” 的（最高频率 f0​ ），且满足 <strong>采样定理（<code>fs​≥2f0</code>​ ，奈奎斯特采样条件）</strong> ，这些重复的频谱就不会 “重叠”，后续可以用滤波器把原始频谱 “提取” 出来，恢复信号；如果不满足采样定理，频谱重叠会导致 <strong>混叠（Aliasing）</strong> ，信号就无法正确恢复啦～</p>
<p>下图直观展示了 <strong>混叠（Aliasing）</strong> 的成因，核心逻辑是：<strong>采样频率不足时，信号的频率成分会相互重叠混合（Mixed Frequency Contents）</strong></p>
<p><img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/20250701095104.png" alt="image.png"></p>
<p>当采样频率过低（不满足奈奎斯特条件 Fs​≥2fmax​ ），信号重复的频谱会<strong>重叠混合</strong>，原本清晰的频率成分被 “混淆”，这就是 “Aliasing = Mixed Frequency Contents” 的含义</p>
<h3 id="3-7-反走样的思路"><a href="#3-7-反走样的思路" class="headerlink" title="3.7 反走样的思路"></a>3.7 反走样的思路</h3><p><img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/20250701095530.png" alt="image.png"></p>
<p>减少混叠的本质，就是<strong>让 “重复的频谱” 不重叠</strong>：</p>
<ul>
<li>方法 1（硬刚）：提高采样率 → 拉大频谱间隔，避免重叠。</li>
<li>方法 2（智取）：采样前过滤高频 → 让频谱本身变窄，即使间隔不变，也不容易重叠</li>
</ul>
<p>简单类比：</p>
<ul>
<li>方法 1 像 “把马路拓宽”，让车（频谱）有更多空间，不挤在一起；</li>
<li>方法 2 像 “限制大车（高频信号）上路”，即使马路窄，小车（低频）也不容易堵～</li>
</ul>
<p><img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/20250701095814.png" alt="image.png"></p>
<p>抗锯齿的关键是 <strong>“先处理高频，再采样”</strong> ：</p>
<ul>
<li><strong>盒式模糊</strong>（卷积）通过 “局部平均” 过滤高频边缘 → 让信号满足奈奎斯特条件（采样率适配信号频率） → 采样后边缘平滑</li>
</ul>
<p><img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/20250701100120.png" alt="image.png"></p>
<p>抗锯齿的本质是<strong>用 “覆盖面积比例” 代替 “非黑即白” 的判断</strong>：</p>
<ul>
<li>规则采样（无抗锯齿）：像素要么全黑（覆盖），要么全白（不覆盖） → 锯齿。</li>
<li>平均像素值（抗锯齿）：像素颜色 = 覆盖面积比例 × 图形颜色 + (1 - 覆盖比例) × 背景颜色 → 过渡色，边缘平滑。</li>
</ul>
<p><img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/20250701100320.png" alt="image.png"></p>
<h3 id="3-8-超采样"><a href="#3-8-超采样" class="headerlink" title="3.8 超采样"></a>3.8 超采样</h3><ul>
<li>盒式滤波器（1 - pixel box filter）的作用是<strong>模糊图像边缘（低通滤波）</strong> ，让采样后的边缘更平滑（抗锯齿）。</li>
<li>超采样的思路：<strong>不直接做滤波</strong>，而是<strong>在一个像素内采多个点</strong>，再把这些点的颜色 “平均”，效果上近似盒式滤波的模糊。</li>
</ul>
<p><img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/20250701100715.png" alt="image.png"></p>
<ul>
<li><strong>采样</strong>：在一个像素的区域内，选多个采样点（图中是 4×4 = 16 个点，即 “4x4 supersampling” ）。</li>
<li><strong>平均</strong>：把这些采样点的颜色值求平均，作为最终像素的颜色。</li>
<li><strong>等价性</strong>：<br>  多次采样 + 平均 ≈ 盒式滤波（模糊），因为本质都是<strong>让像素颜色包含 “周围区域的信息”</strong> ，避免 “非黑即白” 的硬采样，弱化锯齿。</li>
</ul>
<p><img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/20250701100937.png" alt="image.png"></p>
<p>超采样的结果，是让显示器输出的像素颜色<strong>根据 “三角形覆盖比例” 渐变</strong>，本质是用 “颜色比例” 模拟 “边缘的平滑过渡”，实现抗锯齿。</p>
<p><img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/20250701100803.png" alt="image.png"></p>
<h3 id="3-9-抗锯齿技术演进"><a href="#3-9-抗锯齿技术演进" class="headerlink" title="3.9 抗锯齿技术演进"></a>3.9 抗锯齿技术演进</h3><h4 id="3-9-1-MSAA"><a href="#3-9-1-MSAA" class="headerlink" title="3.9.1 MSAA"></a>3.9.1 MSAA</h4><p>传统超采样（如 SSAA，Super Sample Anti - Aliasing）会对每个采样点<strong>单独进行着色计算</strong>（如纹理采样、光照计算），导致计算量随采样率呈平方增长（如 4×4 采样需 16 倍计算）。</p>
<p>MSAA（Multisample Anti - Aliasing）是超采样的优化版，通过 “着色计算复用”，将最耗时的渲染逻辑（如复杂光照模型、高频纹理采样）从 16 次降至 1 次，仅保留必要的几何覆盖判断，从而在几乎不损失画质的前提下大幅降低计算成本。</p>
<ul>
<li><strong>采样阶段</strong>：在像素内进行多采样（如 4×4 子像素点），记录每个采样点的 “几何覆盖信息”（是否在三角形内）。</li>
<li><strong>着色阶段</strong>：<strong>复用像素内所有采样点的着色结果</strong>，仅对像素中心或特定点进行一次着色计算，然后将结果 “广播” 给所有采样点。</li>
<li><strong>优势</strong>：减少着色计算次数，仅保留几何覆盖的采样成本，计算量从 “O (N²)” 降至 “O (N)”（N 为采样倍数）。</li>
</ul>
<p><img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/20250701102441.png" alt="image.png"></p>
<ul>
<li>传统超采样（SSAA）：16 次着色 → 16 个颜色值 → 平均。</li>
<li>MSAA：1 次着色 + 16 次覆盖判断 → 按覆盖比例混合颜色。</li>
</ul>
<h4 id="3-9-2-其他技术"><a href="#3-9-2-其他技术" class="headerlink" title="3.9.2 其他技术"></a>3.9.2 其他技术</h4><p><img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/20250701102557.png" alt="image.png"></p>
<p><span style="color: #badc58; font-weight: 550;">抗锯齿技术演进（Milestones）</span></p>
<ul>
<li><strong>FXAA（Fast Approximate AA）</strong>：<br>  FXAA 是一种<strong>屏幕空间后处理抗锯齿技术</strong>，与传统基于采样的抗锯齿方法（如 MSAA）不同，它<strong>不依赖渲染阶段的多采样数据</strong>，而是<strong>直接对渲染完成的图像进行后期处理</strong>，通过<strong>边缘检测和模糊算法</strong>快速弱化锯齿。</li>
<li><strong>TAA（Temporal AA）</strong>：<br>  “时间抗锯齿” → 利用<strong>帧间信息</strong>（相邻帧的采样结果）抗锯齿，减少每帧的采样量，平衡性能和画质，但可能导致 “运动模糊” 或 “幽灵效应”。</li>
</ul>
<p><span style="color: #badc58; font-weight: 550;">超分辨率 / 超采样（Super resolution /super sampling）</span></p>
<p>计算机图形渲染中，<strong>低分辨率显示的核心缺陷是 “采样不足”</strong>：</p>
<ul>
<li>显示器像素密度低 → 无法捕捉图像中的高频细节（如锐利边缘、精细纹理）→ 采样频率低于信号最高频率 → 导致<strong>混叠（Aliasing）</strong>，表现为锯齿、摩尔纹等失真。</li>
<li><strong>超分辨率与超采样的共同目标</strong>：通过技术手段 “模拟高分辨率效果”，弥补采样不足，减少混叠。</li>
</ul>
<p>二者对比：</p>
<ul>
<li><strong>超采样（SS/MSAA）</strong>：适用于硬件性能充裕、追求 “零伪像” 的场景（如高端游戏主机、影视渲染），通过多采样直接提升信号带宽。</li>
<li><strong>超分辨率（DLSS/FSR）</strong>：适用于性能受限设备，以算法弥补采样不足，是当下 “高帧率 + 高画质” 的最优解。</li>
</ul>
<p><span style="color: #badc58; font-weight: 550;">未来趋势</span></p>
<ul>
<li><strong>未来趋势</strong>：深度学习与传统采样结合（如 DLSS 3.0 引入光流网络预测运动，减少帧间闪烁），进一步提升重建效率与真实性。</li>
<li><strong>DLSS（Deep Learning Super Sampling）</strong>：<br>  “深度学习超采样” → 用<strong>AI 模型</strong>学习 “低分辨率 → 高分辨率” 的映射关系，用少量采样 + 神经网络重建高清图像，平衡性能和画质，是当下前沿的抗锯齿 / 超分方案。</li>
</ul>
<h2 id="4-背面剔除"><a href="#4-背面剔除" class="headerlink" title="4 背面剔除"></a>4 背面剔除</h2><h3 id="4-1-原理：什么是背面？"><a href="#4-1-原理：什么是背面？" class="headerlink" title="4.1 原理：什么是背面？"></a>4.1 原理：什么是背面？</h3><p>一个三角形的“正面”定义为<strong>顶点按逆时针顺序排列（CCW）</strong>所形成的面（默认情况下）。相反，如果顶点按<strong>顺时针顺序（CW）</strong>排列，则为背面。</p>
<p>渲染时，如果一个三角形面向摄像机（可见），它在屏幕空间中的投影仍保持其顶点排列顺序；而如果背对摄像机，顶点顺序在投影后会反转。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 开启剔除</span></span><br><span class="line">gl.<span class="title function_">enable</span>(gl.<span class="property">CULL_FACE</span>);</span><br><span class="line"><span class="comment">// 设置剔除模式（默认剔除背面）</span></span><br><span class="line">gl.<span class="title function_">cullFace</span>(gl.<span class="property">BACK</span>);</span><br><span class="line"><span class="comment">// 设置正面顶点绕序（默认是 gl.CCW，即逆时针）</span></span><br><span class="line">gl.<span class="title function_">frontFace</span>(gl.<span class="property">CCW</span>);</span><br></pre></td></tr></table></figure>

<h3 id="4-2-判断方法-：顶点绕序-面法线"><a href="#4-2-判断方法-：顶点绕序-面法线" class="headerlink" title="4.2 判断方法 ：顶点绕序 + 面法线"></a>4.2 判断方法 ：顶点绕序 + 面法线</h3><p>背面剔除发生在<strong>裁剪空间 → 屏幕空间</strong>阶段之间：</p>
<ul>
<li>给定三角形三个顶点 $v_0, v_1, v_2$，计算边向量：$e1 = v1 - v0，e2 = v2 - v0$</li>
<li>求<strong>屏幕空间法线</strong>的 Z 分量（因为在 2D 中你只能看到其“方向”）：$crossZ = e1.x * e2.y - e1.y * e2.x$</li>
<li>如果 <code>crossZ &lt; 0</code>，说明为顺时针（三角形背对摄像机）。</li>
</ul>
<p><img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/20250711150948.png" alt="image.png"></p>
<p>具体代码如下： </p>
<p><img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/20250711151034.png" alt="image.png"></p>
<h2 id="5-深度测试-Z-buffering"><a href="#5-深度测试-Z-buffering" class="headerlink" title="5 深度测试 (Z-buffering)"></a>5 深度测试 (Z-buffering)</h2><h3 id="5-1-画家算法-Painter’s-Algorithm"><a href="#5-1-画家算法-Painter’s-Algorithm" class="headerlink" title="5.1 画家算法 (Painter’s Algorithm)"></a>5.1 画家算法 (Painter’s Algorithm)</h3><blockquote>
<p> 模仿现实中画家作画逻辑 —— 画家会先画远景（比如背景的山），再画近景（比如前景的树 ），后画的内容会覆盖 / 遮挡先画的部分。</p>
</blockquote>
<p>在计算机图形学里，它遵循 <strong>“从后往前绘制（Paint from back to front）”</strong> 规则，把远处的物体先渲染到帧缓冲区（framebuffer），再渲染近处物体，新内容直接覆盖缓冲区里已有的、被遮挡的旧内容 ，以此模拟真实视觉里 “近景遮挡远景” 的效果。</p>
<p><img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/20250701110104.png" alt="image.png"></p>
<p>画家算法<strong>需要先对物体按 “深度” 排序</strong>（比如离观察者远 / 近），排序的时间复杂度是 **O(n log n)**（n 是三角形数量，经典排序算法如快速排序、归并排序的复杂度 ）。只有排好序，才能按照 “从后往前（远→近）” 的顺序绘制，让近的物体覆盖远的，模拟遮挡。</p>
<p><img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/20250701110210.png" alt="image.png"></p>
<p>上图中交叉的三角形 P、Q、R：它们相互穿插、遮挡，不存在一个绝对的 “谁远谁近” 顺序（比如 P 部分在 Q 前，Q 部分在 R 前，R 部分又在 P 前 ）。这种情况下，单纯靠 “排序后从后往前画” 的逻辑，无法正确渲染出遮挡关系 —— 不管怎么排，都会出现错误覆盖，导致画面失真。</p>
<h3 id="5-2-Z-Buffer（深度缓冲区）算法"><a href="#5-2-Z-Buffer（深度缓冲区）算法" class="headerlink" title="5.2 Z - Buffer（深度缓冲区）算法"></a>5.2 Z - Buffer（深度缓冲区）算法</h3><blockquote>
<p> Z - Buffer 是计算机图形学里<strong>成为主流的深度测试算法</strong>，解决了画家算法（Painter’s Algorithm）遇到的复杂遮挡难题，成为渲染管线里判断 “物体可见性”（谁该显示、谁该被遮挡）的经典方案。</p>
</blockquote>
<h4 id="5-2-1-整体思路"><a href="#5-2-1-整体思路" class="headerlink" title="5.2.1 整体思路"></a>5.2.1 整体思路</h4><p>为<strong>每个像素（或采样点）存储当前最小的 z 值</strong> 。z 值代表 “深度”（可理解为物体离观察者的距离），<strong>z 越小，物体越近；z 越大，物体越远</strong>。渲染时，新物体的 z 值会和缓冲区里已存的比较，只有 “更小（更近）” 的才会覆盖颜色，保证近的物体遮挡远的。</p>
<p>需要<strong>额外的缓冲区存深度信息</strong> ，它和传统的 “帧缓冲区（frame buffer，存像素颜色）” 配合：</p>
<ul>
<li><code>framebuffer</code> 为颜色缓冲区，存储每个像素最终显示的颜色值（<code>rgb</code>）；</li>
<li><code>zbuffer</code> 为深度缓冲区，存储每个像素当前记录的最小深度值（<code>z</code> 值越小表示物体越近）</li>
</ul>
<blockquote>
<p> 为了方便理解，这里做了简化：假设 z 值<strong>始终是正数</strong> ，且遵循 “z 越小，物体离观察者越近；z 越大，物体离观察者越远” 的规则。</p>
</blockquote>
<p><img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/20250701110440.png" alt="image.png"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 遍历场景中的每个三角形</span></span><br><span class="line"><span class="keyword">for</span> (each triangle T) &#123;</span><br><span class="line">    <span class="comment">// 遍历当前三角形覆盖的每个采样点（像素），获取其屏幕坐标(x,y)和3D深度值z</span></span><br><span class="line">    <span class="keyword">for</span> (each <span class="built_in">sample</span> (x,y,z) in T) &#123;</span><br><span class="line">        <span class="comment">// 比较当前采样点的深度值z与深度缓冲区中记录的该像素原有深度值</span></span><br><span class="line">        <span class="keyword">if</span> (z &lt; zbuffer[x][y]) &#123; <span class="comment">// 如果当前采样点的物体更近（z值更小代表距离观察者更近）</span></span><br><span class="line">            <span class="comment">// 更新该像素的颜色为当前三角形在该位置的颜色</span></span><br><span class="line">            framebuffer[x][y] = rgb; </span><br><span class="line">            <span class="comment">// 更新该像素的深度值为当前采样点的深度值，记录最近物体的深度</span></span><br><span class="line">            zbuffer[x][y] = z; </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 若当前采样点的物体更远（被已记录的更近物体遮挡），不做任何操作</span></span><br><span class="line">            <span class="comment">// do nothing, 该采样点被遮挡，保留原有颜色和深度</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>预先初始化每个像素的深度值为无穷大（表示 “最远”）</p>
<p><img src="https://picgocloud.oss-cn-shanghai.aliyuncs.com/picgo/20250701110714.png" alt="image.png"></p>
<p>Z - Buffer <strong>不需要全局排序</strong>。它靠 “逐像素比较深度”，绕开了对三角形整体排序的过程，所以能达到 O(n) 线性时间复杂度。</p>
<h4 id="5-2-2-关于-Z-值"><a href="#5-2-2-关于-Z-值" class="headerlink" title="5.2.2 关于 Z 值"></a>5.2.2 关于 Z 值</h4><p>在 Z-Buffer 算法流程里，**<code>z</code> 是通过 3D 渲染管线中的 “几何处理” 和 “光栅化” 阶段计算得到的**，以下是关键步骤拆解：</p>
<h5 id="前期：3D-模型与投影变换"><a href="#前期：3D-模型与投影变换" class="headerlink" title="前期：3D 模型与投影变换"></a>前期：3D 模型与投影变换</h5><ol>
<li><p><strong>模型空间 → 世界空间 → 观察空间</strong>：<br>3D 模型最初在 “模型空间”（自身局部坐标系），经坐标变换（如平移、旋转、缩放）到 “世界空间”（场景全局坐标系），再转换到 “观察空间”（以摄像机为原点的坐标系 ）。此时，每个顶点的坐标包含 x,y,z，但 z 是<strong>观察空间下的深度</strong>（比如离摄像机的距离 ）</p>
</li>
<li><p><strong>投影变换（Projection）</strong>：</p>
<ul>
<li>投影矩阵将观察空间坐标转换到<strong>裁剪空间</strong>（Clipping Space）。</li>
<li>通过<strong>透视除法</strong>（除以齐次坐标的 w 分量）得到<strong>归一化设备坐标（NDC）</strong>，范围通常为 <code>[−1,1]3</code>。</li>
<li><strong>z 值处理</strong>：透视除法后，z 值被重新映射到特定范围（如 <code>[0,1]</code> 或 <code>[−1,1]</code>），用于后续深度比较。</li>
</ul>
</li>
</ol>
<h5 id="光栅化阶段：插值计算像素级-z-值"><a href="#光栅化阶段：插值计算像素级-z-值" class="headerlink" title="光栅化阶段：插值计算像素级 z 值"></a>光栅化阶段：插值计算像素级 z 值</h5><ol>
<li><strong>光栅化目标</strong><ul>
<li>将变换后的三角形图元转换为屏幕像素，确定每个像素是否被三角形覆盖（采样），并计算其颜色和深度。</li>
</ul>
</li>
<li><strong>顶点 z 值准备</strong><ul>
<li>三角形的三个顶点已完成前期坐标变换，携带观察空间或裁剪空间下的 z 值（代表深度）。</li>
</ul>
</li>
<li><strong>重心插值计算像素 z 值</strong><ul>
<li>对于三角形覆盖的每个像素采样点 (x,y)，GPU 通过<strong>重心插值算法</strong>，基于三角形顶点的 z 值，计算该像素的<strong>插值深度值</strong>。</li>
<li><strong>本质</strong>：利用顶点深度信息，在三角形内部 “平滑过渡” 生成所有像素的深度，确保深度连续性。</li>
<li><strong>结果</strong>：每个像素获得唯一的 z 值，用于 Z-Buffer 算法的深度比较，判断遮挡关系。</li>
</ul>
</li>
</ol>
<p><span style="color: #badc58; font-weight: 550;">注意：</span>这里对深度 Z 的插值需要<strong>透视矫正</strong></p>
<blockquote>
<p> 在透视投影下，三角形投影到屏幕上发生了非线性变形，顶点的属性（包括 z 值、颜色、纹理坐标等）<strong>在屏幕空间中不再满足线性关系</strong>，普通线性插值会产生误差。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1、顶点阶段</span></span><br><span class="line">out.<span class="property">zOverW</span> = z / w;</span><br><span class="line">out.<span class="property">invW</span> = <span class="number">1</span> / w;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2、重心插值</span></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3、片段阶段</span></span><br><span class="line">float z = zOverW / invW;  <span class="comment">// 透视矫正后的 z 值</span></span><br></pre></td></tr></table></figure>

<h2 id="6-颜色混合"><a href="#6-颜色混合" class="headerlink" title="6 颜色混合"></a>6 颜色混合</h2><h3 id="6-1-基本原理"><a href="#6-1-基本原理" class="headerlink" title="6.1 基本原理"></a>6.1 基本原理</h3><p>颜色混合发生在<strong>片段着色器输出颜色之后</strong>，当一个片段即将写入帧缓冲时：</p>
<p><span style="color: #badc58; font-weight: 550;">核心：</span>WebGL 会将<strong>片段颜色 (source)</strong> 和<strong>帧缓冲已有颜色 (destination)</strong> 按照一定规则组合，得出<strong>最终写入帧缓冲</strong>的颜色。</p>
<h3 id="6-2-混合公式-（标准格式）"><a href="#6-2-混合公式-（标准格式）" class="headerlink" title="6.2 混合公式 （标准格式）"></a>6.2 混合公式 （标准格式）</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">FinalColor</span> = (srcColor × srcFactor) + (dstColor × dstFactor)</span><br></pre></td></tr></table></figure>

<p>每个颜色分量（R、G、B、A）都按此规则独立计算。</p>
<ul>
<li><code>srcColor</code>：当前片段着色器输出的颜色</li>
<li><code>dstColor</code>：帧缓冲中已有颜色</li>
<li><code>srcFactor</code>：源因子（影响片段颜色）</li>
<li><code>dstFactor</code>：目标因子（影响缓冲区颜色）</li>
</ul>
<h3 id="6-3-相关函数实现"><a href="#6-3-相关函数实现" class="headerlink" title="6.3 相关函数实现"></a>6.3 相关函数实现</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gl.<span class="title function_">enable</span>(gl.<span class="property">BLEND</span>); <span class="comment">//  启用混合</span></span><br><span class="line">gl.<span class="title function_">blendFunc</span>(srcFactor, dstFactor); <span class="comment">// 设置混合函数</span></span><br></pre></td></tr></table></figure>

<p><span style="color: #badc58; font-weight: 550;">常用混合因子</span></p>
<table>
<thead>
<tr>
<th>混合因子</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td><code>gl.ZERO</code></td>
<td>0（忽略颜色）</td>
</tr>
<tr>
<td><code>gl.ONE</code></td>
<td>1（不改变）</td>
</tr>
<tr>
<td><code>gl.SRC_ALPHA</code></td>
<td>片段颜色的 alpha</td>
</tr>
<tr>
<td><code>gl.ONE_MINUS_SRC_ALPHA</code></td>
<td>1 - alpha</td>
</tr>
<tr>
<td><code>gl.DST_ALPHA</code></td>
<td>帧缓冲区颜色的 alpha</td>
</tr>
<tr>
<td><code>gl.ONE_MINUS_DST_ALPHA</code></td>
<td>1 - 目标 alpha</td>
</tr>
</tbody></table>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://VernalScenery.github.io">Scenery</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://vernalscenery.github.io/2025/07/11/%E5%9B%BE%E5%BD%A2%E5%AD%A6/Games101/02_GAMES101%E6%80%BB%E7%BB%93%E7%89%88_%E5%85%89%E6%A0%85%E5%8C%96/">https://vernalscenery.github.io/2025/07/11/%E5%9B%BE%E5%BD%A2%E5%AD%A6/Games101/02_GAMES101%E6%80%BB%E7%BB%93%E7%89%88_%E5%85%89%E6%A0%85%E5%8C%96/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://VernalScenery.github.io" target="_blank">春和景明的记事本</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/GAMES101/">GAMES101</a></div><div class="post_share"><div class="social-share" data-image="/./img/1.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2025/07/14/%E5%9B%BE%E5%BD%A2%E5%AD%A6/Games101/08_GAMES101_%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA_01/" title="08_GAMES101_光线追踪_01"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">08_GAMES101_光线追踪_01</div></div></a></div><div class="next-post pull-right"><a href="/2025/07/10/%E5%9B%BE%E5%BD%A2%E5%AD%A6/Games101/01_GAMES101%E6%80%BB%E7%BB%93%E7%89%88_%E7%A9%BA%E9%97%B4%E5%8F%98%E6%8D%A2/" title="01_GAMES101总结版_空间变换"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">01_GAMES101总结版_空间变换</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2025/06/26/%E5%9B%BE%E5%BD%A2%E5%AD%A6/Games101/01_GAMES101_%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E6%A6%82%E8%BF%B0/" title="01_GAMES101_计算机图形学概述"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2025-06-26</div><div class="title">01_GAMES101_计算机图形学概述</div></div></a></div><div><a href="/2025/06/26/%E5%9B%BE%E5%BD%A2%E5%AD%A6/Games101/02_GAMES101_%E5%90%91%E9%87%8F%E4%B8%8E%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/" title="02_GAMES101_向量与线性代数"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2025-06-26</div><div class="title">02_GAMES101_向量与线性代数</div></div></a></div><div><a href="/2025/07/10/%E5%9B%BE%E5%BD%A2%E5%AD%A6/Games101/01_GAMES101%E6%80%BB%E7%BB%93%E7%89%88_%E7%A9%BA%E9%97%B4%E5%8F%98%E6%8D%A2/" title="01_GAMES101总结版_空间变换"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2025-07-10</div><div class="title">01_GAMES101总结版_空间变换</div></div></a></div><div><a href="/2025/06/26/%E5%9B%BE%E5%BD%A2%E5%AD%A6/Games101/03_GAMES101_%E5%8F%98%E6%8D%A2(%E4%BA%8C%E7%BB%B4%E4%B8%8E%E4%B8%89%E7%BB%B4)/" title="03_GAMES101_变换(二维与三维)"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2025-06-26</div><div class="title">03_GAMES101_变换(二维与三维)</div></div></a></div><div><a href="/2025/06/27/%E5%9B%BE%E5%BD%A2%E5%AD%A6/Games101/04_GAMES101_%E5%8F%98%E6%8D%A2(%E6%A8%A1%E5%9E%8B%E3%80%81%E8%A7%86%E5%9B%BE%E3%80%81%E6%8A%95%E5%BD%B1)/" title="04_GAMES101_变换(模型、视图、投影)"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2025-06-27</div><div class="title">04_GAMES101_变换(模型、视图、投影)</div></div></a></div><div><a href="/2025/06/30/%E5%9B%BE%E5%BD%A2%E5%AD%A6/Games101/05_GAMES101_%E5%85%89%E6%A0%85%E5%8C%96/" title="05_GAMES101_光栅化"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2025-06-30</div><div class="title">05_GAMES101_光栅化</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/./img/1.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Scenery</div><div class="author-info__description">今天不想跑，所以才去跑</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">73</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">13</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/chjm0121" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="/1595718686@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-Bresenham-%E7%9B%B4%E7%BA%BF%E7%BB%98%E5%88%B6%E7%AE%97%E6%B3%95"><span class="toc-text">1 Bresenham 直线绘制算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-%E9%97%AE%E9%A2%98"><span class="toc-text">1.1 问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86"><span class="toc-text">1.2 前置知识</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-%E5%85%B7%E4%BD%93%E6%8E%A8%E5%AF%BC"><span class="toc-text">1.3 具体推导</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-%E7%89%B9%E6%AE%8A%E6%83%85%E5%86%B5%E7%9A%84%E8%BD%AC%E6%8D%A2"><span class="toc-text">1.4 特殊情况的转换</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E4%B8%89%E8%A7%92%E5%BD%A2%E5%85%89%E6%A0%85%E5%8C%96%E7%AE%97%E6%B3%95"><span class="toc-text">2 三角形光栅化算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E9%87%87%E6%A0%B7"><span class="toc-text">2.1 采样</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-inSide-%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-text">2.2 inSide 的实现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-1-%E5%88%A4%E6%96%AD%E7%82%B9-x-y-%E6%98%AF%E5%90%A6%E5%9C%A8%E4%B8%89%E8%A7%92%E5%BD%A2%E5%86%85"><span class="toc-text">2.2.1 判断点 (x, y) 是否在三角形内</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-%E5%8C%85%E5%9B%B4%E7%9B%92-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96"><span class="toc-text">2.3 包围盒 (性能优化)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-%E9%87%87%E6%A0%B7%E5%B8%A6%E6%9D%A5%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-text">2.4 采样带来的问题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E6%8A%97%E9%94%AF%E9%BD%BF-%E5%8F%8D%E8%B5%B0%E6%A0%B7%EF%BC%88Anti-Aliasing%EF%BC%89"><span class="toc-text">3 抗锯齿 &#x2F; 反走样（Anti-Aliasing）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-%E6%B7%B7%E5%8F%A0-%E8%B5%B0%E6%A0%B7-Aliasing"><span class="toc-text">3.1 混叠 &#x2F; 走样 (Aliasing)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-%E5%82%85%E9%87%8C%E5%8F%B6%E7%BA%A7%E6%95%B0"><span class="toc-text">3.2 傅里叶级数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2"><span class="toc-text">3.3 傅里叶变换</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-1-%E8%BD%AC%E6%8D%A2%E5%85%AC%E5%BC%8F"><span class="toc-text">3.3.1 转换公式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-2-%E6%97%B6%E5%9F%9F%E5%92%8C%E9%A2%91%E5%9F%9F"><span class="toc-text">3.3.2 时域和频域</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-3-%E4%BD%8E%E9%A2%91%E5%92%8C%E9%AB%98%E9%A2%91"><span class="toc-text">3.3.3 低频和高频</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-%E6%BB%A4%E6%B3%A2-Filtering"><span class="toc-text">3.4 滤波 (Filtering)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-5-%E5%8D%B7%E7%A7%AF-Convolution"><span class="toc-text">3.5 卷积 (Convolution)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-5-1-%E7%A9%BA%E9%97%B4%E5%9F%9F%E5%8D%B7%E7%A7%AF-%E2%86%94-%E9%A2%91%E7%8E%87%E5%9F%9F%E4%B9%98%E6%B3%95"><span class="toc-text">3.5.1 空间域卷积 ↔ 频率域乘法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-5-2-%E6%96%B9%E6%A1%86%E6%BB%A4%E6%B3%A2%E5%99%A8"><span class="toc-text">3.5.2 方框滤波器</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-6-%E9%87%87%E6%A0%B7-%E9%87%8D%E5%A4%8D%E9%A2%91%E7%8E%87%E6%88%90%E5%88%86"><span class="toc-text">3.6 采样 &#x3D; 重复频率成分</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-7-%E5%8F%8D%E8%B5%B0%E6%A0%B7%E7%9A%84%E6%80%9D%E8%B7%AF"><span class="toc-text">3.7 反走样的思路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-8-%E8%B6%85%E9%87%87%E6%A0%B7"><span class="toc-text">3.8 超采样</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-9-%E6%8A%97%E9%94%AF%E9%BD%BF%E6%8A%80%E6%9C%AF%E6%BC%94%E8%BF%9B"><span class="toc-text">3.9 抗锯齿技术演进</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-9-1-MSAA"><span class="toc-text">3.9.1 MSAA</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-9-2-%E5%85%B6%E4%BB%96%E6%8A%80%E6%9C%AF"><span class="toc-text">3.9.2 其他技术</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E8%83%8C%E9%9D%A2%E5%89%94%E9%99%A4"><span class="toc-text">4 背面剔除</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-%E5%8E%9F%E7%90%86%EF%BC%9A%E4%BB%80%E4%B9%88%E6%98%AF%E8%83%8C%E9%9D%A2%EF%BC%9F"><span class="toc-text">4.1 原理：什么是背面？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-%E5%88%A4%E6%96%AD%E6%96%B9%E6%B3%95-%EF%BC%9A%E9%A1%B6%E7%82%B9%E7%BB%95%E5%BA%8F-%E9%9D%A2%E6%B3%95%E7%BA%BF"><span class="toc-text">4.2 判断方法 ：顶点绕序 + 面法线</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E6%B7%B1%E5%BA%A6%E6%B5%8B%E8%AF%95-Z-buffering"><span class="toc-text">5 深度测试 (Z-buffering)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-%E7%94%BB%E5%AE%B6%E7%AE%97%E6%B3%95-Painter%E2%80%99s-Algorithm"><span class="toc-text">5.1 画家算法 (Painter’s Algorithm)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-Z-Buffer%EF%BC%88%E6%B7%B1%E5%BA%A6%E7%BC%93%E5%86%B2%E5%8C%BA%EF%BC%89%E7%AE%97%E6%B3%95"><span class="toc-text">5.2 Z - Buffer（深度缓冲区）算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5-2-1-%E6%95%B4%E4%BD%93%E6%80%9D%E8%B7%AF"><span class="toc-text">5.2.1 整体思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-2-2-%E5%85%B3%E4%BA%8E-Z-%E5%80%BC"><span class="toc-text">5.2.2 关于 Z 值</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%89%8D%E6%9C%9F%EF%BC%9A3D-%E6%A8%A1%E5%9E%8B%E4%B8%8E%E6%8A%95%E5%BD%B1%E5%8F%98%E6%8D%A2"><span class="toc-text">前期：3D 模型与投影变换</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%89%E6%A0%85%E5%8C%96%E9%98%B6%E6%AE%B5%EF%BC%9A%E6%8F%92%E5%80%BC%E8%AE%A1%E7%AE%97%E5%83%8F%E7%B4%A0%E7%BA%A7-z-%E5%80%BC"><span class="toc-text">光栅化阶段：插值计算像素级 z 值</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E9%A2%9C%E8%89%B2%E6%B7%B7%E5%90%88"><span class="toc-text">6 颜色混合</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86"><span class="toc-text">6.1 基本原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-%E6%B7%B7%E5%90%88%E5%85%AC%E5%BC%8F-%EF%BC%88%E6%A0%87%E5%87%86%E6%A0%BC%E5%BC%8F%EF%BC%89"><span class="toc-text">6.2 混合公式 （标准格式）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-3-%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0%E5%AE%9E%E7%8E%B0"><span class="toc-text">6.3 相关函数实现</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/08/05/Python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/02_%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90_Numpy/" title="02_数据分析_Numpy">02_数据分析_Numpy</a><time datetime="2025-08-04T21:11:38.000Z" title="发表于 2025-08-05 05:11:38">2025-08-05</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/08/05/Python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/01_%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90_python%E8%AF%AD%E6%B3%95/" title="01_数据分析_python语法">01_数据分析_python语法</a><time datetime="2025-08-04T18:44:45.000Z" title="发表于 2025-08-05 02:44:45">2025-08-05</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/07/29/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E5%9F%BA%E7%A1%80%E5%8E%9F%E7%90%86/13_%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0_%E6%A6%82%E7%8E%87%E5%9B%BE%E6%A8%A1%E5%9E%8B/" title="13_机器学习_概率图模型">13_机器学习_概率图模型</a><time datetime="2025-07-29T00:29:02.000Z" title="发表于 2025-07-29 08:29:02">2025-07-29</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/07/28/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E5%9F%BA%E7%A1%80%E5%8E%9F%E7%90%86/11_%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0_%E8%81%9A%E7%B1%BB/" title="11_机器学习_聚类">11_机器学习_聚类</a><time datetime="2025-07-28T00:19:53.000Z" title="发表于 2025-07-28 08:19:53">2025-07-28</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/07/28/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E5%9F%BA%E7%A1%80%E5%8E%9F%E7%90%86/12_%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0_%E9%99%8D%E7%BB%B4/" title="12_机器学习_降维">12_机器学习_降维</a><time datetime="2025-07-27T20:48:42.000Z" title="发表于 2025-07-28 04:48:42">2025-07-28</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('/./img/1.jpg')"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2025 By Scenery</div><div class="footer_custom_text"><div>波澜不惊</div><div class="footer-div"><img class="footer-icon" src="./img/备案图标.png"><a class="footer-a" target="_blank" rel="noopener" href="http://beian.miit.gov.cn/">皖ICP备2021016944号-1</a></div></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.13.0"></script><script src="/js/main.js?v=4.13.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@5.2.0/instantpage.min.js" type="module"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=4.13.0"></script></div></div></body></html>